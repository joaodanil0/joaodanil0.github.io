{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"D\u00favidas Gerais Como saber qual o endere\u00e7o que o SOC vai buscar, ap\u00f3s iniciar ? (Datasheet ?) Como o u-boot carrega o kernel linux ? Como colocar o Android em um SD card ? VIM3 Raspberry Como foi feito o port do Android ? Git do projeto site com os arquivos compilados","title":"D\u00favidas"},{"location":"#duvidas","text":"","title":"D\u00favidas"},{"location":"#gerais","text":"Como saber qual o endere\u00e7o que o SOC vai buscar, ap\u00f3s iniciar ? (Datasheet ?) Como o u-boot carrega o kernel linux ? Como colocar o Android em um SD card ?","title":"Gerais"},{"location":"#vim3","text":"","title":"VIM3"},{"location":"#raspberry","text":"Como foi feito o port do Android ? Git do projeto site com os arquivos compilados","title":"Raspberry"},{"location":"Android/boot.img/","text":"Boot.img Image by dexmac from Pixabay Introdu\u00e7\u00e3o A algum tempo venho tentando desbravar o mundo do Android embarcado. Sem sombra de d\u00favidas \u00e9 uma \u00e1rea super interessante, mas os desafios s\u00e3o enormes. O sistema est\u00e1 crescendo desenfreadamente e os livros e fontes de estudo n\u00e3o est\u00e3o conseguindo acompanhar essa evolu\u00e7\u00e3o. Al\u00e9m disso, a documenta\u00e7\u00e3o na parte do sistema \u00e9 muito superficial, ao contr\u00e1rio da parte de desenvolvimento de aplica\u00e7\u00f5es ( documenta\u00e7\u00e3o ) que tamb\u00e9m possuem v\u00e1rios cursos pela Internet. Dispositivo usado [Em breve] Antes de Come\u00e7ar [Em breve] Instalando Depend\u00eancias Instalando o Repo []","title":"Boot.img"},{"location":"Android/boot.img/#bootimg","text":"Image by dexmac from Pixabay","title":"Boot.img"},{"location":"Android/boot.img/#introducao","text":"A algum tempo venho tentando desbravar o mundo do Android embarcado. Sem sombra de d\u00favidas \u00e9 uma \u00e1rea super interessante, mas os desafios s\u00e3o enormes. O sistema est\u00e1 crescendo desenfreadamente e os livros e fontes de estudo n\u00e3o est\u00e3o conseguindo acompanhar essa evolu\u00e7\u00e3o. Al\u00e9m disso, a documenta\u00e7\u00e3o na parte do sistema \u00e9 muito superficial, ao contr\u00e1rio da parte de desenvolvimento de aplica\u00e7\u00f5es ( documenta\u00e7\u00e3o ) que tamb\u00e9m possuem v\u00e1rios cursos pela Internet.","title":"Introdu\u00e7\u00e3o"},{"location":"Android/boot.img/#dispositivo-usado","text":"[Em breve]","title":"Dispositivo usado"},{"location":"Android/boot.img/#antes-de-comecar","text":"[Em breve] Instalando Depend\u00eancias Instalando o Repo []","title":"Antes de Come\u00e7ar"},{"location":"Bootloader/VIM3/u-boot/","text":"U-boot na VIM3 (SD Card) U-boot logo baseado no tutorial do pr\u00f3prio u-boot no readthedocs Organizando a estrutura de pastas Ser\u00e3o necess\u00e1rios v\u00e1rios arquivos e pastas durante esse post. Devido isso, iremos usar a seguinte estrutura de pastas . \u251c\u2500\u2500 fip \u251c\u2500\u2500 toolchain \u251c\u2500\u2500 u-boot-mainline \u2514\u2500\u2500 u-boot-vim3 Elas ser\u00e3o criadas ao longo deste post. Baixando o u-boot Mainline O u-boot possui um reposit\u00f3rio no github. Vamos baixa-lo dentro da pasta u-boot-mainline : git clone https://github.com/u-boot/u-boot.git u-boot-mainline Para fazer o cross compile \u00e9 necess\u00e1rio baixar as toolchain . As vers\u00f5es novas do u-boot precisam de vers\u00f5es novas de toolchain , que podem ser encontradas no site da ARM . Nesse post estou usando a vers\u00e3o gcc-arm-10.3-2021.07 (meu link de backup). Compilando o u-boot mainline Uma vez baixado a toolchain ( gcc-arm-10.3-2021.07 ), vamos criar a pasta toolchain e mover a toolchain baixada para dentro dela. Agora, precisamos descompactar a toochain e adicionar os bin\u00e1rios ao path do sistema. Para isso export PATH=CAMINHO_ABSOLUTO/toolchain/gcc-arm-10.3-2021.07-x86_64-aarch64-none-elf/bin:$PATH Observe que a pasta /bin est\u00e1 sendo adicionada ao path . Nela est\u00e3o os execut\u00e1veis que ser\u00e3o utilizados durante o processo de build. Volte para a pasta do u-boot-mainline e execute os seguintes comandos: make khadas-vim3_defconfig O = out/ make CROSS_COMPILE = aarch64-none-elf- O = out/ O par\u00e2metro O define a pasta onde os arquivos compilados ser\u00e3o salvos. O argumento CROSS_COMPILE=aarch64-none-elf- informa qual toolchain ser\u00e1 utilizada no momento da compila\u00e7\u00e3o, essa toolchain precisa estar no path do sistema (como fizemos anteriormente). Dentro os v\u00e1rios compiladores dispon\u00edveis, podemos ver que existem alguns bem conhecidos: c++ , cpp , g++ e muitos outros. toolchain/gcc-arm-10.3-2021.07-x86_64-aarch64-none-elf/bin \u251c\u2500\u2500 aarch64-none-elf-addr2line \u251c\u2500\u2500 aarch64-none-elf-ar \u251c\u2500\u2500 aarch64-none-elf-as \u251c\u2500\u2500 aarch64-none-elf-c++ \u251c\u2500\u2500 aarch64-none-elf-c++filt \u251c\u2500\u2500 aarch64-none-elf-cpp \u251c\u2500\u2500 aarch64-none-elf-elfedit \u251c\u2500\u2500 aarch64-none-elf-g++ ... Se tudo ocorrer como o esperado, uma mensagem similar a essa: aarch64-none-elf-ld.bfd: warning: -z norelro ignored OBJCOPY lib/efi_loader/initrddump.efi LD u-boot OBJCOPY u-boot.srec OBJCOPY u-boot-nodtb.bin RELOC u-boot-nodtb.bin CAT u-boot-dtb.bin COPY u-boot.bin SYM u-boot.sym LD u-boot.elf make[1]: Leaving directory 'CAMINHO_ABSOLUTO/u-boot-mainline/out' O arquivo u-boot.bin deve ter sido gerado dentro da pasta out . Baixando u-boot VIM3 A Khadas tamb\u00e9m possui um reposit\u00f3rio com as vers\u00f5es do u-boot para as diversas placas que eles produzem. Vamos baixar o brach khadas-vims-v2015.01 dentro da pasta u-boot-vim3 git clone https://github.com/khadas/u-boot.git -b khadas-vims-v2015.01 u-boot-vim3 Para fazer o cross compile \u00e9 necess\u00e1rio baixar as toolchain . Seguindo o tutorial base , precisaremos de 2 toolchain ( none-elf e none-eabi ): gcc-linaro-aarch64-none-elf-4.8-2013.11 - Linaro gcc-linaro-aarch64-none-elf-4.8-2013.11 (backup). gcc-linaro-arm-none-eabi-4.8-2013.11 - Linaro gcc-linaro-arm-none-eabi-4.8-2013.11 (backup). Compilando o u-boot VIM3 Antes de adicionar as novas toolchain ao path , limpe o terminal (abra um novo terminal). A vers\u00e3o utilizada no u-boot-mainline n\u00e3o \u00e9 compat\u00edvel com a vers\u00e3o da VIM3 Com as 2 toolchain baixadas, mova-as para a pastas toolchain e descompacte cada uma em sua respectiva pasta. Por fim, adicionar os bin\u00e1rios dos 2 toolchain ao path do sistema export PATH=CAMINHO_ABSOLUTO/toolchain/gcc-linaro-aarch64-none-elf-4.8-2013.11_linux/bin:$PATH export PATH=CAMINHO_ABSOLUTO/toolchain/gcc-linaro-arm-none-eabi-4.8-2013.11_linux/bin:$PATH Com os caminhos adicionados, podemos compilar o u-boot-vim3: make kvim3_defconfig O = out/ make CROSS_COMPILE = aarch64-none-elf- O = out/ O par\u00e2metro O define a pasta onde os arquivos compilados ser\u00e3o salvos. Se tudo ocorrer bem, uma mensagem similar deve aparecer: LD CAMINHO_ABSOLUTO/u-boot-vim3/out/board/khadas/kvim3/firmware/acs.elf OD CAMINHO_ABSOLUTO/u-boot-vim3/out/board/khadas/kvim3/firmware/acs.dump BIN CAMINHO_ABSOLUTO/u-boot-vim3/out/board/khadas/kvim3/firmware/acs.bin Built CAMINHO_ABSOLUTO/u-boot-vim3/out/board/khadas/kvim3/firmware/acs.bin successfully CPP task_entry.s CPP user_task.lds CC task_entry.o CC user_task.o CPP misc.s CC misc.o CC uart.o CC suspend.o CC lib/string.o CC lib/delay.o LD CAMINHO_ABSOLUTO/u-boot-vim3/out/scp_task/bl301.out OBJDUMP CAMINHO_ABSOLUTO/u-boot-vim3/out/scp_task/bl301.dis OBJCOPY CAMINHO_ABSOLUTO/u-boot-vim3/out/scp_task/bl301.bin Juntando tudo O primeiro passo \u00e9 criar a pasta fip . Segundo, \u00e9 preciso baixar esse script da BayLibre ou no meu backup e mover para dentro da pasta fip Para mais informa\u00e7\u00f5es sobre o que \u00e9, acesse: FIP + compilados Terceiro, \u00e9 preciso copiar v\u00e1rios arquivos para dentro da pasta fip : # Arquivos compilados no u-boot-VIM3 cp u-boot-vim3/out/scp_task/bl301.bin fip cp u-boot-vim3/out/board/khadas/kvim3/firmware/acs.bin fip # Copia o u-boot.bin (mainline) e renomeia para bl33.bin cp u-boot-mainline/out/u-boot.bin fip/bl33.bin # Arquivos pr\u00e9-compilados (s\u00e3o fornecidos pela khadas) cp u-boot-vim3/fip/g12b/bl2.bin fip cp u-boot-vim3/fip/g12b/bl30.bin fip cp u-boot-vim3/fip/g12b/bl31.bin fip cp u-boot-vim3/fip/g12b/ddr3_1d.fw fip cp u-boot-vim3/fip/g12b/ddr4_1d.fw fip cp u-boot-vim3/fip/g12b/ddr4_2d.fw fip cp u-boot-vim3/fip/g12b/diag_lpddr4.fw fip cp u-boot-vim3/fip/g12b/lpddr3_1d.fw fip cp u-boot-vim3/fip/g12b/lpddr4_1d.fw fip cp u-boot-vim3/fip/g12b/lpddr4_2d.fw fip cp u-boot-vim3/fip/g12b/piei.fw fip cp u-boot-vim3/fip/g12b/aml_ddr.fw fip cp u-boot-vim3/fip/g12b/aml_encrypt_g12b fip Concatenando os arquivos Pra concatenar as informa\u00e7\u00f5es, vamos utilizar o script da baylibre (dentro da pasta fip ) # Adiciona um padding no bl30.bin e bl301.bin # depois concatena os dois, gerando bl30_new.bin bash blx_fix_g12a.sh bl30.bin zero_tmp bl30_zero.bin bl301.bin bl301_zero.bin bl30_new.bin bl30 # Adiciona um padding no bl2.bin e acs.bin # depois concatena os dois, gerando bl2_new.bin bash blx_fix_g12a.sh bl2.bin zero_tmp bl2_zero.bin acs.bin bl21_zero.bin bl2_new.bin bl2 Encriptando os arquivos Para mais informa\u00e7\u00f5es, acesse: link # Adiciona assinatura no cabe\u00e7alho do bin\u00e1rio ./aml_encrypt_g12b --bl2sig --input bl2_new.bin --output bl2.n.bin.sig # Adiciona assinatura no cabe\u00e7alho do bin\u00e1rio ./aml_encrypt_g12b --bl3sig --input bl31.bin --output bl31.img.enc --level v3 --type bl3 # Adiciona e encripta a assinatura no cabe\u00e7alho do bin\u00e1rio ./aml_encrypt_g12b --bl30sig --input bl30_new.bin --output bl30_new.bin.g12a.enc --level v3 ./aml_encrypt_g12b --bl3sig --input bl30_new.bin.g12a.enc --output bl30_new.bin.enc --level v3 --type bl301 # Adiciona a assinatura no cabe\u00e7alho, um padding no final do bin\u00e1rio e comprime o bin\u00e1rio ./aml_encrypt_g12b --bl3sig --input bl33.bin --compress lz4 --output bl33.bin.enc --level v3 --type bl33 --compress lz4 # Gera o bin\u00e1rio do u-boot com as assinaturas concatenadas ./aml_encrypt_g12b --bootmk --output u-boot-bin --bl2 bl2.n.bin.sig --bl30 bl30_new.bin.enc --bl31 bl31.img.enc \\ --bl33 bl33.bin.enc --ddrfw1 ddr4_1d.fw --ddrfw2 ddr4_2d.fw \\ --ddrfw3 ddr3_1d.fw --ddrfw4 piei.fw --ddrfw5 lpddr4_1d.fw \\ --ddrfw6 lpddr4_2d.fw --ddrfw7 diag_lpddr4.fw --ddrfw8 aml_ddr.fw \\ --ddrfw9 lpddr3_1d.fw --level v3 Passando o u-boot para o SD Card $ DEV=/dev/your_sd_device $ dd if=fip/u-boot.bin.sd.bin of=$DEV conv=fsync,notrunc bs=512 skip=1 seek=1 $ dd if=fip/u-boot.bin.sd.bin of=$DEV conv=fsync,notrunc bs=1 count=444","title":"U-boot na VIM3 (SD Card)"},{"location":"Bootloader/VIM3/u-boot/#u-boot-na-vim3-sd-card","text":"U-boot logo baseado no tutorial do pr\u00f3prio u-boot no readthedocs","title":"U-boot na VIM3 (SD Card)"},{"location":"Bootloader/VIM3/u-boot/#organizando-a-estrutura-de-pastas","text":"Ser\u00e3o necess\u00e1rios v\u00e1rios arquivos e pastas durante esse post. Devido isso, iremos usar a seguinte estrutura de pastas . \u251c\u2500\u2500 fip \u251c\u2500\u2500 toolchain \u251c\u2500\u2500 u-boot-mainline \u2514\u2500\u2500 u-boot-vim3 Elas ser\u00e3o criadas ao longo deste post.","title":"Organizando a estrutura de pastas"},{"location":"Bootloader/VIM3/u-boot/#baixando-o-u-boot-mainline","text":"O u-boot possui um reposit\u00f3rio no github. Vamos baixa-lo dentro da pasta u-boot-mainline : git clone https://github.com/u-boot/u-boot.git u-boot-mainline Para fazer o cross compile \u00e9 necess\u00e1rio baixar as toolchain . As vers\u00f5es novas do u-boot precisam de vers\u00f5es novas de toolchain , que podem ser encontradas no site da ARM . Nesse post estou usando a vers\u00e3o gcc-arm-10.3-2021.07 (meu link de backup).","title":"Baixando o u-boot Mainline"},{"location":"Bootloader/VIM3/u-boot/#compilando-o-u-boot-mainline","text":"Uma vez baixado a toolchain ( gcc-arm-10.3-2021.07 ), vamos criar a pasta toolchain e mover a toolchain baixada para dentro dela. Agora, precisamos descompactar a toochain e adicionar os bin\u00e1rios ao path do sistema. Para isso export PATH=CAMINHO_ABSOLUTO/toolchain/gcc-arm-10.3-2021.07-x86_64-aarch64-none-elf/bin:$PATH Observe que a pasta /bin est\u00e1 sendo adicionada ao path . Nela est\u00e3o os execut\u00e1veis que ser\u00e3o utilizados durante o processo de build. Volte para a pasta do u-boot-mainline e execute os seguintes comandos: make khadas-vim3_defconfig O = out/ make CROSS_COMPILE = aarch64-none-elf- O = out/ O par\u00e2metro O define a pasta onde os arquivos compilados ser\u00e3o salvos. O argumento CROSS_COMPILE=aarch64-none-elf- informa qual toolchain ser\u00e1 utilizada no momento da compila\u00e7\u00e3o, essa toolchain precisa estar no path do sistema (como fizemos anteriormente). Dentro os v\u00e1rios compiladores dispon\u00edveis, podemos ver que existem alguns bem conhecidos: c++ , cpp , g++ e muitos outros. toolchain/gcc-arm-10.3-2021.07-x86_64-aarch64-none-elf/bin \u251c\u2500\u2500 aarch64-none-elf-addr2line \u251c\u2500\u2500 aarch64-none-elf-ar \u251c\u2500\u2500 aarch64-none-elf-as \u251c\u2500\u2500 aarch64-none-elf-c++ \u251c\u2500\u2500 aarch64-none-elf-c++filt \u251c\u2500\u2500 aarch64-none-elf-cpp \u251c\u2500\u2500 aarch64-none-elf-elfedit \u251c\u2500\u2500 aarch64-none-elf-g++ ... Se tudo ocorrer como o esperado, uma mensagem similar a essa: aarch64-none-elf-ld.bfd: warning: -z norelro ignored OBJCOPY lib/efi_loader/initrddump.efi LD u-boot OBJCOPY u-boot.srec OBJCOPY u-boot-nodtb.bin RELOC u-boot-nodtb.bin CAT u-boot-dtb.bin COPY u-boot.bin SYM u-boot.sym LD u-boot.elf make[1]: Leaving directory 'CAMINHO_ABSOLUTO/u-boot-mainline/out' O arquivo u-boot.bin deve ter sido gerado dentro da pasta out .","title":"Compilando o u-boot mainline"},{"location":"Bootloader/VIM3/u-boot/#baixando-u-boot-vim3","text":"A Khadas tamb\u00e9m possui um reposit\u00f3rio com as vers\u00f5es do u-boot para as diversas placas que eles produzem. Vamos baixar o brach khadas-vims-v2015.01 dentro da pasta u-boot-vim3 git clone https://github.com/khadas/u-boot.git -b khadas-vims-v2015.01 u-boot-vim3 Para fazer o cross compile \u00e9 necess\u00e1rio baixar as toolchain . Seguindo o tutorial base , precisaremos de 2 toolchain ( none-elf e none-eabi ): gcc-linaro-aarch64-none-elf-4.8-2013.11 - Linaro gcc-linaro-aarch64-none-elf-4.8-2013.11 (backup). gcc-linaro-arm-none-eabi-4.8-2013.11 - Linaro gcc-linaro-arm-none-eabi-4.8-2013.11 (backup).","title":"Baixando u-boot VIM3"},{"location":"Bootloader/VIM3/u-boot/#compilando-o-u-boot-vim3","text":"Antes de adicionar as novas toolchain ao path , limpe o terminal (abra um novo terminal). A vers\u00e3o utilizada no u-boot-mainline n\u00e3o \u00e9 compat\u00edvel com a vers\u00e3o da VIM3 Com as 2 toolchain baixadas, mova-as para a pastas toolchain e descompacte cada uma em sua respectiva pasta. Por fim, adicionar os bin\u00e1rios dos 2 toolchain ao path do sistema export PATH=CAMINHO_ABSOLUTO/toolchain/gcc-linaro-aarch64-none-elf-4.8-2013.11_linux/bin:$PATH export PATH=CAMINHO_ABSOLUTO/toolchain/gcc-linaro-arm-none-eabi-4.8-2013.11_linux/bin:$PATH Com os caminhos adicionados, podemos compilar o u-boot-vim3: make kvim3_defconfig O = out/ make CROSS_COMPILE = aarch64-none-elf- O = out/ O par\u00e2metro O define a pasta onde os arquivos compilados ser\u00e3o salvos. Se tudo ocorrer bem, uma mensagem similar deve aparecer: LD CAMINHO_ABSOLUTO/u-boot-vim3/out/board/khadas/kvim3/firmware/acs.elf OD CAMINHO_ABSOLUTO/u-boot-vim3/out/board/khadas/kvim3/firmware/acs.dump BIN CAMINHO_ABSOLUTO/u-boot-vim3/out/board/khadas/kvim3/firmware/acs.bin Built CAMINHO_ABSOLUTO/u-boot-vim3/out/board/khadas/kvim3/firmware/acs.bin successfully CPP task_entry.s CPP user_task.lds CC task_entry.o CC user_task.o CPP misc.s CC misc.o CC uart.o CC suspend.o CC lib/string.o CC lib/delay.o LD CAMINHO_ABSOLUTO/u-boot-vim3/out/scp_task/bl301.out OBJDUMP CAMINHO_ABSOLUTO/u-boot-vim3/out/scp_task/bl301.dis OBJCOPY CAMINHO_ABSOLUTO/u-boot-vim3/out/scp_task/bl301.bin","title":"Compilando o u-boot VIM3"},{"location":"Bootloader/VIM3/u-boot/#juntando-tudo","text":"O primeiro passo \u00e9 criar a pasta fip . Segundo, \u00e9 preciso baixar esse script da BayLibre ou no meu backup e mover para dentro da pasta fip Para mais informa\u00e7\u00f5es sobre o que \u00e9, acesse: FIP + compilados Terceiro, \u00e9 preciso copiar v\u00e1rios arquivos para dentro da pasta fip : # Arquivos compilados no u-boot-VIM3 cp u-boot-vim3/out/scp_task/bl301.bin fip cp u-boot-vim3/out/board/khadas/kvim3/firmware/acs.bin fip # Copia o u-boot.bin (mainline) e renomeia para bl33.bin cp u-boot-mainline/out/u-boot.bin fip/bl33.bin # Arquivos pr\u00e9-compilados (s\u00e3o fornecidos pela khadas) cp u-boot-vim3/fip/g12b/bl2.bin fip cp u-boot-vim3/fip/g12b/bl30.bin fip cp u-boot-vim3/fip/g12b/bl31.bin fip cp u-boot-vim3/fip/g12b/ddr3_1d.fw fip cp u-boot-vim3/fip/g12b/ddr4_1d.fw fip cp u-boot-vim3/fip/g12b/ddr4_2d.fw fip cp u-boot-vim3/fip/g12b/diag_lpddr4.fw fip cp u-boot-vim3/fip/g12b/lpddr3_1d.fw fip cp u-boot-vim3/fip/g12b/lpddr4_1d.fw fip cp u-boot-vim3/fip/g12b/lpddr4_2d.fw fip cp u-boot-vim3/fip/g12b/piei.fw fip cp u-boot-vim3/fip/g12b/aml_ddr.fw fip cp u-boot-vim3/fip/g12b/aml_encrypt_g12b fip","title":"Juntando tudo"},{"location":"Bootloader/VIM3/u-boot/#concatenando-os-arquivos","text":"Pra concatenar as informa\u00e7\u00f5es, vamos utilizar o script da baylibre (dentro da pasta fip ) # Adiciona um padding no bl30.bin e bl301.bin # depois concatena os dois, gerando bl30_new.bin bash blx_fix_g12a.sh bl30.bin zero_tmp bl30_zero.bin bl301.bin bl301_zero.bin bl30_new.bin bl30 # Adiciona um padding no bl2.bin e acs.bin # depois concatena os dois, gerando bl2_new.bin bash blx_fix_g12a.sh bl2.bin zero_tmp bl2_zero.bin acs.bin bl21_zero.bin bl2_new.bin bl2","title":"Concatenando os arquivos"},{"location":"Bootloader/VIM3/u-boot/#encriptando-os-arquivos","text":"Para mais informa\u00e7\u00f5es, acesse: link # Adiciona assinatura no cabe\u00e7alho do bin\u00e1rio ./aml_encrypt_g12b --bl2sig --input bl2_new.bin --output bl2.n.bin.sig # Adiciona assinatura no cabe\u00e7alho do bin\u00e1rio ./aml_encrypt_g12b --bl3sig --input bl31.bin --output bl31.img.enc --level v3 --type bl3 # Adiciona e encripta a assinatura no cabe\u00e7alho do bin\u00e1rio ./aml_encrypt_g12b --bl30sig --input bl30_new.bin --output bl30_new.bin.g12a.enc --level v3 ./aml_encrypt_g12b --bl3sig --input bl30_new.bin.g12a.enc --output bl30_new.bin.enc --level v3 --type bl301 # Adiciona a assinatura no cabe\u00e7alho, um padding no final do bin\u00e1rio e comprime o bin\u00e1rio ./aml_encrypt_g12b --bl3sig --input bl33.bin --compress lz4 --output bl33.bin.enc --level v3 --type bl33 --compress lz4 # Gera o bin\u00e1rio do u-boot com as assinaturas concatenadas ./aml_encrypt_g12b --bootmk --output u-boot-bin --bl2 bl2.n.bin.sig --bl30 bl30_new.bin.enc --bl31 bl31.img.enc \\ --bl33 bl33.bin.enc --ddrfw1 ddr4_1d.fw --ddrfw2 ddr4_2d.fw \\ --ddrfw3 ddr3_1d.fw --ddrfw4 piei.fw --ddrfw5 lpddr4_1d.fw \\ --ddrfw6 lpddr4_2d.fw --ddrfw7 diag_lpddr4.fw --ddrfw8 aml_ddr.fw \\ --ddrfw9 lpddr3_1d.fw --level v3","title":"Encriptando os arquivos"},{"location":"Bootloader/VIM3/u-boot/#passando-o-u-boot-para-o-sd-card","text":"$ DEV=/dev/your_sd_device $ dd if=fip/u-boot.bin.sd.bin of=$DEV conv=fsync,notrunc bs=512 skip=1 seek=1 $ dd if=fip/u-boot.bin.sd.bin of=$DEV conv=fsync,notrunc bs=1 count=444","title":"Passando o u-boot para o SD Card"},{"location":"Bootloader/VIM3/Android/Carregando/","text":"Decifrando o BOOTCMD Image by Gerd Altmann from Pixabay Introdu\u00e7\u00e3o Na minha saga para desvendar o mundo dos sistemas embarcados, nesse post eu pretendo entender explicar como o u-boot mainline carrega o kernel Android na VIM3 . O bootcmd Depois que que o u-boot \u00e9 carregado, ele executa comandos para encontrar o kernel. Para isso, \u00e9 gerado um script para checar as poss\u00edveis formas de carrega-lo. O primeiro passo foi dar o comando printenv no console do u-boot, resultando nas seguintes informa\u00e7\u00f5es: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 arch = arm avb_verify = avb init ${ mmcdev } ; avb verify $slot_suffix ; baudrate = 115200 board = vim3 board_name = vim3 boot_a_script = load ${ devtype } ${ devnum } : ${ distro_bootpart } ${ scriptaddr } ${ prefix }${ script } ; source ${ scriptaddr } boot_efi_binary = load ${ devtype } ${ devnum } : ${ distro_bootpart } ${ kernel_addr_r } efi/boot/bootaa64.efi ; if fdt addr -q ${ fdt_addr_r } ; then bootefi ${ kernel_addr_r } ${ fdt_addr_r } ; else bootefi ${ kernel_addr_r } ${ fdtcontroladdr } ; fi boot_efi_bootmgr = if fdt addr -q ${ fdt_addr_r } ; then bootefi bootmgr ${ fdt_addr_r } ; else bootefi bootmgr ; fi boot_extlinux = sysboot ${ devtype } ${ devnum } : ${ distro_bootpart } any ${ scriptaddr } ${ prefix }${ boot_syslinux_conf } boot_net_usb_start = usb start boot_pci_enum = pci enum boot_prefixes = / /boot/ boot_script_dhcp = boot.scr.uimg boot_scripts = boot.scr.uimg boot.scr boot_source = sd boot_syslinux_conf = extlinux/extlinux.conf boot_targets = fastboot recovery system panic bootcmd = run distro_bootcmd bootcmd_fastboot = setenv run_fastboot 0 ; if test \" ${ boot_source } \" = \"usb\" ; then echo Fastboot forced by usb rom boot ; setenv run_fastboot 1 ; fi ; if test \" ${ run_fastboot } \" -eq 0 ; then if gpt verify mmc ${ mmcdev } ${ partitions } ; then ; else echo Broken MMC partition scheme ; setenv run_fastboot 1 ; fi ; fi ; if test \" ${ run_fastboot } \" -eq 0 ; then if bcb load 2 misc ; then if bcb test command = bootonce-bootloader ; then echo BCB: Bootloader boot... ; bcb clear command ; bcb store ; setenv run_fastboot 1 ; elif bcb test command = boot-fastboot ; then echo BCB: fastboot userspace boot... ; setenv force_recovery 1 ; fi ; else echo Warning: BCB is corrupted or does not exist ; fi ; fi ; if test \" ${ run_fastboot } \" -eq 1 ; then echo Running Fastboot... ; fastboot 0 ; fi bootcmd_panic = fastboot 0 ; reset bootcmd_recovery = pinmux dev pinctrl@14 ; pinmux dev pinctrl@40 ; setenv run_recovery 0 ; if run check_button ; then echo Recovery button is pressed ; setenv run_recovery 1 ; fi ; if bcb load 2 misc ; then if bcb test command = boot-recovery ; then echo BCB: Recovery boot... ; setenv run_recovery 1 ; fi ; else echo Warning: BCB is corrupted or does not exist ; fi ; if test \" ${ skip_recovery } \" -eq 1 ; then echo Recovery skipped by environment ; setenv run_recovery 0 ; fi ; if test \" ${ force_recovery } \" -eq 1 ; then echo Recovery forced by environment ; setenv run_recovery 1 ; fi ; if test \" ${ run_recovery } \" -eq 1 ; then echo Running Recovery... ; mmc dev ${ mmcdev } ; setenv bootargs \" ${ bootargs } androidboot.serialno= ${ serial # } \" ; if test \" ${ force_avb } \" -eq 1 ; then if run avb_verify ; then echo AVB verification OK. ; setenv bootargs \" $bootargs $avb_bootargs \" ; else echo AVB verification failed. ; exit ; fi ; else setenv bootargs \" $bootargs androidboot.verifiedbootstate=orange\" ; echo Running without AVB... ; fi ; part start mmc ${ mmcdev } recovery ${ slot_suffix } boot_start ; part size mmc ${ mmcdev } recovery ${ slot_suffix } boot_size ; if mmc read ${ loadaddr } ${ boot_start } ${ boot_size } ; then echo Preparing FDT... ; if test $board_name = sei510 ; then echo \" Reading DTB for sei510...\" ; setenv dtb_index 0 ; elif test $board_name = sei610 ; then echo \" Reading DTB for sei610...\" ; setenv dtb_index 1 ; elif test $board_name = vim3l ; then echo \" Reading DTB for vim3l...\" ; setenv dtb_index 2 ; elif test $board_name = vim3 ; then echo \" Reading DTB for vim3...\" ; setenv dtb_index 3 ; else echo Error: Android boot is not supported for $board_name ; exit ; fi ; abootimg get dtb --index = $dtb_index dtb_start dtb_size ; cp.b $dtb_start $fdt_addr_r $dtb_size ; fdt addr $fdt_addr_r 0x80000 ; if test $board_name = sei510 ; then echo \" Reading DTBO for sei510...\" ; setenv dtbo_index 0 ; elif test $board_name = sei610 ; then echo \" Reading DTBO for sei610...\" ; setenv dtbo_index 1 ; elif test $board_name = vim3l ; then echo \" Reading DTBO for vim3l...\" ; setenv dtbo_index 2 ; elif test $board_name = vim3 ; then echo \" Reading DTBO for vim3...\" ; setenv dtbo_index 3 ; else echo Error: Android boot is not supported for $board_name ; exit ; fi ; part start mmc ${ mmcdev } dtbo ${ slot_suffix } p_dtbo_start ; part size mmc ${ mmcdev } dtbo ${ slot_suffix } p_dtbo_size ; mmc read ${ dtboaddr } ${ p_dtbo_start } ${ p_dtbo_size } ; echo \" Applying DTBOs...\" ; adtimg addr $dtboaddr ; adtimg get dt --index = $dtbo_index dtbo0_addr ; fdt apply $dtbo0_addr ; setenv bootargs \" $bootargs androidboot.dtbo_idx= $dtbo_index \" ; echo Running Android Recovery... ; bootm ${ loadaddr } ${ loadaddr } ${ fdt_addr_r } ; fi ; echo Failed to boot Android... ; reset ; fi bootcmd_system = echo Loading Android boot partition... ; mmc dev ${ mmcdev } ; setenv bootargs ${ bootargs } androidboot.serialno = ${ serial # } ; if test \" ${ force_avb } \" -eq 1 ; then if run avb_verify ; then echo AVB verification OK. ; setenv bootargs \" $bootargs $avb_bootargs \" ; else echo AVB verification failed. ; exit ; fi ; else setenv bootargs \" $bootargs androidboot.verifiedbootstate=orange\" ; echo Running without AVB... ; fi ; part start mmc ${ mmcdev } boot ${ slot_suffix } boot_start ; part size mmc ${ mmcdev } boot ${ slot_suffix } boot_size ; if mmc read ${ loadaddr } ${ boot_start } ${ boot_size } ; then echo Preparing FDT... ; if test $board_name = sei510 ; then echo \" Reading DTB for sei510...\" ; setenv dtb_index 0 ; elif test $board_name = sei610 ; then echo \" Reading DTB for sei610...\" ; setenv dtb_index 1 ; elif test $board_name = vim3l ; then echo \" Reading DTB for vim3l...\" ; setenv dtb_index 2 ; elif test $board_name = vim3 ; then echo \" Reading DTB for vim3...\" ; setenv dtb_index 3 ; else echo Error: Android boot is not supported for $board_name ; exit ; fi ; abootimg get dtb --index = $dtb_index dtb_start dtb_size ; cp.b $dtb_start $fdt_addr_r $dtb_size ; fdt addr $fdt_addr_r 0x80000 ; if test $board_name = sei510 ; then echo \" Reading DTBO for sei510...\" ; setenv dtbo_index 0 ; elif test $board_name = sei610 ; then echo \" Reading DTBO for sei610...\" ; setenv dtbo_index 1 ; elif test $board_name = vim3l ; then echo \" Reading DTBO for vim3l...\" ; setenv dtbo_index 2 ; elif test $board_name = vim3 ; then echo \" Reading DTBO for vim3...\" ; setenv dtbo_index 3 ; else echo Error: Android boot is not supported for $board_name ; exit ; fi ; part start mmc ${ mmcdev } dtbo ${ slot_suffix } p_dtbo_start ; part size mmc ${ mmcdev } dtbo ${ slot_suffix } p_dtbo_size ; mmc read ${ dtboaddr } ${ p_dtbo_start } ${ p_dtbo_size } ; echo \" Applying DTBOs...\" ; adtimg addr $dtboaddr ; adtimg get dt --index = $dtbo_index dtbo0_addr ; fdt apply $dtbo0_addr ; setenv bootargs \" $bootargs androidboot.dtbo_idx= $dtbo_index \" ; setenv bootargs \" ${ bootargs } \" ; echo Running Android... ; bootm ${ loadaddr } ${ loadaddr } ${ fdt_addr_r } ; fi ; echo Failed to boot Android... ; bootdelay = 2 check_button = gpio input ${ gpio_recovery } ; test $? -eq 0 ; cpu = armv8 distro_bootcmd = setenv nvme_need_init ; for target in ${ boot_targets } ; do run bootcmd_ ${ target } ; done dtboaddr = 0x08200000 efi_dtb_prefixes = / /dtb/ /dtb/current/ ethaddr = c8:63:14:71:2d:35 fastboot_raw_partition_bootenv = 0x0 0xfff mmcpart 2 fastboot_raw_partition_bootloader = 0x1 0xfff mmcpart 1 fdt_addr_r = 0x01000000 fdtcontroladdr = f0efa100 fdtfile = amlogic/meson-g12b-a311d-khadas-vim3.dtb force_avb = 0 gpio_recovery = 88 kernel_addr_r = 0x01080000 load_efi_dtb = load ${ devtype } ${ devnum } : ${ distro_bootpart } ${ fdt_addr_r } ${ prefix }${ efi_fdtfile } load_logo = if test \" ${ boot_source } \" ! = \"usb\" && gpt verify mmc ${ mmcdev } ${ partitions } ; then ; mmc dev ${ mmcdev } ; part start mmc ${ mmcdev } logo boot_start ; part size mmc ${ mmcdev } logo boot_size ; if mmc read ${ loadaddr } ${ boot_start } ${ boot_size } ; then bmp display ${ loadaddr } m m ; fi ; fi ; loadaddr = 0x01080000 mmc_boot = if mmc dev ${ devnum } ; then devtype = mmc ; run scan_dev_for_boot_part ; fi mmcdev = 2 nvme_boot = run boot_pci_enum ; run nvme_init ; if nvme dev ${ devnum } ; then devtype = nvme ; run scan_dev_for_boot_part ; fi nvme_init = if ${ nvme_need_init } ; then setenv nvme_need_init false ; nvme scan ; fi partitions = uuid_disk = ${ uuid_gpt_disk } ; name = logo,start = 512K,size = 2M,uuid = 43a3305d-150f-4cc9-bd3b-38fca8693846 ; name = misc,size = 512K,uuid = ${ uuid_gpt_misc } ; name = dtbo,size = 8M,uuid = ${ uuid_gpt_dtbo } ; name = vbmeta,size = 512K,uuid = ${ uuid_gpt_vbmeta } ; name = boot,size = 32M,bootable,uuid = ${ uuid_gpt_boot } ; name = recovery,size = 32M,uuid = ${ uuid_gpt_recovery } ; name = cache,size = 256M,uuid = ${ uuid_gpt_cache } ; name = super,size = 1792M,uuid = ${ uuid_gpt_super } ; name = userdata,size = 12786M,uuid = ${ uuid_gpt_userdata } ; name = rootfs,size = -,uuid = ddb8c3f6-d94d-4394-b633-3134139cc2e0 ; pxefile_addr_r = 0x01080000 ramdisk_addr_r = 0x13000000 scan_dev_for_boot = echo Scanning ${ devtype } ${ devnum } : ${ distro_bootpart } ... ; for prefix in ${ boot_prefixes } ; do run scan_dev_for_extlinux ; run scan_dev_for_scripts ; done ; run scan_dev_for_efi ; scan_dev_for_boot_part = part list ${ devtype } ${ devnum } -bootable devplist ; env exists devplist || setenv devplist 1 ; for distro_bootpart in ${ devplist } ; do if fstype ${ devtype } ${ devnum } : ${ distro_bootpart } bootfstype ; then run scan_dev_for_boot ; fi ; done ; setenv devplist scan_dev_for_efi = setenv efi_fdtfile ${ fdtfile } ; for prefix in ${ efi_dtb_prefixes } ; do if test -e ${ devtype } ${ devnum } : ${ distro_bootpart } ${ prefix }${ efi_fdtfile } ; then run load_efi_dtb ; fi ; done ; run boot_efi_bootmgr ; if test -e ${ devtype } ${ devnum } : ${ distro_bootpart } efi/boot/bootaa64.efi ; then echo Found EFI removable media binary efi/boot/bootaa64.efi ; run boot_efi_binary ; echo EFI LOAD FAILED: continuing... ; fi ; setenv efi_fdtfile scan_dev_for_extlinux = if test -e ${ devtype } ${ devnum } : ${ distro_bootpart } ${ prefix }${ boot_syslinux_conf } ; then echo Found ${ prefix }${ boot_syslinux_conf } ; run boot_extlinux ; echo SCRIPT FAILED: continuing... ; fi scan_dev_for_scripts = for script in ${ boot_scripts } ; do if test -e ${ devtype } ${ devnum } : ${ distro_bootpart } ${ prefix }${ script } ; then echo Found U-Boot script ${ prefix }${ script } ; run boot_a_script ; echo SCRIPT FAILED: continuing... ; fi ; done scriptaddr = 0x08000000 serial# = C86314712D35 soc = meson stderr = vidconsole,serial stdin = usbkbd,serial stdout = vidconsole,serial usb_boot = usb start ; if usb dev ${ devnum } ; then devtype = usb ; run scan_dev_for_boot_part ; fi vendor = amlogic Environment size: 9785 /65532 bytes = > Estudaremos inicialmente essa sa\u00edda, come\u00e7ando pelo bootcmd (linha 18). Ele \u00e9 o ponta p\u00e9 inicial para o script. Podemos observar que ele executa outra fun\u00e7\u00e3o: bootcmd = run distro_bootcmd Ele executa a distro_bootcmd (linha 26). O distro_bootcmd Essa fun\u00e7\u00e3o \u00e9 um pouco mais elaborada, quebrei em v\u00e1rias linhas. Vamos analiz\u00e1-las distro_bootcmd = setenv nvme_need_init ; for target in ${ boot_targets } ; do run bootcmd_ ${ target } ; done A flag nvme_need_init n\u00e3o est\u00e1 setada, mas podemos encontrar alguns detalhes no arquivo: include/config_distro_bootcmd.h No diret\u00f3rio do c\u00f3digo fonte do u-boot, n\u00e3o vou focar nessa linha pois n\u00e3o \u00e9 de interesse utilizar o NVME (ainda ). Seguindo no c\u00f3digo, podemos obsevar que a vari\u00e1vel boot_targets (atribu\u00edda na linha 17) \u00e9 iterada com os seguintes valores: boot_targets=fastboot recovery system panic Cada valor \u00e9 concatenado com a string bootcmd_ , resultando em: bootcmd_fastboot bootcmd_recovery bootcmd_system bootcmd_panic As ramifica\u00e7\u00f5es do bootcmd_ O distro_bootcmd acaba executando outras 4 fun\u00e7\u00f5es, vamos entender o que elas fazem. O bootcmd_fastboot Atribu\u00edda na linha 19, ela possui a seguinte implementa\u00e7\u00e3o: bootcmd_fastboot = setenv run_fastboot 0 ; if test \" ${ boot_source } \" = \"usb\" ; then echo Fastboot forced by usb rom boot ; setenv run_fastboot 1 ; fi ; if test \" ${ run_fastboot } \" -eq 0 ; then if gpt verify mmc ${ mmcdev } ${ partitions } ; then ; else echo Broken MMC partition scheme ; setenv run_fastboot 1 ; fi ; fi ; if test \" ${ run_fastboot } \" -eq 0 ; then if bcb load 2 misc ; then if bcb test command = bootonce-bootloader ; then echo BCB: Bootloader boot... ; bcb clear command ; bcb store ; setenv run_fastboot 1 ; elif bcb test command = boot-fastboot ; then echo BCB: fastboot userspace boot... ; setenv force_recovery 1 ; fi ; else echo Warning: BCB is corrupted or does not exist ; fi ; fi ; if test \" ${ run_fastboot } \" -eq 1 ; then echo Running Fastboot... ; fastboot 0 ; fi A flag run_fastboot \u00e9 setada para 0. A vari\u00e1vel boot_source \u00e9 atribu\u00edda na linha 15: boot_source=sd Com isso, o primeiro if n\u00e3o \u00e9 acionado. No proximo if j\u00e1 sabemos que run_fastboot==0 , ao entrar no if \u00e9 checado a vari\u00e1vel mmcdev que \u00e9 atribu\u00edda na linha 42 e a vari\u00e1vel partitions , atribu\u00edda na linha 45: mmcdev = 2 partitions = uuid_disk = ${ uuid_gpt_disk } ; name = logo,start = 512K,size = 2M,uuid = 43a3305d-150f-4cc9-bd3b-38fca8693846 ; name = misc,size = 512K,uuid = ${ uuid_gpt_misc } ; name = dtbo,size = 8M,uuid = ${ uuid_gpt_dtbo } ; name = vbmeta,size = 512K,uuid = ${ uuid_gpt_vbmeta } ; name = boot,size = 32M,bootable,uuid = ${ uuid_gpt_boot } ; name = recovery,size = 32M,uuid = ${ uuid_gpt_recovery } ; name = cache,size = 256M,uuid = ${ uuid_gpt_cache } ; name = super,size = 1792M,uuid = ${ uuid_gpt_super } ; name = userdata,size = 12786M,uuid = ${ uuid_gpt_userdata } ; name = rootfs,size = -,uuid = ddb8c3f6-d94d-4394-b633-3134139cc2e0 ; Logo, na linha if gpt verify mmc ${mmcdev} ${partitions}; then; \u00e9 checado se as parti\u00e7\u00f5es existem, nesse caso no eMMC da placa ( mmcdev=2 ), caso contr\u00e1rio imprime a mensagem de erro Broken MMC partition scheme; e seta a flag run_fastboot para 1. Mais adiante, \u00e9 checado novamente a flag run_fastboot . Caso as parti\u00e7\u00f5es no eMMC estejam corretas, \u00e9 checado if bcb load 2 misc; then . Essa linha tenta carregar a parti\u00e7\u00e3o misc do eMMC (mais informa\u00e7\u00f5es nesse link ). Se tudo der certo, em seguida \u00e9 checado o conte\u00fado da v\u00e1ri\u00e1vel command que foi guardada dentro da parti\u00e7\u00e3o misc : if bcb test command = bootonce-bootloader; then elif bcb test command = boot-fastboot; then Caso algum problema ocorra ao carregar a parti\u00e7\u00e3o misc , a seguinte mensagem \u00e9 impressa na tela Warning: BCB is corrupted or does not exist; . O \u00faltimo if checa se a flag run_fastboot \u00e9 1, caso positivo \u00e9 impresso na tela a mensagem Running Fastboot... e entra no modo Fastboot com o comando fastboot 0 . O bootcmd_recovery Atribu\u00eddo na linha 21 e possui a seguinte implementa\u00e7\u00e3o: bootcmd_recovery = pinmux dev pinctrl@14 ; pinmux dev pinctrl@40 ; setenv run_recovery 0 ; if run check_button ; then echo Recovery button is pressed ; setenv run_recovery 1 ; fi ; if bcb load 2 misc ; then if bcb test command = boot-recovery ; then echo BCB: Recovery boot... ; setenv run_recovery 1 ; fi ; else echo Warning: BCB is corrupted or does not exist ; fi ; if test \" ${ skip_recovery } \" -eq 1 ; then echo Recovery skipped by environment ; setenv run_recovery 0 ; fi ; if test \" ${ force_recovery } \" -eq 1 ; then echo Recovery forced by environment ; setenv run_recovery 1 ; fi ; if test \" ${ run_recovery } \" -eq 1 ; then echo Running Recovery... ; mmc dev ${ mmcdev } ; setenv bootargs \" ${ bootargs } androidboot.serialno= ${ serial # } \" ; if test \" ${ force_avb } \" -eq 1 ; then if run avb_verify ; then echo AVB verification OK. ; setenv bootargs \" $bootargs $avb_bootargs \" ; else echo AVB verification failed. ; exit ; fi ; else setenv bootargs \" $bootargs androidboot.verifiedbootstate=orange\" ; echo Running without AVB... ; fi ; part start mmc ${ mmcdev } recovery ${ slot_suffix } boot_start ; part size mmc ${ mmcdev } recovery ${ slot_suffix } boot_size ; if mmc read ${ loadaddr } ${ boot_start } ${ boot_size } ; then echo Preparing FDT... ; if test $board_name = sei510 ; then echo \" Reading DTB for sei510...\" ; setenv dtb_index 0 ; elif test $board_name = sei610 ; then echo \" Reading DTB for sei610...\" ; setenv dtb_index 1 ; elif test $board_name = vim3l ; then echo \" Reading DTB for vim3l...\" ; setenv dtb_index 2 ; elif test $board_name = vim3 ; then echo \" Reading DTB for vim3...\" ; setenv dtb_index 3 ; else echo Error: Android boot is not supported for $board_name ; exit ; fi ; abootimg get dtb --index = $dtb_index dtb_start dtb_size ; cp.b $dtb_start $fdt_addr_r $dtb_size ; fdt addr $fdt_addr_r 0x80000 ; if test $board_name = sei510 ; then echo \" Reading DTBO for sei510...\" ; setenv dtbo_index 0 ; elif test $board_name = sei610 ; then echo \" Reading DTBO for sei610...\" ; setenv dtbo_index 1 ; elif test $board_name = vim3l ; then echo \" Reading DTBO for vim3l...\" ; setenv dtbo_index 2 ; elif test $board_name = vim3 ; then echo \" Reading DTBO for vim3...\" ; setenv dtbo_index 3 ; else echo Error: Android boot is not supported for $board_name ; exit ; fi ; part start mmc ${ mmcdev } dtbo ${ slot_suffix } p_dtbo_start ; part size mmc ${ mmcdev } dtbo ${ slot_suffix } p_dtbo_size ; mmc read ${ dtboaddr } ${ p_dtbo_start } ${ p_dtbo_size } ; echo \" Applying DTBOs...\" ; adtimg addr $dtboaddr ; adtimg get dt --index = $dtbo_index dtbo0_addr ; fdt apply $dtbo0_addr ; setenv bootargs \" $bootargs androidboot.dtbo_idx= $dtbo_index \" ; echo Running Android Recovery... ; bootm ${ loadaddr } ${ loadaddr } ${ fdt_addr_r } ; fi ; echo Failed to boot Android... ; reset ; fi As duas primeiras linhas: pinmux dev pinctrl@14; pinmux dev pinctrl@40; A pr\u00edncipio n\u00e3o funcionam, tentei ver o status desses pinos e retornaram pinctrl@14 not found e pinctrl@40 not found . Talvez esteja faltando alguma implementa\u00e7\u00e3o. Seguindo no c\u00f3digo, a flag run_recovery \u00e9 setada para 0 e ent\u00e3o a fun\u00e7\u00e3o check_button \u00e9 checada. Ela foi atribu\u00edda na linha 24: check_button = gpio input ${ gpio_recovery } ; test $? -eq 0 ; Na linha 36 a vari\u00e1vel gpio_recovery=88 \u00e9 atribu\u00edda. Por padr\u00e3o, esse GPIO \u00e9 setado para 1 gpio: pin 88 (gpio 88) value is 1 , logo o valor retornado \u00e9 falso. Dessa forma, a compara\u00e7\u00e3o if run check_button; then n\u00e3o \u00e9 acionada. Mais adiante, a parti\u00e7\u00e3o misc \u00e9 carregada novamente e \u00e9 checado se a vari\u00e1vel command est\u00e1 setada para boot-recovery . Em seguinda, a v\u00e1ri\u00e1vel skip_recovery n\u00e3o est\u00e1 setada, logo n\u00e3o entra no pr\u00f3ximo if . Se a vari\u00e1vel force_recovery foi setada na etapa do bootcmd_fastboot , ent\u00e3o a linha if test \"${force_recovery}\" -eq 1; then \u00e9 acionada \u00e9 a vari\u00e1vel a flag run_recovery \u00e9 setada para 1. Isso faz com que o pr\u00f3ximo if seja acionado ( if test \"${run_recovery}\" -eq 1; then ) e come\u00e7ar o processo de entrar no modo Recovery . Vimos na se\u00e7\u00e3o anterior que mmcdev=2 . Com isso, o comando mmc dev ${mmcdev}; ativa o eMMC. A pr\u00f3xima linha adiciona a vari\u00e1vel bootargs a propriedade androidboot.serialno=${serial#} . A vari\u00e1vel serial# \u00e9 atribu\u00edda na linha 54: serial# = C86314712D35 Seguindo, \u00e9 checado a v\u00e1ri\u00e1vel force_avb=0 , atribu\u00edda na linha 35. Como o Android Verified Boot (AVB) n\u00e3o est\u00e1 setado, \u00e9 adicionado mais uma propriedade ao bootargs : setenv bootargs \" $bootargs androidboot.verifiedbootstate=orange\" ; Mais a frente, temos a linha: part start mmc ${ mmcdev } recovery ${ slot_suffix } boot_start ; a vari\u00e1vel slot_suffix n\u00e3o est\u00e1 setada. Dessa forma, essa linha procura o inicio da parti\u00e7\u00e3o recovery dentro do eMMC e adiciona o valor na vari\u00e1vel boot_start . A linha: part size mmc ${ mmcdev } recovery ${ slot_suffix } boot_size ; \u00e9 semelhante, mas nesse caso armazena o tamanho da parti\u00e7\u00e3o recovery na vari\u00e1vel boot_size . Na linha seguinte: if mmc read ${ loadaddr } ${ boot_start } ${ boot_size } ; then a vari\u00e1vel loadaddr=0x01080000 \u00e9 atribu\u00edda na linha 40. A parti\u00e7\u00e3o recovery \u00e9 carregada e se tudo ocorrer corretamente, segue dentro do if . A vari\u00e1vel board_name=vim3 \u00e9 atribu\u00edda na linha 5, consequentemente, setando a flag setenv dtb_index 3; . A pr\u00f3xima linha: abootimg get dtb --index = $dtb_index dtb_start dtb_size ; Armazena o endere\u00e7o e o tamanho do Device Tree Blob (DTB) nas vari\u00e1veis dtb_start e dtb_size , respectivamente. Seguindo, temos: cp.b $dtb_start $fdt_addr_r $dtb_size ; a vari\u00e1vel fdt_addr_r=0x01000000 \u00e9 atribu\u00edda na linha 32. A linha acima copia o conte\u00fado do DTB para o endere\u00e7o da vari\u00e1vel fdt_addr_r . Ap\u00f3s isso, a localiza\u00e7\u00e3o do ftd \u00e9 setada para o endere\u00e7o 0x80000 , pelo comando: fdt addr $fdt_addr_r 0x80000 ; Agora \u00e9 necess\u00e1rio carregar o Device Tree Blob Overlay (DTBO). Para isso, \u00e9 checando novamente a var\u00edavel board_name , consequentemente, a flag setenv dtb_index 3 \u00e9 setada. As seguintes linhas tem fun\u00e7\u00e3o similar as anteriores: part start mmc ${ mmcdev } dtbo ${ slot_suffix } p_dtbo_start ; part size mmc ${ mmcdev } dtbo ${ slot_suffix } p_dtbo_size ; mmc read ${ dtboaddr } ${ p_dtbo_start } ${ p_dtbo_size } ; a vari\u00e1vel dtboaddr=0x08200000 \u00e9 atribu\u00edda na linha 27. As linhas: adtimg addr $dtboaddr ; adtimg get dt --index = $dtbo_index dtbo0_addr ; fdt apply $dtbo0_addr ; Seta a localiza\u00e7\u00e3o da imagem do DTBO para o endere\u00e7o da vari\u00e1vel dtboaddr , armazena o endere\u00e7o do DTBO na vari\u00e1vel dtbo0_addr . Por fim, aplica o DTBO no DTB. Na linha seguinte, \u00e9 adicionado a propriedade setenv bootargs \"$bootargs androidboot.dtbo_idx=$dtbo_index \" na vari\u00e1vel bootargs . Finalmente, na linha: bootm ${ loadaddr } ${ loadaddr } ${ fdt_addr_r } ; faz o boot da imagem de recovery . O bootcmd_system Atribu\u00eddo na linha 22, ele possui a seguinte implementa\u00e7\u00e3o: bootcmd_system = echo Loading Android boot partition... ; mmc dev ${ mmcdev } ; setenv bootargs ${ bootargs } androidboot.serialno = ${ serial # } ; if test \" ${ force_avb } \" -eq 1 ; then if run avb_verify ; then echo AVB verification OK. ; setenv bootargs \" $bootargs $avb_bootargs \" ; else echo AVB verification failed. ; exit ; fi ; else setenv bootargs \" $bootargs androidboot.verifiedbootstate=orange\" ; echo Running without AVB... ; fi ; part start mmc ${ mmcdev } boot ${ slot_suffix } boot_start ; part size mmc ${ mmcdev } boot ${ slot_suffix } boot_size ; if mmc read ${ loadaddr } ${ boot_start } ${ boot_size } ; then echo Preparing FDT... ; if test $board_name = sei510 ; then echo \" Reading DTB for sei510...\" ; setenv dtb_index 0 ; elif test $board_name = sei610 ; then echo \" Reading DTB for sei610...\" ; setenv dtb_index 1 ; elif test $board_name = vim3l ; then echo \" Reading DTB for vim3l...\" ; setenv dtb_index 2 ; elif test $board_name = vim3 ; then echo \" Reading DTB for vim3...\" ; setenv dtb_index 3 ; else echo Error: Android boot is not supported for $board_name ; exit ; fi ; abootimg get dtb --index = $dtb_index dtb_start dtb_size ; cp.b $dtb_start $fdt_addr_r $dtb_size ; fdt addr $fdt_addr_r 0x80000 ; if test $board_name = sei510 ; then echo \" Reading DTBO for sei510...\" ; setenv dtbo_index 0 ; elif test $board_name = sei610 ; then echo \" Reading DTBO for sei610...\" ; setenv dtbo_index 1 ; elif test $board_name = vim3l ; then echo \" Reading DTBO for vim3l...\" ; setenv dtbo_index 2 ; elif test $board_name = vim3 ; then echo \" Reading DTBO for vim3...\" ; setenv dtbo_index 3 ; else echo Error: Android boot is not supported for $board_name ; exit ; fi ; part start mmc ${ mmcdev } dtbo ${ slot_suffix } p_dtbo_start ; part size mmc ${ mmcdev } dtbo ${ slot_suffix } p_dtbo_size ; mmc read ${ dtboaddr } ${ p_dtbo_start } ${ p_dtbo_size } ; echo \" Applying DTBOs...\" ; adtimg addr $dtboaddr ; adtimg get dt --index = $dtbo_index dtbo0_addr ; fdt apply $dtbo0_addr ; setenv bootargs \" $bootargs androidboot.dtbo_idx= $dtbo_index \" ; setenv bootargs \" ${ bootargs } \" ; echo Running Android... ; bootm ${ loadaddr } ${ loadaddr } ${ fdt_addr_r } ; fi ; echo Failed to boot Android... ; Todo o processo \u00e9 o mesmo do modo recovery a diferen\u00e7a fica nas seguintes linhas: part start mmc ${ mmcdev } boot ${ slot_suffix } boot_start ; part size mmc ${ mmcdev } boot ${ slot_suffix } boot_size ; Observe que agora o script busca pela parti\u00e7\u00e3o boot . O resto segue inalterado. O bootcmd_panic Atribu\u00eddo na linha 20, ele possui a seguinte implementa\u00e7\u00e3o: bootcmd_panic = fastboot 0 ; reset Como \u00faltimo recurso, caso n\u00e3o tenha sido poss\u00edvel fazer o boot do Android. O script entra no modo fastboot e ao sair ele reinicia a VIM3. Conclus\u00e3o Sem d\u00favida entender esse processo n\u00e3o \u00e9 algo trivial, n\u00e3o existe uma padroniza\u00e7\u00e3o e tudo fica na m\u00e3o do desenvolvedor na hora de criar o script respons\u00e1vel por carregar o kernel do Android. Com certeza, esse passo foi fundamental para um melhor entendimento de como o Android funciona.","title":"Decifrando o BOOTCMD"},{"location":"Bootloader/VIM3/Android/Carregando/#decifrando-o-bootcmd","text":"Image by Gerd Altmann from Pixabay","title":"Decifrando o BOOTCMD"},{"location":"Bootloader/VIM3/Android/Carregando/#introducao","text":"Na minha saga para desvendar o mundo dos sistemas embarcados, nesse post eu pretendo entender explicar como o u-boot mainline carrega o kernel Android na VIM3 .","title":"Introdu\u00e7\u00e3o"},{"location":"Bootloader/VIM3/Android/Carregando/#o-bootcmd","text":"Depois que que o u-boot \u00e9 carregado, ele executa comandos para encontrar o kernel. Para isso, \u00e9 gerado um script para checar as poss\u00edveis formas de carrega-lo. O primeiro passo foi dar o comando printenv no console do u-boot, resultando nas seguintes informa\u00e7\u00f5es: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 arch = arm avb_verify = avb init ${ mmcdev } ; avb verify $slot_suffix ; baudrate = 115200 board = vim3 board_name = vim3 boot_a_script = load ${ devtype } ${ devnum } : ${ distro_bootpart } ${ scriptaddr } ${ prefix }${ script } ; source ${ scriptaddr } boot_efi_binary = load ${ devtype } ${ devnum } : ${ distro_bootpart } ${ kernel_addr_r } efi/boot/bootaa64.efi ; if fdt addr -q ${ fdt_addr_r } ; then bootefi ${ kernel_addr_r } ${ fdt_addr_r } ; else bootefi ${ kernel_addr_r } ${ fdtcontroladdr } ; fi boot_efi_bootmgr = if fdt addr -q ${ fdt_addr_r } ; then bootefi bootmgr ${ fdt_addr_r } ; else bootefi bootmgr ; fi boot_extlinux = sysboot ${ devtype } ${ devnum } : ${ distro_bootpart } any ${ scriptaddr } ${ prefix }${ boot_syslinux_conf } boot_net_usb_start = usb start boot_pci_enum = pci enum boot_prefixes = / /boot/ boot_script_dhcp = boot.scr.uimg boot_scripts = boot.scr.uimg boot.scr boot_source = sd boot_syslinux_conf = extlinux/extlinux.conf boot_targets = fastboot recovery system panic bootcmd = run distro_bootcmd bootcmd_fastboot = setenv run_fastboot 0 ; if test \" ${ boot_source } \" = \"usb\" ; then echo Fastboot forced by usb rom boot ; setenv run_fastboot 1 ; fi ; if test \" ${ run_fastboot } \" -eq 0 ; then if gpt verify mmc ${ mmcdev } ${ partitions } ; then ; else echo Broken MMC partition scheme ; setenv run_fastboot 1 ; fi ; fi ; if test \" ${ run_fastboot } \" -eq 0 ; then if bcb load 2 misc ; then if bcb test command = bootonce-bootloader ; then echo BCB: Bootloader boot... ; bcb clear command ; bcb store ; setenv run_fastboot 1 ; elif bcb test command = boot-fastboot ; then echo BCB: fastboot userspace boot... ; setenv force_recovery 1 ; fi ; else echo Warning: BCB is corrupted or does not exist ; fi ; fi ; if test \" ${ run_fastboot } \" -eq 1 ; then echo Running Fastboot... ; fastboot 0 ; fi bootcmd_panic = fastboot 0 ; reset bootcmd_recovery = pinmux dev pinctrl@14 ; pinmux dev pinctrl@40 ; setenv run_recovery 0 ; if run check_button ; then echo Recovery button is pressed ; setenv run_recovery 1 ; fi ; if bcb load 2 misc ; then if bcb test command = boot-recovery ; then echo BCB: Recovery boot... ; setenv run_recovery 1 ; fi ; else echo Warning: BCB is corrupted or does not exist ; fi ; if test \" ${ skip_recovery } \" -eq 1 ; then echo Recovery skipped by environment ; setenv run_recovery 0 ; fi ; if test \" ${ force_recovery } \" -eq 1 ; then echo Recovery forced by environment ; setenv run_recovery 1 ; fi ; if test \" ${ run_recovery } \" -eq 1 ; then echo Running Recovery... ; mmc dev ${ mmcdev } ; setenv bootargs \" ${ bootargs } androidboot.serialno= ${ serial # } \" ; if test \" ${ force_avb } \" -eq 1 ; then if run avb_verify ; then echo AVB verification OK. ; setenv bootargs \" $bootargs $avb_bootargs \" ; else echo AVB verification failed. ; exit ; fi ; else setenv bootargs \" $bootargs androidboot.verifiedbootstate=orange\" ; echo Running without AVB... ; fi ; part start mmc ${ mmcdev } recovery ${ slot_suffix } boot_start ; part size mmc ${ mmcdev } recovery ${ slot_suffix } boot_size ; if mmc read ${ loadaddr } ${ boot_start } ${ boot_size } ; then echo Preparing FDT... ; if test $board_name = sei510 ; then echo \" Reading DTB for sei510...\" ; setenv dtb_index 0 ; elif test $board_name = sei610 ; then echo \" Reading DTB for sei610...\" ; setenv dtb_index 1 ; elif test $board_name = vim3l ; then echo \" Reading DTB for vim3l...\" ; setenv dtb_index 2 ; elif test $board_name = vim3 ; then echo \" Reading DTB for vim3...\" ; setenv dtb_index 3 ; else echo Error: Android boot is not supported for $board_name ; exit ; fi ; abootimg get dtb --index = $dtb_index dtb_start dtb_size ; cp.b $dtb_start $fdt_addr_r $dtb_size ; fdt addr $fdt_addr_r 0x80000 ; if test $board_name = sei510 ; then echo \" Reading DTBO for sei510...\" ; setenv dtbo_index 0 ; elif test $board_name = sei610 ; then echo \" Reading DTBO for sei610...\" ; setenv dtbo_index 1 ; elif test $board_name = vim3l ; then echo \" Reading DTBO for vim3l...\" ; setenv dtbo_index 2 ; elif test $board_name = vim3 ; then echo \" Reading DTBO for vim3...\" ; setenv dtbo_index 3 ; else echo Error: Android boot is not supported for $board_name ; exit ; fi ; part start mmc ${ mmcdev } dtbo ${ slot_suffix } p_dtbo_start ; part size mmc ${ mmcdev } dtbo ${ slot_suffix } p_dtbo_size ; mmc read ${ dtboaddr } ${ p_dtbo_start } ${ p_dtbo_size } ; echo \" Applying DTBOs...\" ; adtimg addr $dtboaddr ; adtimg get dt --index = $dtbo_index dtbo0_addr ; fdt apply $dtbo0_addr ; setenv bootargs \" $bootargs androidboot.dtbo_idx= $dtbo_index \" ; echo Running Android Recovery... ; bootm ${ loadaddr } ${ loadaddr } ${ fdt_addr_r } ; fi ; echo Failed to boot Android... ; reset ; fi bootcmd_system = echo Loading Android boot partition... ; mmc dev ${ mmcdev } ; setenv bootargs ${ bootargs } androidboot.serialno = ${ serial # } ; if test \" ${ force_avb } \" -eq 1 ; then if run avb_verify ; then echo AVB verification OK. ; setenv bootargs \" $bootargs $avb_bootargs \" ; else echo AVB verification failed. ; exit ; fi ; else setenv bootargs \" $bootargs androidboot.verifiedbootstate=orange\" ; echo Running without AVB... ; fi ; part start mmc ${ mmcdev } boot ${ slot_suffix } boot_start ; part size mmc ${ mmcdev } boot ${ slot_suffix } boot_size ; if mmc read ${ loadaddr } ${ boot_start } ${ boot_size } ; then echo Preparing FDT... ; if test $board_name = sei510 ; then echo \" Reading DTB for sei510...\" ; setenv dtb_index 0 ; elif test $board_name = sei610 ; then echo \" Reading DTB for sei610...\" ; setenv dtb_index 1 ; elif test $board_name = vim3l ; then echo \" Reading DTB for vim3l...\" ; setenv dtb_index 2 ; elif test $board_name = vim3 ; then echo \" Reading DTB for vim3...\" ; setenv dtb_index 3 ; else echo Error: Android boot is not supported for $board_name ; exit ; fi ; abootimg get dtb --index = $dtb_index dtb_start dtb_size ; cp.b $dtb_start $fdt_addr_r $dtb_size ; fdt addr $fdt_addr_r 0x80000 ; if test $board_name = sei510 ; then echo \" Reading DTBO for sei510...\" ; setenv dtbo_index 0 ; elif test $board_name = sei610 ; then echo \" Reading DTBO for sei610...\" ; setenv dtbo_index 1 ; elif test $board_name = vim3l ; then echo \" Reading DTBO for vim3l...\" ; setenv dtbo_index 2 ; elif test $board_name = vim3 ; then echo \" Reading DTBO for vim3...\" ; setenv dtbo_index 3 ; else echo Error: Android boot is not supported for $board_name ; exit ; fi ; part start mmc ${ mmcdev } dtbo ${ slot_suffix } p_dtbo_start ; part size mmc ${ mmcdev } dtbo ${ slot_suffix } p_dtbo_size ; mmc read ${ dtboaddr } ${ p_dtbo_start } ${ p_dtbo_size } ; echo \" Applying DTBOs...\" ; adtimg addr $dtboaddr ; adtimg get dt --index = $dtbo_index dtbo0_addr ; fdt apply $dtbo0_addr ; setenv bootargs \" $bootargs androidboot.dtbo_idx= $dtbo_index \" ; setenv bootargs \" ${ bootargs } \" ; echo Running Android... ; bootm ${ loadaddr } ${ loadaddr } ${ fdt_addr_r } ; fi ; echo Failed to boot Android... ; bootdelay = 2 check_button = gpio input ${ gpio_recovery } ; test $? -eq 0 ; cpu = armv8 distro_bootcmd = setenv nvme_need_init ; for target in ${ boot_targets } ; do run bootcmd_ ${ target } ; done dtboaddr = 0x08200000 efi_dtb_prefixes = / /dtb/ /dtb/current/ ethaddr = c8:63:14:71:2d:35 fastboot_raw_partition_bootenv = 0x0 0xfff mmcpart 2 fastboot_raw_partition_bootloader = 0x1 0xfff mmcpart 1 fdt_addr_r = 0x01000000 fdtcontroladdr = f0efa100 fdtfile = amlogic/meson-g12b-a311d-khadas-vim3.dtb force_avb = 0 gpio_recovery = 88 kernel_addr_r = 0x01080000 load_efi_dtb = load ${ devtype } ${ devnum } : ${ distro_bootpart } ${ fdt_addr_r } ${ prefix }${ efi_fdtfile } load_logo = if test \" ${ boot_source } \" ! = \"usb\" && gpt verify mmc ${ mmcdev } ${ partitions } ; then ; mmc dev ${ mmcdev } ; part start mmc ${ mmcdev } logo boot_start ; part size mmc ${ mmcdev } logo boot_size ; if mmc read ${ loadaddr } ${ boot_start } ${ boot_size } ; then bmp display ${ loadaddr } m m ; fi ; fi ; loadaddr = 0x01080000 mmc_boot = if mmc dev ${ devnum } ; then devtype = mmc ; run scan_dev_for_boot_part ; fi mmcdev = 2 nvme_boot = run boot_pci_enum ; run nvme_init ; if nvme dev ${ devnum } ; then devtype = nvme ; run scan_dev_for_boot_part ; fi nvme_init = if ${ nvme_need_init } ; then setenv nvme_need_init false ; nvme scan ; fi partitions = uuid_disk = ${ uuid_gpt_disk } ; name = logo,start = 512K,size = 2M,uuid = 43a3305d-150f-4cc9-bd3b-38fca8693846 ; name = misc,size = 512K,uuid = ${ uuid_gpt_misc } ; name = dtbo,size = 8M,uuid = ${ uuid_gpt_dtbo } ; name = vbmeta,size = 512K,uuid = ${ uuid_gpt_vbmeta } ; name = boot,size = 32M,bootable,uuid = ${ uuid_gpt_boot } ; name = recovery,size = 32M,uuid = ${ uuid_gpt_recovery } ; name = cache,size = 256M,uuid = ${ uuid_gpt_cache } ; name = super,size = 1792M,uuid = ${ uuid_gpt_super } ; name = userdata,size = 12786M,uuid = ${ uuid_gpt_userdata } ; name = rootfs,size = -,uuid = ddb8c3f6-d94d-4394-b633-3134139cc2e0 ; pxefile_addr_r = 0x01080000 ramdisk_addr_r = 0x13000000 scan_dev_for_boot = echo Scanning ${ devtype } ${ devnum } : ${ distro_bootpart } ... ; for prefix in ${ boot_prefixes } ; do run scan_dev_for_extlinux ; run scan_dev_for_scripts ; done ; run scan_dev_for_efi ; scan_dev_for_boot_part = part list ${ devtype } ${ devnum } -bootable devplist ; env exists devplist || setenv devplist 1 ; for distro_bootpart in ${ devplist } ; do if fstype ${ devtype } ${ devnum } : ${ distro_bootpart } bootfstype ; then run scan_dev_for_boot ; fi ; done ; setenv devplist scan_dev_for_efi = setenv efi_fdtfile ${ fdtfile } ; for prefix in ${ efi_dtb_prefixes } ; do if test -e ${ devtype } ${ devnum } : ${ distro_bootpart } ${ prefix }${ efi_fdtfile } ; then run load_efi_dtb ; fi ; done ; run boot_efi_bootmgr ; if test -e ${ devtype } ${ devnum } : ${ distro_bootpart } efi/boot/bootaa64.efi ; then echo Found EFI removable media binary efi/boot/bootaa64.efi ; run boot_efi_binary ; echo EFI LOAD FAILED: continuing... ; fi ; setenv efi_fdtfile scan_dev_for_extlinux = if test -e ${ devtype } ${ devnum } : ${ distro_bootpart } ${ prefix }${ boot_syslinux_conf } ; then echo Found ${ prefix }${ boot_syslinux_conf } ; run boot_extlinux ; echo SCRIPT FAILED: continuing... ; fi scan_dev_for_scripts = for script in ${ boot_scripts } ; do if test -e ${ devtype } ${ devnum } : ${ distro_bootpart } ${ prefix }${ script } ; then echo Found U-Boot script ${ prefix }${ script } ; run boot_a_script ; echo SCRIPT FAILED: continuing... ; fi ; done scriptaddr = 0x08000000 serial# = C86314712D35 soc = meson stderr = vidconsole,serial stdin = usbkbd,serial stdout = vidconsole,serial usb_boot = usb start ; if usb dev ${ devnum } ; then devtype = usb ; run scan_dev_for_boot_part ; fi vendor = amlogic Environment size: 9785 /65532 bytes = > Estudaremos inicialmente essa sa\u00edda, come\u00e7ando pelo bootcmd (linha 18). Ele \u00e9 o ponta p\u00e9 inicial para o script. Podemos observar que ele executa outra fun\u00e7\u00e3o: bootcmd = run distro_bootcmd Ele executa a distro_bootcmd (linha 26).","title":"O bootcmd"},{"location":"Bootloader/VIM3/Android/Carregando/#o-distro_bootcmd","text":"Essa fun\u00e7\u00e3o \u00e9 um pouco mais elaborada, quebrei em v\u00e1rias linhas. Vamos analiz\u00e1-las distro_bootcmd = setenv nvme_need_init ; for target in ${ boot_targets } ; do run bootcmd_ ${ target } ; done A flag nvme_need_init n\u00e3o est\u00e1 setada, mas podemos encontrar alguns detalhes no arquivo: include/config_distro_bootcmd.h No diret\u00f3rio do c\u00f3digo fonte do u-boot, n\u00e3o vou focar nessa linha pois n\u00e3o \u00e9 de interesse utilizar o NVME (ainda ). Seguindo no c\u00f3digo, podemos obsevar que a vari\u00e1vel boot_targets (atribu\u00edda na linha 17) \u00e9 iterada com os seguintes valores: boot_targets=fastboot recovery system panic Cada valor \u00e9 concatenado com a string bootcmd_ , resultando em: bootcmd_fastboot bootcmd_recovery bootcmd_system bootcmd_panic","title":"O distro_bootcmd"},{"location":"Bootloader/VIM3/Android/Carregando/#as-ramificacoes-do-bootcmd_","text":"O distro_bootcmd acaba executando outras 4 fun\u00e7\u00f5es, vamos entender o que elas fazem.","title":"As ramifica\u00e7\u00f5es do bootcmd_"},{"location":"Bootloader/VIM3/Android/Carregando/#o-bootcmd_fastboot","text":"Atribu\u00edda na linha 19, ela possui a seguinte implementa\u00e7\u00e3o: bootcmd_fastboot = setenv run_fastboot 0 ; if test \" ${ boot_source } \" = \"usb\" ; then echo Fastboot forced by usb rom boot ; setenv run_fastboot 1 ; fi ; if test \" ${ run_fastboot } \" -eq 0 ; then if gpt verify mmc ${ mmcdev } ${ partitions } ; then ; else echo Broken MMC partition scheme ; setenv run_fastboot 1 ; fi ; fi ; if test \" ${ run_fastboot } \" -eq 0 ; then if bcb load 2 misc ; then if bcb test command = bootonce-bootloader ; then echo BCB: Bootloader boot... ; bcb clear command ; bcb store ; setenv run_fastboot 1 ; elif bcb test command = boot-fastboot ; then echo BCB: fastboot userspace boot... ; setenv force_recovery 1 ; fi ; else echo Warning: BCB is corrupted or does not exist ; fi ; fi ; if test \" ${ run_fastboot } \" -eq 1 ; then echo Running Fastboot... ; fastboot 0 ; fi A flag run_fastboot \u00e9 setada para 0. A vari\u00e1vel boot_source \u00e9 atribu\u00edda na linha 15: boot_source=sd Com isso, o primeiro if n\u00e3o \u00e9 acionado. No proximo if j\u00e1 sabemos que run_fastboot==0 , ao entrar no if \u00e9 checado a vari\u00e1vel mmcdev que \u00e9 atribu\u00edda na linha 42 e a vari\u00e1vel partitions , atribu\u00edda na linha 45: mmcdev = 2 partitions = uuid_disk = ${ uuid_gpt_disk } ; name = logo,start = 512K,size = 2M,uuid = 43a3305d-150f-4cc9-bd3b-38fca8693846 ; name = misc,size = 512K,uuid = ${ uuid_gpt_misc } ; name = dtbo,size = 8M,uuid = ${ uuid_gpt_dtbo } ; name = vbmeta,size = 512K,uuid = ${ uuid_gpt_vbmeta } ; name = boot,size = 32M,bootable,uuid = ${ uuid_gpt_boot } ; name = recovery,size = 32M,uuid = ${ uuid_gpt_recovery } ; name = cache,size = 256M,uuid = ${ uuid_gpt_cache } ; name = super,size = 1792M,uuid = ${ uuid_gpt_super } ; name = userdata,size = 12786M,uuid = ${ uuid_gpt_userdata } ; name = rootfs,size = -,uuid = ddb8c3f6-d94d-4394-b633-3134139cc2e0 ; Logo, na linha if gpt verify mmc ${mmcdev} ${partitions}; then; \u00e9 checado se as parti\u00e7\u00f5es existem, nesse caso no eMMC da placa ( mmcdev=2 ), caso contr\u00e1rio imprime a mensagem de erro Broken MMC partition scheme; e seta a flag run_fastboot para 1. Mais adiante, \u00e9 checado novamente a flag run_fastboot . Caso as parti\u00e7\u00f5es no eMMC estejam corretas, \u00e9 checado if bcb load 2 misc; then . Essa linha tenta carregar a parti\u00e7\u00e3o misc do eMMC (mais informa\u00e7\u00f5es nesse link ). Se tudo der certo, em seguida \u00e9 checado o conte\u00fado da v\u00e1ri\u00e1vel command que foi guardada dentro da parti\u00e7\u00e3o misc : if bcb test command = bootonce-bootloader; then elif bcb test command = boot-fastboot; then Caso algum problema ocorra ao carregar a parti\u00e7\u00e3o misc , a seguinte mensagem \u00e9 impressa na tela Warning: BCB is corrupted or does not exist; . O \u00faltimo if checa se a flag run_fastboot \u00e9 1, caso positivo \u00e9 impresso na tela a mensagem Running Fastboot... e entra no modo Fastboot com o comando fastboot 0 .","title":"O bootcmd_fastboot"},{"location":"Bootloader/VIM3/Android/Carregando/#o-bootcmd_recovery","text":"Atribu\u00eddo na linha 21 e possui a seguinte implementa\u00e7\u00e3o: bootcmd_recovery = pinmux dev pinctrl@14 ; pinmux dev pinctrl@40 ; setenv run_recovery 0 ; if run check_button ; then echo Recovery button is pressed ; setenv run_recovery 1 ; fi ; if bcb load 2 misc ; then if bcb test command = boot-recovery ; then echo BCB: Recovery boot... ; setenv run_recovery 1 ; fi ; else echo Warning: BCB is corrupted or does not exist ; fi ; if test \" ${ skip_recovery } \" -eq 1 ; then echo Recovery skipped by environment ; setenv run_recovery 0 ; fi ; if test \" ${ force_recovery } \" -eq 1 ; then echo Recovery forced by environment ; setenv run_recovery 1 ; fi ; if test \" ${ run_recovery } \" -eq 1 ; then echo Running Recovery... ; mmc dev ${ mmcdev } ; setenv bootargs \" ${ bootargs } androidboot.serialno= ${ serial # } \" ; if test \" ${ force_avb } \" -eq 1 ; then if run avb_verify ; then echo AVB verification OK. ; setenv bootargs \" $bootargs $avb_bootargs \" ; else echo AVB verification failed. ; exit ; fi ; else setenv bootargs \" $bootargs androidboot.verifiedbootstate=orange\" ; echo Running without AVB... ; fi ; part start mmc ${ mmcdev } recovery ${ slot_suffix } boot_start ; part size mmc ${ mmcdev } recovery ${ slot_suffix } boot_size ; if mmc read ${ loadaddr } ${ boot_start } ${ boot_size } ; then echo Preparing FDT... ; if test $board_name = sei510 ; then echo \" Reading DTB for sei510...\" ; setenv dtb_index 0 ; elif test $board_name = sei610 ; then echo \" Reading DTB for sei610...\" ; setenv dtb_index 1 ; elif test $board_name = vim3l ; then echo \" Reading DTB for vim3l...\" ; setenv dtb_index 2 ; elif test $board_name = vim3 ; then echo \" Reading DTB for vim3...\" ; setenv dtb_index 3 ; else echo Error: Android boot is not supported for $board_name ; exit ; fi ; abootimg get dtb --index = $dtb_index dtb_start dtb_size ; cp.b $dtb_start $fdt_addr_r $dtb_size ; fdt addr $fdt_addr_r 0x80000 ; if test $board_name = sei510 ; then echo \" Reading DTBO for sei510...\" ; setenv dtbo_index 0 ; elif test $board_name = sei610 ; then echo \" Reading DTBO for sei610...\" ; setenv dtbo_index 1 ; elif test $board_name = vim3l ; then echo \" Reading DTBO for vim3l...\" ; setenv dtbo_index 2 ; elif test $board_name = vim3 ; then echo \" Reading DTBO for vim3...\" ; setenv dtbo_index 3 ; else echo Error: Android boot is not supported for $board_name ; exit ; fi ; part start mmc ${ mmcdev } dtbo ${ slot_suffix } p_dtbo_start ; part size mmc ${ mmcdev } dtbo ${ slot_suffix } p_dtbo_size ; mmc read ${ dtboaddr } ${ p_dtbo_start } ${ p_dtbo_size } ; echo \" Applying DTBOs...\" ; adtimg addr $dtboaddr ; adtimg get dt --index = $dtbo_index dtbo0_addr ; fdt apply $dtbo0_addr ; setenv bootargs \" $bootargs androidboot.dtbo_idx= $dtbo_index \" ; echo Running Android Recovery... ; bootm ${ loadaddr } ${ loadaddr } ${ fdt_addr_r } ; fi ; echo Failed to boot Android... ; reset ; fi As duas primeiras linhas: pinmux dev pinctrl@14; pinmux dev pinctrl@40; A pr\u00edncipio n\u00e3o funcionam, tentei ver o status desses pinos e retornaram pinctrl@14 not found e pinctrl@40 not found . Talvez esteja faltando alguma implementa\u00e7\u00e3o. Seguindo no c\u00f3digo, a flag run_recovery \u00e9 setada para 0 e ent\u00e3o a fun\u00e7\u00e3o check_button \u00e9 checada. Ela foi atribu\u00edda na linha 24: check_button = gpio input ${ gpio_recovery } ; test $? -eq 0 ; Na linha 36 a vari\u00e1vel gpio_recovery=88 \u00e9 atribu\u00edda. Por padr\u00e3o, esse GPIO \u00e9 setado para 1 gpio: pin 88 (gpio 88) value is 1 , logo o valor retornado \u00e9 falso. Dessa forma, a compara\u00e7\u00e3o if run check_button; then n\u00e3o \u00e9 acionada. Mais adiante, a parti\u00e7\u00e3o misc \u00e9 carregada novamente e \u00e9 checado se a vari\u00e1vel command est\u00e1 setada para boot-recovery . Em seguinda, a v\u00e1ri\u00e1vel skip_recovery n\u00e3o est\u00e1 setada, logo n\u00e3o entra no pr\u00f3ximo if . Se a vari\u00e1vel force_recovery foi setada na etapa do bootcmd_fastboot , ent\u00e3o a linha if test \"${force_recovery}\" -eq 1; then \u00e9 acionada \u00e9 a vari\u00e1vel a flag run_recovery \u00e9 setada para 1. Isso faz com que o pr\u00f3ximo if seja acionado ( if test \"${run_recovery}\" -eq 1; then ) e come\u00e7ar o processo de entrar no modo Recovery . Vimos na se\u00e7\u00e3o anterior que mmcdev=2 . Com isso, o comando mmc dev ${mmcdev}; ativa o eMMC. A pr\u00f3xima linha adiciona a vari\u00e1vel bootargs a propriedade androidboot.serialno=${serial#} . A vari\u00e1vel serial# \u00e9 atribu\u00edda na linha 54: serial# = C86314712D35 Seguindo, \u00e9 checado a v\u00e1ri\u00e1vel force_avb=0 , atribu\u00edda na linha 35. Como o Android Verified Boot (AVB) n\u00e3o est\u00e1 setado, \u00e9 adicionado mais uma propriedade ao bootargs : setenv bootargs \" $bootargs androidboot.verifiedbootstate=orange\" ; Mais a frente, temos a linha: part start mmc ${ mmcdev } recovery ${ slot_suffix } boot_start ; a vari\u00e1vel slot_suffix n\u00e3o est\u00e1 setada. Dessa forma, essa linha procura o inicio da parti\u00e7\u00e3o recovery dentro do eMMC e adiciona o valor na vari\u00e1vel boot_start . A linha: part size mmc ${ mmcdev } recovery ${ slot_suffix } boot_size ; \u00e9 semelhante, mas nesse caso armazena o tamanho da parti\u00e7\u00e3o recovery na vari\u00e1vel boot_size . Na linha seguinte: if mmc read ${ loadaddr } ${ boot_start } ${ boot_size } ; then a vari\u00e1vel loadaddr=0x01080000 \u00e9 atribu\u00edda na linha 40. A parti\u00e7\u00e3o recovery \u00e9 carregada e se tudo ocorrer corretamente, segue dentro do if . A vari\u00e1vel board_name=vim3 \u00e9 atribu\u00edda na linha 5, consequentemente, setando a flag setenv dtb_index 3; . A pr\u00f3xima linha: abootimg get dtb --index = $dtb_index dtb_start dtb_size ; Armazena o endere\u00e7o e o tamanho do Device Tree Blob (DTB) nas vari\u00e1veis dtb_start e dtb_size , respectivamente. Seguindo, temos: cp.b $dtb_start $fdt_addr_r $dtb_size ; a vari\u00e1vel fdt_addr_r=0x01000000 \u00e9 atribu\u00edda na linha 32. A linha acima copia o conte\u00fado do DTB para o endere\u00e7o da vari\u00e1vel fdt_addr_r . Ap\u00f3s isso, a localiza\u00e7\u00e3o do ftd \u00e9 setada para o endere\u00e7o 0x80000 , pelo comando: fdt addr $fdt_addr_r 0x80000 ; Agora \u00e9 necess\u00e1rio carregar o Device Tree Blob Overlay (DTBO). Para isso, \u00e9 checando novamente a var\u00edavel board_name , consequentemente, a flag setenv dtb_index 3 \u00e9 setada. As seguintes linhas tem fun\u00e7\u00e3o similar as anteriores: part start mmc ${ mmcdev } dtbo ${ slot_suffix } p_dtbo_start ; part size mmc ${ mmcdev } dtbo ${ slot_suffix } p_dtbo_size ; mmc read ${ dtboaddr } ${ p_dtbo_start } ${ p_dtbo_size } ; a vari\u00e1vel dtboaddr=0x08200000 \u00e9 atribu\u00edda na linha 27. As linhas: adtimg addr $dtboaddr ; adtimg get dt --index = $dtbo_index dtbo0_addr ; fdt apply $dtbo0_addr ; Seta a localiza\u00e7\u00e3o da imagem do DTBO para o endere\u00e7o da vari\u00e1vel dtboaddr , armazena o endere\u00e7o do DTBO na vari\u00e1vel dtbo0_addr . Por fim, aplica o DTBO no DTB. Na linha seguinte, \u00e9 adicionado a propriedade setenv bootargs \"$bootargs androidboot.dtbo_idx=$dtbo_index \" na vari\u00e1vel bootargs . Finalmente, na linha: bootm ${ loadaddr } ${ loadaddr } ${ fdt_addr_r } ; faz o boot da imagem de recovery .","title":"O bootcmd_recovery"},{"location":"Bootloader/VIM3/Android/Carregando/#o-bootcmd_system","text":"Atribu\u00eddo na linha 22, ele possui a seguinte implementa\u00e7\u00e3o: bootcmd_system = echo Loading Android boot partition... ; mmc dev ${ mmcdev } ; setenv bootargs ${ bootargs } androidboot.serialno = ${ serial # } ; if test \" ${ force_avb } \" -eq 1 ; then if run avb_verify ; then echo AVB verification OK. ; setenv bootargs \" $bootargs $avb_bootargs \" ; else echo AVB verification failed. ; exit ; fi ; else setenv bootargs \" $bootargs androidboot.verifiedbootstate=orange\" ; echo Running without AVB... ; fi ; part start mmc ${ mmcdev } boot ${ slot_suffix } boot_start ; part size mmc ${ mmcdev } boot ${ slot_suffix } boot_size ; if mmc read ${ loadaddr } ${ boot_start } ${ boot_size } ; then echo Preparing FDT... ; if test $board_name = sei510 ; then echo \" Reading DTB for sei510...\" ; setenv dtb_index 0 ; elif test $board_name = sei610 ; then echo \" Reading DTB for sei610...\" ; setenv dtb_index 1 ; elif test $board_name = vim3l ; then echo \" Reading DTB for vim3l...\" ; setenv dtb_index 2 ; elif test $board_name = vim3 ; then echo \" Reading DTB for vim3...\" ; setenv dtb_index 3 ; else echo Error: Android boot is not supported for $board_name ; exit ; fi ; abootimg get dtb --index = $dtb_index dtb_start dtb_size ; cp.b $dtb_start $fdt_addr_r $dtb_size ; fdt addr $fdt_addr_r 0x80000 ; if test $board_name = sei510 ; then echo \" Reading DTBO for sei510...\" ; setenv dtbo_index 0 ; elif test $board_name = sei610 ; then echo \" Reading DTBO for sei610...\" ; setenv dtbo_index 1 ; elif test $board_name = vim3l ; then echo \" Reading DTBO for vim3l...\" ; setenv dtbo_index 2 ; elif test $board_name = vim3 ; then echo \" Reading DTBO for vim3...\" ; setenv dtbo_index 3 ; else echo Error: Android boot is not supported for $board_name ; exit ; fi ; part start mmc ${ mmcdev } dtbo ${ slot_suffix } p_dtbo_start ; part size mmc ${ mmcdev } dtbo ${ slot_suffix } p_dtbo_size ; mmc read ${ dtboaddr } ${ p_dtbo_start } ${ p_dtbo_size } ; echo \" Applying DTBOs...\" ; adtimg addr $dtboaddr ; adtimg get dt --index = $dtbo_index dtbo0_addr ; fdt apply $dtbo0_addr ; setenv bootargs \" $bootargs androidboot.dtbo_idx= $dtbo_index \" ; setenv bootargs \" ${ bootargs } \" ; echo Running Android... ; bootm ${ loadaddr } ${ loadaddr } ${ fdt_addr_r } ; fi ; echo Failed to boot Android... ; Todo o processo \u00e9 o mesmo do modo recovery a diferen\u00e7a fica nas seguintes linhas: part start mmc ${ mmcdev } boot ${ slot_suffix } boot_start ; part size mmc ${ mmcdev } boot ${ slot_suffix } boot_size ; Observe que agora o script busca pela parti\u00e7\u00e3o boot . O resto segue inalterado.","title":"O bootcmd_system"},{"location":"Bootloader/VIM3/Android/Carregando/#o-bootcmd_panic","text":"Atribu\u00eddo na linha 20, ele possui a seguinte implementa\u00e7\u00e3o: bootcmd_panic = fastboot 0 ; reset Como \u00faltimo recurso, caso n\u00e3o tenha sido poss\u00edvel fazer o boot do Android. O script entra no modo fastboot e ao sair ele reinicia a VIM3.","title":"O bootcmd_panic"},{"location":"Bootloader/VIM3/Android/Carregando/#conclusao","text":"Sem d\u00favida entender esse processo n\u00e3o \u00e9 algo trivial, n\u00e3o existe uma padroniza\u00e7\u00e3o e tudo fica na m\u00e3o do desenvolvedor na hora de criar o script respons\u00e1vel por carregar o kernel do Android. Com certeza, esse passo foi fundamental para um melhor entendimento de como o Android funciona.","title":"Conclus\u00e3o"},{"location":"Bootloader/qemu/U-boot_qemu/","text":"U-boot no QEMU Image by PublicDomainPictures from Pixabay Introdu\u00e7\u00e3o A fim de ter um ambiente de testes para aprender sobre o U-Boot, o mais recomendado \u00e9 criar um ambiente virtual. Para isso, eu escolhi o QEMU, que \u00e9 altamente configur\u00e1vel. Essa postagem tem como base a arquitetura aarch64 , devido sua larga utiliza\u00e7\u00e3o em sistemas embarcados. Baixando o U-Boot mainline Basta copiar e colar o c\u00f3digo abaixo: git clone https://source.denx.de/u-boot/u-boot.git Buildando o U-boot A seguir s\u00e3o definidos alguns passos para gerar o bin\u00e1rio do U-boot, que ser\u00e1 utilizado pelo QEMU. Instalando Depend\u00eancias Dependendo do sistema utilizado, alguns pacotes ser\u00e3o necess\u00e1rios para que o processo de build tenha sucesso. No meu ambiente ( ubuntu 22.04 ), foram necess\u00e1rio os seguintes pacotes: sudo apt install \\ flex \\ bison \\ gcc-aarch64-linux-gnu \\ Definindo a Arquitetura Para criar um sistema de build limpo, o par\u00e2metro O= foi utilizado. Dentro da pasta do U-Boot, cole o c\u00f3digo abaixo: make O=../out qemu_arm64_defconfig -j16 Se tudo ocorrer bem, a mensagem a seguir deve aparecer: Uma pasta out foi criada, adicionando todos os itens necess\u00e1rios para a build. Gerando o Bin\u00e1rio Dentro da pasta out , cole o c\u00f3digo abaixo: make CROSS_COMPILE=aarch64-linux-gnu- -j16 Se tudo ocorrer corretamente o arquivo u-boot.bin ser\u00e1 criado. Carregando o U-boot com QEMU Para utilizar o QEMU para arquiteturas ARM64 \u00e9 necess\u00e1rio instalar o pacote: sudo apt install qemu-system-arm Dentro da pasta out , execute o seguinte comando: qemu-system-aarch64 -M virt -nographic -cpu cortex-a57 -bios u-boot.bin onde o par\u00e2metro -bios \u00e9 o binario que acabou de ser criado pela nossa build. Ap\u00f3s executar o comando, o u-boot dever\u00e1 iniciar normalmente:","title":"U-boot no QEMU"},{"location":"Bootloader/qemu/U-boot_qemu/#u-boot-no-qemu","text":"Image by PublicDomainPictures from Pixabay","title":"U-boot no QEMU"},{"location":"Bootloader/qemu/U-boot_qemu/#introducao","text":"A fim de ter um ambiente de testes para aprender sobre o U-Boot, o mais recomendado \u00e9 criar um ambiente virtual. Para isso, eu escolhi o QEMU, que \u00e9 altamente configur\u00e1vel. Essa postagem tem como base a arquitetura aarch64 , devido sua larga utiliza\u00e7\u00e3o em sistemas embarcados.","title":"Introdu\u00e7\u00e3o"},{"location":"Bootloader/qemu/U-boot_qemu/#baixando-o-u-boot-mainline","text":"Basta copiar e colar o c\u00f3digo abaixo: git clone https://source.denx.de/u-boot/u-boot.git","title":"Baixando o U-Boot mainline"},{"location":"Bootloader/qemu/U-boot_qemu/#buildando-o-u-boot","text":"A seguir s\u00e3o definidos alguns passos para gerar o bin\u00e1rio do U-boot, que ser\u00e1 utilizado pelo QEMU.","title":"Buildando o U-boot"},{"location":"Bootloader/qemu/U-boot_qemu/#instalando-dependencias","text":"Dependendo do sistema utilizado, alguns pacotes ser\u00e3o necess\u00e1rios para que o processo de build tenha sucesso. No meu ambiente ( ubuntu 22.04 ), foram necess\u00e1rio os seguintes pacotes: sudo apt install \\ flex \\ bison \\ gcc-aarch64-linux-gnu \\","title":"Instalando Depend\u00eancias"},{"location":"Bootloader/qemu/U-boot_qemu/#definindo-a-arquitetura","text":"Para criar um sistema de build limpo, o par\u00e2metro O= foi utilizado. Dentro da pasta do U-Boot, cole o c\u00f3digo abaixo: make O=../out qemu_arm64_defconfig -j16 Se tudo ocorrer bem, a mensagem a seguir deve aparecer: Uma pasta out foi criada, adicionando todos os itens necess\u00e1rios para a build.","title":"Definindo a Arquitetura"},{"location":"Bootloader/qemu/U-boot_qemu/#gerando-o-binario","text":"Dentro da pasta out , cole o c\u00f3digo abaixo: make CROSS_COMPILE=aarch64-linux-gnu- -j16 Se tudo ocorrer corretamente o arquivo u-boot.bin ser\u00e1 criado.","title":"Gerando o Bin\u00e1rio"},{"location":"Bootloader/qemu/U-boot_qemu/#carregando-o-u-boot-com-qemu","text":"Para utilizar o QEMU para arquiteturas ARM64 \u00e9 necess\u00e1rio instalar o pacote: sudo apt install qemu-system-arm Dentro da pasta out , execute o seguinte comando: qemu-system-aarch64 -M virt -nographic -cpu cortex-a57 -bios u-boot.bin onde o par\u00e2metro -bios \u00e9 o binario que acabou de ser criado pela nossa build. Ap\u00f3s executar o comando, o u-boot dever\u00e1 iniciar normalmente:","title":"Carregando o U-boot com QEMU"},{"location":"Documenta%C3%A7%C3%A3o/Parti%C3%A7%C3%B5es/GPT/","text":"Tabela de Parti\u00e7\u00e3o GUID baseado nos link1 , link2 e link3 Considera\u00e7\u00f5es iniciais Vamos utilizar um cart\u00e3o micro SD de 32GB. Para identificarmos o cart\u00e3o no sistema, utilizamos o comando lsblk , o resultado ser\u00e1 similar a essa \u2570\u2500 lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT sda 8 :0 0 894 ,3G 0 disk \u2514\u2500sda1 8 :1 0 894 ,3G 0 part /run/timeshift/backup sdc 8 :32 1 29 ,1G 0 disk \u2514\u2500sdc1 8 :33 1 29 ,1G 0 part nvme0n1 259 :0 0 465 ,8G 0 disk \u251c\u2500nvme0n1p1 259 :1 0 476M 0 part /boot/efi \u251c\u2500nvme0n1p2 259 :2 0 30 ,5G 0 part [ SWAP ] \u2514\u2500nvme0n1p3 259 :3 0 434 ,8G 0 part / Para ter certeza qual \u00e9 o cart\u00e3o SD, execute o lsblk com o cart\u00e3o n\u00e3o conectado e depois conecte o cart\u00e3o e execute o comando novamente (simples ). No caso acima, o cart\u00e3o SD \u00e9 o /dev/sdc . Para facilitar a visualiza\u00e7\u00e3o das altera\u00e7\u00f5es que iremos fazer, vamos zerar os primeiros 10240 bytes do cart\u00e3o. Para isso, utilizaremos o comando dd sudo dd if = /dev/zero of = /dev/sdc bs = 1024 count = 10 Podemos visualizar conte\u00fado do cart\u00e3o, com o comando hexdump sudo hexdump -C /dev/sdc -n 10240 O resultado deve ser similar a esse 00000000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | ................ | * 00002800 o n\u00famero 00002800 \u00e9 em hexadecimal e seu equivalente em decimal \u00e9 10240 (ou 10 kB). Formatando o cart\u00e3o com GPT Com os primeiros bytes do cart\u00e3o SD zerados, vamos adicionar a parti\u00e7\u00e3o GPT ao cart\u00e3o com o comando fdisk sudo fdisk /dev/sdc Um menu ir\u00e1 aparecer: Digite g Depois digite n Partition number (1-128, default 1): Enter First sector (2048-61067230, default 2048): Enter Last sector, +/-sectors or +/-size{K,M,G,T,P} (2048-61067230, default 61067230): Enter Por fim, digite w Agora o cart\u00e3o est\u00e1 com o particionamento GPT. Para checar, vamos visualizar novamente o conte\u00fado do cart\u00e3o SD 00000000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | ................ | * 000001c0 02 00 ee ff ff ff 01 00 00 00 ff cf a3 03 00 00 | ................ | 000001d0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | ................ | * 000001f0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 55 aa | ..............U. | 00000200 45 46 49 20 50 41 52 54 00 00 01 00 5c 00 00 00 | EFI PART.... \\. .. | 00000210 fc d8 3a 53 00 00 00 00 01 00 00 00 00 00 00 00 | ..:S............ | 00000220 ff cf a3 03 00 00 00 00 00 08 00 00 00 00 00 00 | ................ | 00000230 de cf a3 03 00 00 00 00 90 30 7b d4 f3 72 46 59 | .........0 { ..rFY | 00000240 89 2c 7f 77 9e b0 00 e6 02 00 00 00 00 00 00 00 | .,.w............ | 00000250 80 00 00 00 80 00 00 00 f1 ae 2f f5 00 00 00 00 | ........../..... | 00000260 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | ................ | * 00000400 af 3d c6 0f 83 84 72 47 8e 79 3d 69 d8 47 7d e4 | . = ....rG.y = i.G } . | 00000410 9c 58 84 76 3e 65 45 92 a4 ec 96 ed 84 df 22 99 | .X.v>eE....... \".| 00000420 00 08 00 00 00 00 00 00 de cf a3 03 00 00 00 00 |................| 00000430 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 00002800 Esses dados mostram que o GPT est\u00e1 sendo usando no cart\u00e3o SD. O Backup de seguran\u00e7a Como uma forma de seguran\u00e7a contra perda de dados, o GPT faz um backup da parti\u00e7\u00e3o no final disco. Para checar basta utilizar o comando: sudo tail -c 10M /dev/sdc | hexdump -C Visualizando os \u00faltimos 10 MB do cart\u00e3o SD, encontramos o seguinte conte\u00fado 747900000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | ................ | * 7479fbe00 af 3d c6 0f 83 84 72 47 8e 79 3d 69 d8 47 7d e4 | . = ....rG.y = i.G } . | 7479fbe10 9c 58 84 76 3e 65 45 92 a4 ec 96 ed 84 df 22 99 | .X.v>eE....... \".| 7479fbe20 00 08 00 00 00 00 00 00 de cf a3 03 00 00 00 00 |................| 7479fbe30 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 7479ffe00 45 46 49 20 50 41 52 54 00 00 01 00 5c 00 00 00 |EFI PART....\\...| 7479ffe10 66 9b 01 67 00 00 00 00 ff cf a3 03 00 00 00 00 |f..g............| 7479ffe20 01 00 00 00 00 00 00 00 00 08 00 00 00 00 00 00 |................| 7479ffe30 de cf a3 03 00 00 00 00 90 30 7b d4 f3 72 46 59 |.........0{..rFY| 7479ffe40 89 2c 7f 77 9e b0 00 e6 df cf a3 03 00 00 00 00 |.,.w............| 7479ffe50 80 00 00 00 80 00 00 00 f1 ae 2f f5 00 00 00 00 |........../.....| 7479ffe60 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 747a00000 Podemos perceber um espelho dos dados do inicio do disco. O Logical Block Addressing O Logical Block Addressing ou LBA, s\u00e3o blocos de informa\u00e7\u00e3o utilizado pelo GPT. Esses blocos possuem 512 bytes. LBA0 O LBA0 existe para compatibilidade com o Master Boot Record (MBR), checando os primeiros 512 bytes do cart\u00e3o SD sudo hexdump -C /dev/sdc -s 0 -n 512 Temos esse resultado: 00000000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 000001c0 02 00 ee ff ff ff 01 00 00 00 ff cf a3 03 00 00 |................| 000001d0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 000001f0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 55 aa |..............U.| 00000200 Nada relevante pode ser visto aqui (a n\u00e3o ser que voc\u00ea esteja usando MBR ) LBA1 Esse LBA possui o cabe\u00e7alho da tabela de parti\u00e7\u00e3o. Visualizando os pr\u00f3ximos 512 bytes do cart\u00e3o SD sudo hexdump -C /dev/sdc -s 512 -n 512 Temos os seguintes dados: 00000200 45 46 49 20 50 41 52 54 00 00 01 00 5c 00 00 00 |EFI PART....\\...| 00000210 d2 61 e7 36 00 00 00 00 01 00 00 00 00 00 00 00 |.a.6............| 00000220 ff cf a3 03 00 00 00 00 00 08 00 00 00 00 00 00 |................| 00000230 de cf a3 03 00 00 00 00 46 8a 0b 22 c3 8c 45 75 |........F..\"..Eu| 00000240 8c ef f5 bd 9e 32 4c 5b 02 00 00 00 00 00 00 00 |.....2L[........| 00000250 80 00 00 00 80 00 00 00 af 06 c5 b4 00 00 00 00 |................| 00000260 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 00000400 Agora vamos entender esse vetor de bytes: Esses dados s\u00e3o Little Endian . Para interpretarmos o valor em decimal, devemos converter para Big Endian A assinatura s\u00e3o os primeiros 8 bytes 00000200 45 46 49 20 50 41 52 54 |EFI PART| 00000208 A revis\u00e3o s\u00e3o os 4 pr\u00f3ximos bytes 00000208 00 00 01 00 |....| 0000020c O tamanho do cabe\u00e7alho s\u00e3o os 4 pr\u00f3ximos bytes 0000020c 5c 00 00 00 |\\...| 00000210 O CRC32 da parti\u00e7\u00e3o s\u00e3o os 4 pr\u00f3ximos bytes 00000210 d2 61 e7 36 |.a.6| 00000214 Os pr\u00f3ximos 4 bytes s\u00e3o reservados e devem ser 0's 00000214 00 00 00 00 |....| 00000218 Endere\u00e7o do LBA atual s\u00e3o os 8 pr\u00f3ximos bytes 00000218 01 00 00 00 00 00 00 00 |........| 00000220 Localiza\u00e7\u00e3o do LBA espelho (backup) s\u00e3o os 8 pr\u00f3ximos bytes 00000220 ff cf a3 03 00 00 00 00 |........| 00000228 Big Endian: 00 00 00 00 03 A3 CF FF | Decimal 61067263. Isso indica que o LBA espelho est\u00e1 no setor 61067263. Para acessa-lo podemos utilizar o comando: sudo dd if=/dev/sdc bs=512 count=1 skip=61067263 Primeiro setor dispon\u00edvel para parti\u00e7\u00e3o s\u00e3o os pr\u00f3ximos 8 bytes 00000228 00 08 00 00 00 00 00 00 |........| 00000230 00 00 08 00 00 00 00 00 -> 2048 \u00daltimo setor dispon\u00edvel para parti\u00e7\u00e3o s\u00e3o os pr\u00f3ximos 8 bytes 00000230 de cf a3 03 00 00 00 00 |........| 00000238 Big endian: 0000000003A3CFDE | Decimal: 61067230. O \u00faltimo setor dispon\u00edvel \u00e9 o 61067230. O GUID s\u00e3o os pr\u00f3ximos 16 bytes 00000238 46 8a 0b 22 c3 8c 45 75 8c ef f5 bd 9e 32 4c 5b |F..\"..Eu.....2L[| 00000248 O GUID possui segmenta\u00e7\u00f5es: 468a0b22-c38c-4575-8cef-f5bd9e324c5b. Os primeiros 8 bytes s\u00e3o convertidos para big endian e o restante n\u00e3o \u00e9 convertido, resultando em: 220B8A46-8CC3-7545-8CEF-F5BD9E324C5B O setor que inicia as tabelas de parti\u00e7\u00e3o s\u00e3o os pr\u00f3ximos 8 bytes 00000248 02 00 00 00 00 00 00 00 |........| 00000250 Quantidades poss\u00edveis de parti\u00e7\u00f5es s\u00e3o os pr\u00f3ximos 4 bytes 00000250 80 00 00 00 |....| 00000254 Tamanho de um entrada da tabela de parti\u00e7\u00e3o s\u00e3o os pr\u00f3ximos 4 bytes 00000254 80 00 00 00 |....| 00000258 CRC32 de todas as entradas de parti\u00e7\u00e3o do disco s\u00e3o os pr\u00f3ximos 4 bytes 00000258 af 06 c5 b4 |....| 0000025c Restante do espa\u00e7o s\u00e3o 420 bytes 0000025c 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 00000400 LB2 - LBN 00000400 af 3d c6 0f 83 84 72 47 8e 79 3d 69 d8 47 7d e4 |.=....rG.y=i.G}.| 00000410 a0 d5 b4 b0 cf d0 4d fe b7 09 a8 3f 44 67 bd b7 |......M....?Dg..| 00000420 00 08 00 00 00 00 00 00 de cf a3 03 00 00 00 00 |................| 00000430 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 00000480 Tipo de parti\u00e7\u00e3o GUID s\u00e3o os primeiros 16 bytes 00000400 af 3d c6 0f 83 84 72 47 8e 79 3d 69 d8 47 7d e4 |.=....rG.y=i.G}.| 00000410 GUID \u00fanico s\u00e3o os pr\u00f3ximos 16 bytes 00000410 a0 d5 b4 b0 cf d0 4d fe b7 09 a8 3f 44 67 bd b7 |......M....?Dg..| 00000420 Primeiro setor dispon\u00edvel para parti\u00e7\u00e3o s\u00e3o os pr\u00f3ximos 8 bytes 00000420 00 08 00 00 00 00 00 00 |........| 00000428 \u00daltimo setor dispon\u00edvel para parti\u00e7\u00e3o s\u00e3o os pr\u00f3ximos 8 bytes 00000428 de cf a3 03 00 00 00 00 |........| 00000430 Os atributos s\u00e3o os pr\u00f3ximos 8 bytes 00000430 00 00 00 00 00 00 00 00 |........| 00000438 O nome da parti\u00e7\u00e3o s\u00e3o os pr\u00f3ximos 72 bytes 00000438 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 00000480","title":"Tabela de Parti\u00e7\u00e3o GUID"},{"location":"Documenta%C3%A7%C3%A3o/Parti%C3%A7%C3%B5es/GPT/#tabela-de-particao-guid","text":"baseado nos link1 , link2 e link3","title":"Tabela de Parti\u00e7\u00e3o GUID"},{"location":"Documenta%C3%A7%C3%A3o/Parti%C3%A7%C3%B5es/GPT/#consideracoes-iniciais","text":"Vamos utilizar um cart\u00e3o micro SD de 32GB. Para identificarmos o cart\u00e3o no sistema, utilizamos o comando lsblk , o resultado ser\u00e1 similar a essa \u2570\u2500 lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT sda 8 :0 0 894 ,3G 0 disk \u2514\u2500sda1 8 :1 0 894 ,3G 0 part /run/timeshift/backup sdc 8 :32 1 29 ,1G 0 disk \u2514\u2500sdc1 8 :33 1 29 ,1G 0 part nvme0n1 259 :0 0 465 ,8G 0 disk \u251c\u2500nvme0n1p1 259 :1 0 476M 0 part /boot/efi \u251c\u2500nvme0n1p2 259 :2 0 30 ,5G 0 part [ SWAP ] \u2514\u2500nvme0n1p3 259 :3 0 434 ,8G 0 part / Para ter certeza qual \u00e9 o cart\u00e3o SD, execute o lsblk com o cart\u00e3o n\u00e3o conectado e depois conecte o cart\u00e3o e execute o comando novamente (simples ). No caso acima, o cart\u00e3o SD \u00e9 o /dev/sdc . Para facilitar a visualiza\u00e7\u00e3o das altera\u00e7\u00f5es que iremos fazer, vamos zerar os primeiros 10240 bytes do cart\u00e3o. Para isso, utilizaremos o comando dd sudo dd if = /dev/zero of = /dev/sdc bs = 1024 count = 10 Podemos visualizar conte\u00fado do cart\u00e3o, com o comando hexdump sudo hexdump -C /dev/sdc -n 10240 O resultado deve ser similar a esse 00000000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | ................ | * 00002800 o n\u00famero 00002800 \u00e9 em hexadecimal e seu equivalente em decimal \u00e9 10240 (ou 10 kB).","title":"Considera\u00e7\u00f5es iniciais"},{"location":"Documenta%C3%A7%C3%A3o/Parti%C3%A7%C3%B5es/GPT/#formatando-o-cartao-com-gpt","text":"Com os primeiros bytes do cart\u00e3o SD zerados, vamos adicionar a parti\u00e7\u00e3o GPT ao cart\u00e3o com o comando fdisk sudo fdisk /dev/sdc Um menu ir\u00e1 aparecer: Digite g Depois digite n Partition number (1-128, default 1): Enter First sector (2048-61067230, default 2048): Enter Last sector, +/-sectors or +/-size{K,M,G,T,P} (2048-61067230, default 61067230): Enter Por fim, digite w Agora o cart\u00e3o est\u00e1 com o particionamento GPT. Para checar, vamos visualizar novamente o conte\u00fado do cart\u00e3o SD 00000000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | ................ | * 000001c0 02 00 ee ff ff ff 01 00 00 00 ff cf a3 03 00 00 | ................ | 000001d0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | ................ | * 000001f0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 55 aa | ..............U. | 00000200 45 46 49 20 50 41 52 54 00 00 01 00 5c 00 00 00 | EFI PART.... \\. .. | 00000210 fc d8 3a 53 00 00 00 00 01 00 00 00 00 00 00 00 | ..:S............ | 00000220 ff cf a3 03 00 00 00 00 00 08 00 00 00 00 00 00 | ................ | 00000230 de cf a3 03 00 00 00 00 90 30 7b d4 f3 72 46 59 | .........0 { ..rFY | 00000240 89 2c 7f 77 9e b0 00 e6 02 00 00 00 00 00 00 00 | .,.w............ | 00000250 80 00 00 00 80 00 00 00 f1 ae 2f f5 00 00 00 00 | ........../..... | 00000260 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | ................ | * 00000400 af 3d c6 0f 83 84 72 47 8e 79 3d 69 d8 47 7d e4 | . = ....rG.y = i.G } . | 00000410 9c 58 84 76 3e 65 45 92 a4 ec 96 ed 84 df 22 99 | .X.v>eE....... \".| 00000420 00 08 00 00 00 00 00 00 de cf a3 03 00 00 00 00 |................| 00000430 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 00002800 Esses dados mostram que o GPT est\u00e1 sendo usando no cart\u00e3o SD.","title":"Formatando o cart\u00e3o com GPT"},{"location":"Documenta%C3%A7%C3%A3o/Parti%C3%A7%C3%B5es/GPT/#o-backup-de-seguranca","text":"Como uma forma de seguran\u00e7a contra perda de dados, o GPT faz um backup da parti\u00e7\u00e3o no final disco. Para checar basta utilizar o comando: sudo tail -c 10M /dev/sdc | hexdump -C Visualizando os \u00faltimos 10 MB do cart\u00e3o SD, encontramos o seguinte conte\u00fado 747900000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | ................ | * 7479fbe00 af 3d c6 0f 83 84 72 47 8e 79 3d 69 d8 47 7d e4 | . = ....rG.y = i.G } . | 7479fbe10 9c 58 84 76 3e 65 45 92 a4 ec 96 ed 84 df 22 99 | .X.v>eE....... \".| 7479fbe20 00 08 00 00 00 00 00 00 de cf a3 03 00 00 00 00 |................| 7479fbe30 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 7479ffe00 45 46 49 20 50 41 52 54 00 00 01 00 5c 00 00 00 |EFI PART....\\...| 7479ffe10 66 9b 01 67 00 00 00 00 ff cf a3 03 00 00 00 00 |f..g............| 7479ffe20 01 00 00 00 00 00 00 00 00 08 00 00 00 00 00 00 |................| 7479ffe30 de cf a3 03 00 00 00 00 90 30 7b d4 f3 72 46 59 |.........0{..rFY| 7479ffe40 89 2c 7f 77 9e b0 00 e6 df cf a3 03 00 00 00 00 |.,.w............| 7479ffe50 80 00 00 00 80 00 00 00 f1 ae 2f f5 00 00 00 00 |........../.....| 7479ffe60 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 747a00000 Podemos perceber um espelho dos dados do inicio do disco.","title":"O Backup de seguran\u00e7a"},{"location":"Documenta%C3%A7%C3%A3o/Parti%C3%A7%C3%B5es/GPT/#o-logical-block-addressing","text":"O Logical Block Addressing ou LBA, s\u00e3o blocos de informa\u00e7\u00e3o utilizado pelo GPT. Esses blocos possuem 512 bytes.","title":"O Logical Block Addressing"},{"location":"Documenta%C3%A7%C3%A3o/Parti%C3%A7%C3%B5es/GPT/#lba0","text":"O LBA0 existe para compatibilidade com o Master Boot Record (MBR), checando os primeiros 512 bytes do cart\u00e3o SD sudo hexdump -C /dev/sdc -s 0 -n 512 Temos esse resultado: 00000000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 000001c0 02 00 ee ff ff ff 01 00 00 00 ff cf a3 03 00 00 |................| 000001d0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 000001f0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 55 aa |..............U.| 00000200 Nada relevante pode ser visto aqui (a n\u00e3o ser que voc\u00ea esteja usando MBR )","title":"LBA0"},{"location":"Documenta%C3%A7%C3%A3o/Parti%C3%A7%C3%B5es/GPT/#lba1","text":"Esse LBA possui o cabe\u00e7alho da tabela de parti\u00e7\u00e3o. Visualizando os pr\u00f3ximos 512 bytes do cart\u00e3o SD sudo hexdump -C /dev/sdc -s 512 -n 512 Temos os seguintes dados: 00000200 45 46 49 20 50 41 52 54 00 00 01 00 5c 00 00 00 |EFI PART....\\...| 00000210 d2 61 e7 36 00 00 00 00 01 00 00 00 00 00 00 00 |.a.6............| 00000220 ff cf a3 03 00 00 00 00 00 08 00 00 00 00 00 00 |................| 00000230 de cf a3 03 00 00 00 00 46 8a 0b 22 c3 8c 45 75 |........F..\"..Eu| 00000240 8c ef f5 bd 9e 32 4c 5b 02 00 00 00 00 00 00 00 |.....2L[........| 00000250 80 00 00 00 80 00 00 00 af 06 c5 b4 00 00 00 00 |................| 00000260 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 00000400 Agora vamos entender esse vetor de bytes: Esses dados s\u00e3o Little Endian . Para interpretarmos o valor em decimal, devemos converter para Big Endian A assinatura s\u00e3o os primeiros 8 bytes 00000200 45 46 49 20 50 41 52 54 |EFI PART| 00000208 A revis\u00e3o s\u00e3o os 4 pr\u00f3ximos bytes 00000208 00 00 01 00 |....| 0000020c O tamanho do cabe\u00e7alho s\u00e3o os 4 pr\u00f3ximos bytes 0000020c 5c 00 00 00 |\\...| 00000210 O CRC32 da parti\u00e7\u00e3o s\u00e3o os 4 pr\u00f3ximos bytes 00000210 d2 61 e7 36 |.a.6| 00000214 Os pr\u00f3ximos 4 bytes s\u00e3o reservados e devem ser 0's 00000214 00 00 00 00 |....| 00000218 Endere\u00e7o do LBA atual s\u00e3o os 8 pr\u00f3ximos bytes 00000218 01 00 00 00 00 00 00 00 |........| 00000220 Localiza\u00e7\u00e3o do LBA espelho (backup) s\u00e3o os 8 pr\u00f3ximos bytes 00000220 ff cf a3 03 00 00 00 00 |........| 00000228 Big Endian: 00 00 00 00 03 A3 CF FF | Decimal 61067263. Isso indica que o LBA espelho est\u00e1 no setor 61067263. Para acessa-lo podemos utilizar o comando: sudo dd if=/dev/sdc bs=512 count=1 skip=61067263 Primeiro setor dispon\u00edvel para parti\u00e7\u00e3o s\u00e3o os pr\u00f3ximos 8 bytes 00000228 00 08 00 00 00 00 00 00 |........| 00000230 00 00 08 00 00 00 00 00 -> 2048 \u00daltimo setor dispon\u00edvel para parti\u00e7\u00e3o s\u00e3o os pr\u00f3ximos 8 bytes 00000230 de cf a3 03 00 00 00 00 |........| 00000238 Big endian: 0000000003A3CFDE | Decimal: 61067230. O \u00faltimo setor dispon\u00edvel \u00e9 o 61067230. O GUID s\u00e3o os pr\u00f3ximos 16 bytes 00000238 46 8a 0b 22 c3 8c 45 75 8c ef f5 bd 9e 32 4c 5b |F..\"..Eu.....2L[| 00000248 O GUID possui segmenta\u00e7\u00f5es: 468a0b22-c38c-4575-8cef-f5bd9e324c5b. Os primeiros 8 bytes s\u00e3o convertidos para big endian e o restante n\u00e3o \u00e9 convertido, resultando em: 220B8A46-8CC3-7545-8CEF-F5BD9E324C5B O setor que inicia as tabelas de parti\u00e7\u00e3o s\u00e3o os pr\u00f3ximos 8 bytes 00000248 02 00 00 00 00 00 00 00 |........| 00000250 Quantidades poss\u00edveis de parti\u00e7\u00f5es s\u00e3o os pr\u00f3ximos 4 bytes 00000250 80 00 00 00 |....| 00000254 Tamanho de um entrada da tabela de parti\u00e7\u00e3o s\u00e3o os pr\u00f3ximos 4 bytes 00000254 80 00 00 00 |....| 00000258 CRC32 de todas as entradas de parti\u00e7\u00e3o do disco s\u00e3o os pr\u00f3ximos 4 bytes 00000258 af 06 c5 b4 |....| 0000025c Restante do espa\u00e7o s\u00e3o 420 bytes 0000025c 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 00000400","title":"LBA1"},{"location":"Documenta%C3%A7%C3%A3o/Parti%C3%A7%C3%B5es/GPT/#lb2-lbn","text":"00000400 af 3d c6 0f 83 84 72 47 8e 79 3d 69 d8 47 7d e4 |.=....rG.y=i.G}.| 00000410 a0 d5 b4 b0 cf d0 4d fe b7 09 a8 3f 44 67 bd b7 |......M....?Dg..| 00000420 00 08 00 00 00 00 00 00 de cf a3 03 00 00 00 00 |................| 00000430 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 00000480 Tipo de parti\u00e7\u00e3o GUID s\u00e3o os primeiros 16 bytes 00000400 af 3d c6 0f 83 84 72 47 8e 79 3d 69 d8 47 7d e4 |.=....rG.y=i.G}.| 00000410 GUID \u00fanico s\u00e3o os pr\u00f3ximos 16 bytes 00000410 a0 d5 b4 b0 cf d0 4d fe b7 09 a8 3f 44 67 bd b7 |......M....?Dg..| 00000420 Primeiro setor dispon\u00edvel para parti\u00e7\u00e3o s\u00e3o os pr\u00f3ximos 8 bytes 00000420 00 08 00 00 00 00 00 00 |........| 00000428 \u00daltimo setor dispon\u00edvel para parti\u00e7\u00e3o s\u00e3o os pr\u00f3ximos 8 bytes 00000428 de cf a3 03 00 00 00 00 |........| 00000430 Os atributos s\u00e3o os pr\u00f3ximos 8 bytes 00000430 00 00 00 00 00 00 00 00 |........| 00000438 O nome da parti\u00e7\u00e3o s\u00e3o os pr\u00f3ximos 72 bytes 00000438 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 00000480","title":"LB2 - LBN"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/","text":"Documenta\u00e7\u00e3o com MKDOCS Image by WikiImages from Pixabay Introdu\u00e7\u00e3o Essa postagem foi inspirado na live de python #189 . Se quiser mais informa\u00e7\u00f5es sobre MKDocs da uma olhada no v\u00eddeo e deixa o like. O MKDocs \u00e9 uma biblioteca focada em documenta\u00e7\u00e3o, desenvolvida em python. Ela possui v\u00e1rias funcionalidades e algumas delas ser\u00e3o mostradas abaixo. Para instalar: pip install mkdocs Ap\u00f3s a instala\u00e7\u00e3o basta digitar: mkdocs new TESTE Os arquivos necess\u00e1rios para iniciar a documenta\u00e7\u00e3o ser\u00e3o criados. Markdown B\u00e1sico Comandos dispon\u00edveis por padr\u00e3o na biblioteca. T\u00edtulo (H1) # Exemplo Subtitulo (H2) ## Exemplo Subsubtitulo (H3) ### Exemplo Negrito **Exemplo** Exemplo It\u00e1lico *Exemplo* Exemplo Cita\u00e7\u00e3o > Exemplo Exemplo Lista Ordenada 1. Exemplo 2. Exemplo 3. Exemplo Exemplo Exemplo Exemplo Lista N\u00e3o Ordenada - Exemplo - Exemplo - Exemplo Exemplo Exemplo Exemplo Linha de C\u00f3digo `C\u00f3digo` C\u00f3digo Link [Site do google](https://www.google.com.br) Site do google Tabela | Nome | Idade | | ---- | ----- | | Jo\u00e3o | 28 | | Pedro | 34 | Nome Idade Jo\u00e3o 28 Pedro 34 Markdown Estendido Para ter ainda mais funcionalidades, \u00e9 necess\u00e1rio instalar a biblioteca PyMdown Extensions : pip install pymdown-extensions Al\u00e9m disso, \u00e9 necess\u00e1rio adicionar quais extens\u00f5es ser\u00e3o usadas dentro do arquivo mkdocs.yml , por exemplo: markdown_extensions: - pymdownx.tasklist - pymdownx.emoji - pymdownx.mark - pymdownx.tilde Cada uma dessas extens\u00f5es ser\u00e3o mostradas a seguir. Lista de Tarefas pymdownx.tasklist - [ ] Checar. - [ ] checar. - [X] checado. Checar. checar. checado. Emoji Para mais emojis: emojipedia . Escolha um emoji e procure por Shortcodes . pymdownx.emoji :snake: :heart: :rocket: Tachado pymdownx.tilde ~~Exemplo~~ Exemplo Real\u00e7ado pymdownx.mark ==Exemplo== Exemplo Super Fences Dentro do pymdown-extensions existe uma funcionalidade que merece um t\u00f3pico a parte, chamado de superfences . Com ele, o MKDocs fica ainda mais poderoso. \u00c9 necess\u00e1rio informar para o MKDocs que o super fences ser\u00e1 utilizado, adicionando as linhas dentro do mkdocs.yml : markdown_extensions: # ... - pymdownx.superfences: custom_fences: - name: mermaid class: mermaid format: !!python/name:pymdownx.superfences.fence_div_format extra_javascript: - https://unpkg.com/mermaid@8.5.1/dist/mermaid.min.js Bloco de c\u00f3digo pymdownx.superfences ```{.py3 linenums=\"44\" title=\"teste.py\" hl_lines=\"1 3\"} def xpto(): \"\"\"Docstring\"\"\" return True ``` teste.py 44 45 46 def xpto (): \"\"\"Docstring\"\"\" return True F\u00f3rmulas pymdownx.arithmatex $$ \\operatorname{ker} f=\\{g\\in G:f(g)=e_{H}\\}{\\mbox{.}} $$ \\[ \\operatorname{ker} f=\\{g\\in G:f(g)=e_{H}\\}{\\mbox{.}} \\] The homomorphism $f$ is injective if and only if its kernel is only the singleton set $e_G$, because otherwise $\\exists a,b\\in G$ with $a\\neq b$ such that $f(a)=f(b)$. The homomorphism \\(f\\) is injective if and only if its kernel is only the singleton set \\(e_G\\) , because otherwise \\(\\exists a,b\\in G\\) with \\(a\\neq b\\) such that \\(f(a)=f(b)\\) . Custom Fences \u00c9 poss\u00edvel incorporar outras bibliotecas dentro do MKDocs, por exemplo a Mermaid que \u00e9 uma biblioteca para gerar diagramas e gr\u00e1ficos. Para isso, \u00e9 necess\u00e1rio adicionar no mkdocs.yml - pymdownx.superfences: custom_fences: - name: mermaid class: mermaid format: !!python/name:pymdownx.superfences.fence_div_format extra_javascript: - https://unpkg.com/mermaid@8.5.1/dist/mermaid.min.js ```mermaid classDiagram Pessoa <|-- Eduardo class Pessoa{ +String nome +metodo(self):bool } ``` classDiagram Pessoa <|-- Jao class Pessoa{ +String nome +metodo(self):bool }","title":"Documenta\u00e7\u00e3o com MKDOCS"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#documentacao-com-mkdocs","text":"Image by WikiImages from Pixabay","title":"Documenta\u00e7\u00e3o com MKDOCS"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#introducao","text":"Essa postagem foi inspirado na live de python #189 . Se quiser mais informa\u00e7\u00f5es sobre MKDocs da uma olhada no v\u00eddeo e deixa o like. O MKDocs \u00e9 uma biblioteca focada em documenta\u00e7\u00e3o, desenvolvida em python. Ela possui v\u00e1rias funcionalidades e algumas delas ser\u00e3o mostradas abaixo. Para instalar: pip install mkdocs Ap\u00f3s a instala\u00e7\u00e3o basta digitar: mkdocs new TESTE Os arquivos necess\u00e1rios para iniciar a documenta\u00e7\u00e3o ser\u00e3o criados.","title":"Introdu\u00e7\u00e3o"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#markdown-basico","text":"Comandos dispon\u00edveis por padr\u00e3o na biblioteca.","title":"Markdown B\u00e1sico"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#titulo-h1","text":"# Exemplo","title":"T\u00edtulo (H1)"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#subtitulo-h2","text":"## Exemplo","title":"Subtitulo (H2)"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#subsubtitulo-h3","text":"### Exemplo","title":"Subsubtitulo (H3)"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#negrito","text":"**Exemplo** Exemplo","title":"Negrito"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#italico","text":"*Exemplo* Exemplo","title":"It\u00e1lico"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#citacao","text":"> Exemplo Exemplo","title":"Cita\u00e7\u00e3o"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#lista-ordenada","text":"1. Exemplo 2. Exemplo 3. Exemplo Exemplo Exemplo Exemplo","title":"Lista Ordenada"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#lista-nao-ordenada","text":"- Exemplo - Exemplo - Exemplo Exemplo Exemplo Exemplo","title":"Lista N\u00e3o Ordenada"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#linha-de-codigo","text":"`C\u00f3digo` C\u00f3digo","title":"Linha de C\u00f3digo"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#link","text":"[Site do google](https://www.google.com.br) Site do google","title":"Link"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#tabela","text":"| Nome | Idade | | ---- | ----- | | Jo\u00e3o | 28 | | Pedro | 34 | Nome Idade Jo\u00e3o 28 Pedro 34","title":"Tabela"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#markdown-estendido","text":"Para ter ainda mais funcionalidades, \u00e9 necess\u00e1rio instalar a biblioteca PyMdown Extensions : pip install pymdown-extensions Al\u00e9m disso, \u00e9 necess\u00e1rio adicionar quais extens\u00f5es ser\u00e3o usadas dentro do arquivo mkdocs.yml , por exemplo: markdown_extensions: - pymdownx.tasklist - pymdownx.emoji - pymdownx.mark - pymdownx.tilde Cada uma dessas extens\u00f5es ser\u00e3o mostradas a seguir.","title":"Markdown Estendido"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#lista-de-tarefas","text":"pymdownx.tasklist - [ ] Checar. - [ ] checar. - [X] checado. Checar. checar. checado.","title":"Lista de Tarefas"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#emoji","text":"Para mais emojis: emojipedia . Escolha um emoji e procure por Shortcodes . pymdownx.emoji :snake: :heart: :rocket:","title":"Emoji"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#tachado","text":"pymdownx.tilde ~~Exemplo~~ Exemplo","title":"Tachado"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#realcado","text":"pymdownx.mark ==Exemplo== Exemplo","title":"Real\u00e7ado"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#super-fences","text":"Dentro do pymdown-extensions existe uma funcionalidade que merece um t\u00f3pico a parte, chamado de superfences . Com ele, o MKDocs fica ainda mais poderoso. \u00c9 necess\u00e1rio informar para o MKDocs que o super fences ser\u00e1 utilizado, adicionando as linhas dentro do mkdocs.yml : markdown_extensions: # ... - pymdownx.superfences: custom_fences: - name: mermaid class: mermaid format: !!python/name:pymdownx.superfences.fence_div_format extra_javascript: - https://unpkg.com/mermaid@8.5.1/dist/mermaid.min.js","title":"Super Fences"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#bloco-de-codigo","text":"pymdownx.superfences ```{.py3 linenums=\"44\" title=\"teste.py\" hl_lines=\"1 3\"} def xpto(): \"\"\"Docstring\"\"\" return True ``` teste.py 44 45 46 def xpto (): \"\"\"Docstring\"\"\" return True","title":"Bloco de c\u00f3digo"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#formulas","text":"pymdownx.arithmatex $$ \\operatorname{ker} f=\\{g\\in G:f(g)=e_{H}\\}{\\mbox{.}} $$ \\[ \\operatorname{ker} f=\\{g\\in G:f(g)=e_{H}\\}{\\mbox{.}} \\] The homomorphism $f$ is injective if and only if its kernel is only the singleton set $e_G$, because otherwise $\\exists a,b\\in G$ with $a\\neq b$ such that $f(a)=f(b)$. The homomorphism \\(f\\) is injective if and only if its kernel is only the singleton set \\(e_G\\) , because otherwise \\(\\exists a,b\\in G\\) with \\(a\\neq b\\) such that \\(f(a)=f(b)\\) .","title":"F\u00f3rmulas"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#custom-fences","text":"\u00c9 poss\u00edvel incorporar outras bibliotecas dentro do MKDocs, por exemplo a Mermaid que \u00e9 uma biblioteca para gerar diagramas e gr\u00e1ficos. Para isso, \u00e9 necess\u00e1rio adicionar no mkdocs.yml - pymdownx.superfences: custom_fences: - name: mermaid class: mermaid format: !!python/name:pymdownx.superfences.fence_div_format extra_javascript: - https://unpkg.com/mermaid@8.5.1/dist/mermaid.min.js ```mermaid classDiagram Pessoa <|-- Eduardo class Pessoa{ +String nome +metodo(self):bool } ``` classDiagram Pessoa <|-- Jao class Pessoa{ +String nome +metodo(self):bool }","title":"Custom Fences"},{"location":"Linguagens/Rust/Cap1/","text":"Introdu\u00e7\u00e3o Instalando o Rust no linux Escrevendo o Hello World! Usando cargo (gerenciador de pacotes e sistema de build) Instalando o Rust no linux Devemos baixar o rustup , que \u00e9 responsp\u00e1vel por baixar o rust e fazer a instala\u00e7\u00e3o curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh Algumas informa\u00e7\u00f5es devem aparecer Welcome to Rust! This will download and install the official compiler for the Rust programming language, and its package manager, Cargo. Rustup metadata and toolchains will be installed into the Rustup home directory, located at: /home/jao/Documents/Programs/rust/rustup/ This can be modified with the RUSTUP_HOME environment variable. The Cargo home directory located at: /home/jao/Documents/Programs/rust/cargo/ This can be modified with the CARGO_HOME environment variable. The cargo, rustc, rustup and other commands will be added to Cargo's bin directory , located at: /home/jao/.cargo/bin This path will then be added to your PATH environment variable by modifying the profile files located at: /home/jao/.profile /home/jao/.zshenv You can uninstall at any time with rustup self uninstall and these changes will be reverted. Current installation options: default host triple: x86_64-unknown-linux-gnu default toolchain: stable (default) profile: default modify PATH variable: yes 1) Proceed with installation (default) 2) Customize installation 3) Cancel installation Basta digitar 1 e a instala\u00e7\u00e3o ir\u00e1 come\u00e7ar. Se tudo occorrer bem, a seguinte mensagem deve aparecer Rust is installed now. Great! To get started you may need to restart your current shell. This would reload your PATH environment variable to include Cargo's bin directory (/home/jao/Documents/Programs/rust/cargo//bin). To configure your current shell, run: source /home/jao/Documents/Programs/rust/cargo//env Alguns comandos \u00fateis rustup update rustup self uninstall rustc --version rustup doc Escrevendo o Hello World! Crie um arquivo chamado main.rs e adicione o conte\u00fado main.rs fn main () { println! ( \"Hello World!\" ); } Para compilar e executar, basta digitar no terminal rustc main.rc ./main O resultado ser\u00e1 o texto Hello World! Alguns comandos \u00fateis rustfmt (para formatar o c\u00f3digo) Usando cargo (gerenciador de pacotes e sistema de build) Para criar um projeto utilizando o cargo , basta usar o comando cargo new hello_cargo Um arquivo main.rs ser\u00e1 criado dentro da pasta hello_cargo/src/ . Para compilar o c\u00f3digo, basta digitar cargo build dentro da pasta hello_cargo, a pasta target/ ser\u00e1 criada e o execut\u00e1vel est\u00e1 em hello_cargo/target/debug , chamado de hello_cargo Comandos \u00fateis cargo run (para executar o programa) cargo check (para fazer as checagens no c\u00f3digo, sem compilar) cargo build --release (para fazer uma build de release, por padr\u00e3o a build \u00e9 de debug).","title":"Introdu\u00e7\u00e3o"},{"location":"Linguagens/Rust/Cap1/#introducao","text":"Instalando o Rust no linux Escrevendo o Hello World! Usando cargo (gerenciador de pacotes e sistema de build)","title":"Introdu\u00e7\u00e3o"},{"location":"Linguagens/Rust/Cap1/#instalando-o-rust-no-linux","text":"Devemos baixar o rustup , que \u00e9 responsp\u00e1vel por baixar o rust e fazer a instala\u00e7\u00e3o curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh Algumas informa\u00e7\u00f5es devem aparecer Welcome to Rust! This will download and install the official compiler for the Rust programming language, and its package manager, Cargo. Rustup metadata and toolchains will be installed into the Rustup home directory, located at: /home/jao/Documents/Programs/rust/rustup/ This can be modified with the RUSTUP_HOME environment variable. The Cargo home directory located at: /home/jao/Documents/Programs/rust/cargo/ This can be modified with the CARGO_HOME environment variable. The cargo, rustc, rustup and other commands will be added to Cargo's bin directory , located at: /home/jao/.cargo/bin This path will then be added to your PATH environment variable by modifying the profile files located at: /home/jao/.profile /home/jao/.zshenv You can uninstall at any time with rustup self uninstall and these changes will be reverted. Current installation options: default host triple: x86_64-unknown-linux-gnu default toolchain: stable (default) profile: default modify PATH variable: yes 1) Proceed with installation (default) 2) Customize installation 3) Cancel installation Basta digitar 1 e a instala\u00e7\u00e3o ir\u00e1 come\u00e7ar. Se tudo occorrer bem, a seguinte mensagem deve aparecer Rust is installed now. Great! To get started you may need to restart your current shell. This would reload your PATH environment variable to include Cargo's bin directory (/home/jao/Documents/Programs/rust/cargo//bin). To configure your current shell, run: source /home/jao/Documents/Programs/rust/cargo//env","title":"Instalando o Rust no linux"},{"location":"Linguagens/Rust/Cap1/#alguns-comandos-uteis","text":"rustup update rustup self uninstall rustc --version rustup doc","title":"Alguns comandos \u00fateis"},{"location":"Linguagens/Rust/Cap1/#escrevendo-o-hello-world","text":"Crie um arquivo chamado main.rs e adicione o conte\u00fado main.rs fn main () { println! ( \"Hello World!\" ); } Para compilar e executar, basta digitar no terminal rustc main.rc ./main O resultado ser\u00e1 o texto Hello World!","title":"Escrevendo o Hello World!"},{"location":"Linguagens/Rust/Cap1/#alguns-comandos-uteis_1","text":"rustfmt (para formatar o c\u00f3digo)","title":"Alguns comandos \u00fateis"},{"location":"Linguagens/Rust/Cap1/#usando-cargo-gerenciador-de-pacotes-e-sistema-de-build","text":"Para criar um projeto utilizando o cargo , basta usar o comando cargo new hello_cargo Um arquivo main.rs ser\u00e1 criado dentro da pasta hello_cargo/src/ . Para compilar o c\u00f3digo, basta digitar cargo build dentro da pasta hello_cargo, a pasta target/ ser\u00e1 criada e o execut\u00e1vel est\u00e1 em hello_cargo/target/debug , chamado de hello_cargo","title":"Usando cargo (gerenciador de pacotes e sistema de build)"},{"location":"Linguagens/Rust/Cap1/#comandos-uteis","text":"cargo run (para executar o programa) cargo check (para fazer as checagens no c\u00f3digo, sem compilar) cargo build --release (para fazer uma build de release, por padr\u00e3o a build \u00e9 de debug).","title":"Comandos \u00fateis"},{"location":"RTOS/zephyr/zephyr/","text":"Zephyr + Esp32 + Blinky = \u2764\ufe0f Image by methodshop from Pixabay Introdu\u00e7\u00e3o Recentemente voltei a pesquisar sobre Internet of Things (IoT) e durante uma conversas no trabalho fiquei sabendo do Zephyr. Por sorte, um Webnar da Embarcados aconteceu e pude me interar mais sobre essa plataforma. S\u00f3 tenho uma palavra para definir: Sensacional \ud83e\udd2f Instalando depend\u00eancias Estou usando Ubuntu 22.04 . sudo apt install --no-install-recommends git cmake ninja-build gperf \\ ccache dfu-util device-tree-compiler wget \\ python3-dev python3-pip python3-setuptools python3-tk python3-wheel xz-utils file \\ make gcc gcc-multilib g++-multilib libsdl2-dev O Zephyr usa o python para gerenciar os pacotes, algumas depend\u00eancias tamb\u00e9m s\u00e3o necess\u00e1rias pip3 install west Ap\u00f3s isso, \u00e9 necess\u00e1rio definir o local onde os arquivos ser\u00e3o salvos. No exemplo vou usar o caminho /home/jao/Documents/Workspace/IoT west init /home/jao/Documents/Workspace/IoT/PASTA_DO_ZEPHYR Alguns arquivos ser\u00e3o baixados do reposit\u00f3rio . Em seguida: PS: Demora... cd /home/jao/Documents/Workspace/IoT/PASTA_DO_ZEPHYR west update Depois de terminar a atualiza\u00e7\u00e3o, \u00e9 necess\u00e1rio exportar algumas vari\u00e1veis de ambiente: west zephyr-export e ent\u00e3o instalar as dep\u00eancencias restantes do python: pip3 install -r /home/jao/Documents/Workspace/IoT/PASTA_DO_ZEPHYR/zephyr/scripts/requirements.txt Baixando a toolchain Como vamos utilizar o Esp32, a toolchain pode ser baixada aqui . No meu caso estou usando a plataforma linux-amd64 Ap\u00f3s baixar a toolchain correto, extraia e adicione o caminho da pasta a vari\u00e1vel de ambiente ESPRESSIF_TOOLCHAIN_PATH export ESPRESSIF_TOOLCHAIN_PATH=/home/jao/Documents/Workspace/IoT/xtensa-esp32-elf/xtensa-esp32-elf/ \u00c9 necess\u00e1rio adicionar outra vari\u00e1vel: export ZEPHYR_TOOLCHAIN_VARIANT=\"espressif\" Finalmente, podemos baixar os pacotes referentes ao Esp32 do Zephyr: PS: O camando deve ser dado dentro da pasta do Zephyr, no caso: /home/jao/Documents/Workspace/IoT/PASTA_DO_ZEPHYR west espressif update Ap\u00f3s esse passo, o ambiente de configura\u00e7\u00e3o para o Esp32 estar\u00e1 finalizado. Exemplo Blinky Na vers\u00e3o atual do Zephyr 3.0.0 , \u00e9 necess\u00e1rio adicionar um m\u00f3dulo no device driver para que o led built-in sej\u00e1 reconhecido. Para isso, \u00e9 necess\u00e1rio criar um arquivo dentro do exemplo do Blincky do pr\u00f3prio Zephyr touch /home/jao/Documents/Workspace/IoT/PASTA_DO_ZEPHYR/zephyr/samples/basic/blinky/esp32.overlay o arquivo deve conter o seguinte conte\u00fado: / { aliases { led0 = &led0; }; leds { compatible = \"gpio-leds\"; led0: led_0 { gpios = <&gpio0 2 GPIO_ACTIVE_HIGH>; label = \"LED 0\"; }; }; }; Na linha gpios = <&gpio0 2 GPIO_ACTIVE_HIGH>; , o n\u00famero 2 \u00e9 referente ao gpio associado ao led built-in . Agora \u00e9 s\u00f3 compilar: PS: dentro da pasta: /home/jao/Documents/Workspace/IoT/PASTA_DO_ZEPHYR/ west build -p auto -b esp32 zephyr/samples/basic/blinky Muitas vezes o arquivo CMakeCache.txt, precisa ser deletado. Ele fica localizado em : /home/jao/Documents/Workspace/IoT/PASTA_DO_ZEPHYR/build/ Se tudo ocorrer bem, a seguinte mensagem deve aparecer: [103/103] Linking C executable zephyr/zephyr.elf Memory region Used Size Region Size %age Used mcuboot_hdr: 32 B 32 B 100.00% metadata: 28 B 32 B 87.50% ROM: 31172 B 4194240 B 0.74% iram0_0_seg: 13004 B 128 KB 9.92% irom0_0_seg: 13692 B 3342304 B 0.41% dram0_0_seg: 1240 B 180736 B 0.69% dram0_1_seg: 53 KB 110032 B 49.32% drom0_0_seg: 3826 B 4194240 B 0.09% rtc_iram_seg: 0 GB 8 KB 0.00% rtc_slow_seg: 0 GB 4 KB 0.00% IDT_LIST: 0 GB 8 KB 0.00% esptool.py v3.3-dev Creating esp32 image... Merged 6 ELF sections Successfully created esp32 image. Para flashar no esp32, pasta digitar o seguinte comando: west flash O resultado deve ser algo semelhante: Flash will be erased from 0x00010000 to 0x00033fff... Flash params set to 0x0220 Wrote 32768 bytes at 0x00001000 in 0.7 seconds (390.4 kbit/s)... Hash of data verified. Wrote 16384 bytes at 0x00008000 in 0.3 seconds (515.8 kbit/s)... Hash of data verified. Wrote 147456 bytes at 0x00010000 in 2.0 seconds (594.7 kbit/s)... Hash of data verified. Leaving... Hard resetting via RTS pin... Se o seguinte erro acontecer: /dev/ttyS0 failed to connect: Failed to connect to Espressif device: No serial data received. For troubleshooting steps visit: https://docs.espressif.com/projects/esptool/en/latest/troubleshooting.html A fatal error occurred: Could not connect to an Espressif device on any of the 2 available serial ports. Talvez seja necess\u00e1rio ficar segurando o bot\u00e3o boot do Esp32. \u00c9 isso, at\u00e9 a pr\u00f3xima.","title":"Zephyr + Esp32 + Blinky = \u2764\ufe0f"},{"location":"RTOS/zephyr/zephyr/#zephyr-esp32-blinky","text":"Image by methodshop from Pixabay","title":"Zephyr + Esp32 + Blinky = \u2764\ufe0f"},{"location":"RTOS/zephyr/zephyr/#introducao","text":"Recentemente voltei a pesquisar sobre Internet of Things (IoT) e durante uma conversas no trabalho fiquei sabendo do Zephyr. Por sorte, um Webnar da Embarcados aconteceu e pude me interar mais sobre essa plataforma. S\u00f3 tenho uma palavra para definir: Sensacional \ud83e\udd2f","title":"Introdu\u00e7\u00e3o"},{"location":"RTOS/zephyr/zephyr/#instalando-dependencias","text":"Estou usando Ubuntu 22.04 . sudo apt install --no-install-recommends git cmake ninja-build gperf \\ ccache dfu-util device-tree-compiler wget \\ python3-dev python3-pip python3-setuptools python3-tk python3-wheel xz-utils file \\ make gcc gcc-multilib g++-multilib libsdl2-dev O Zephyr usa o python para gerenciar os pacotes, algumas depend\u00eancias tamb\u00e9m s\u00e3o necess\u00e1rias pip3 install west Ap\u00f3s isso, \u00e9 necess\u00e1rio definir o local onde os arquivos ser\u00e3o salvos. No exemplo vou usar o caminho /home/jao/Documents/Workspace/IoT west init /home/jao/Documents/Workspace/IoT/PASTA_DO_ZEPHYR Alguns arquivos ser\u00e3o baixados do reposit\u00f3rio . Em seguida: PS: Demora... cd /home/jao/Documents/Workspace/IoT/PASTA_DO_ZEPHYR west update Depois de terminar a atualiza\u00e7\u00e3o, \u00e9 necess\u00e1rio exportar algumas vari\u00e1veis de ambiente: west zephyr-export e ent\u00e3o instalar as dep\u00eancencias restantes do python: pip3 install -r /home/jao/Documents/Workspace/IoT/PASTA_DO_ZEPHYR/zephyr/scripts/requirements.txt","title":"Instalando depend\u00eancias"},{"location":"RTOS/zephyr/zephyr/#baixando-a-toolchain","text":"Como vamos utilizar o Esp32, a toolchain pode ser baixada aqui . No meu caso estou usando a plataforma linux-amd64 Ap\u00f3s baixar a toolchain correto, extraia e adicione o caminho da pasta a vari\u00e1vel de ambiente ESPRESSIF_TOOLCHAIN_PATH export ESPRESSIF_TOOLCHAIN_PATH=/home/jao/Documents/Workspace/IoT/xtensa-esp32-elf/xtensa-esp32-elf/ \u00c9 necess\u00e1rio adicionar outra vari\u00e1vel: export ZEPHYR_TOOLCHAIN_VARIANT=\"espressif\" Finalmente, podemos baixar os pacotes referentes ao Esp32 do Zephyr: PS: O camando deve ser dado dentro da pasta do Zephyr, no caso: /home/jao/Documents/Workspace/IoT/PASTA_DO_ZEPHYR west espressif update Ap\u00f3s esse passo, o ambiente de configura\u00e7\u00e3o para o Esp32 estar\u00e1 finalizado.","title":"Baixando a toolchain"},{"location":"RTOS/zephyr/zephyr/#exemplo-blinky","text":"Na vers\u00e3o atual do Zephyr 3.0.0 , \u00e9 necess\u00e1rio adicionar um m\u00f3dulo no device driver para que o led built-in sej\u00e1 reconhecido. Para isso, \u00e9 necess\u00e1rio criar um arquivo dentro do exemplo do Blincky do pr\u00f3prio Zephyr touch /home/jao/Documents/Workspace/IoT/PASTA_DO_ZEPHYR/zephyr/samples/basic/blinky/esp32.overlay o arquivo deve conter o seguinte conte\u00fado: / { aliases { led0 = &led0; }; leds { compatible = \"gpio-leds\"; led0: led_0 { gpios = <&gpio0 2 GPIO_ACTIVE_HIGH>; label = \"LED 0\"; }; }; }; Na linha gpios = <&gpio0 2 GPIO_ACTIVE_HIGH>; , o n\u00famero 2 \u00e9 referente ao gpio associado ao led built-in . Agora \u00e9 s\u00f3 compilar: PS: dentro da pasta: /home/jao/Documents/Workspace/IoT/PASTA_DO_ZEPHYR/ west build -p auto -b esp32 zephyr/samples/basic/blinky Muitas vezes o arquivo CMakeCache.txt, precisa ser deletado. Ele fica localizado em : /home/jao/Documents/Workspace/IoT/PASTA_DO_ZEPHYR/build/ Se tudo ocorrer bem, a seguinte mensagem deve aparecer: [103/103] Linking C executable zephyr/zephyr.elf Memory region Used Size Region Size %age Used mcuboot_hdr: 32 B 32 B 100.00% metadata: 28 B 32 B 87.50% ROM: 31172 B 4194240 B 0.74% iram0_0_seg: 13004 B 128 KB 9.92% irom0_0_seg: 13692 B 3342304 B 0.41% dram0_0_seg: 1240 B 180736 B 0.69% dram0_1_seg: 53 KB 110032 B 49.32% drom0_0_seg: 3826 B 4194240 B 0.09% rtc_iram_seg: 0 GB 8 KB 0.00% rtc_slow_seg: 0 GB 4 KB 0.00% IDT_LIST: 0 GB 8 KB 0.00% esptool.py v3.3-dev Creating esp32 image... Merged 6 ELF sections Successfully created esp32 image. Para flashar no esp32, pasta digitar o seguinte comando: west flash O resultado deve ser algo semelhante: Flash will be erased from 0x00010000 to 0x00033fff... Flash params set to 0x0220 Wrote 32768 bytes at 0x00001000 in 0.7 seconds (390.4 kbit/s)... Hash of data verified. Wrote 16384 bytes at 0x00008000 in 0.3 seconds (515.8 kbit/s)... Hash of data verified. Wrote 147456 bytes at 0x00010000 in 2.0 seconds (594.7 kbit/s)... Hash of data verified. Leaving... Hard resetting via RTS pin... Se o seguinte erro acontecer: /dev/ttyS0 failed to connect: Failed to connect to Espressif device: No serial data received. For troubleshooting steps visit: https://docs.espressif.com/projects/esptool/en/latest/troubleshooting.html A fatal error occurred: Could not connect to an Espressif device on any of the 2 available serial ports. Talvez seja necess\u00e1rio ficar segurando o bot\u00e3o boot do Esp32. \u00c9 isso, at\u00e9 a pr\u00f3xima.","title":"Exemplo Blinky"}]}
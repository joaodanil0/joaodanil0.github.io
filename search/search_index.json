{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"D\u00favidas Gerais Como saber qual o endere\u00e7o que o SOC vai buscar, ap\u00f3s iniciar ? (Datasheet ?) Como o u-boot carrega o kernel linux ? Como colocar o Android em um SD card ? VIM3 Raspberry Como foi feito o port do Android ? Git do projeto site com os arquivos compilados","title":"D\u00favidas"},{"location":"#duvidas","text":"","title":"D\u00favidas"},{"location":"#gerais","text":"Como saber qual o endere\u00e7o que o SOC vai buscar, ap\u00f3s iniciar ? (Datasheet ?) Como o u-boot carrega o kernel linux ? Como colocar o Android em um SD card ?","title":"Gerais"},{"location":"#vim3","text":"","title":"VIM3"},{"location":"#raspberry","text":"Como foi feito o port do Android ? Git do projeto site com os arquivos compilados","title":"Raspberry"},{"location":"Android/boot.img/","text":"Boot.img Image by dexmac from Pixabay Introdu\u00e7\u00e3o A algum tempo venho tentando desbravar o mundo do Android embarcado. Sem sombra de d\u00favidas \u00e9 uma \u00e1rea super interessante, mas os desafios s\u00e3o enormes. O sistema est\u00e1 crescendo desenfreadamente e os livros e fontes de estudo n\u00e3o est\u00e3o conseguindo acompanhar essa evolu\u00e7\u00e3o. Al\u00e9m disso, a documenta\u00e7\u00e3o na parte do sistema \u00e9 muito superficial, ao contr\u00e1rio da parte de desenvolvimento de aplica\u00e7\u00f5es ( documenta\u00e7\u00e3o ) que tamb\u00e9m possuem v\u00e1rios cursos pela Internet. Dispositivo usado [Em breve] Antes de Come\u00e7ar [Em breve] Instalando Depend\u00eancias Instalando o Repo []","title":"Boot.img"},{"location":"Android/boot.img/#bootimg","text":"Image by dexmac from Pixabay","title":"Boot.img"},{"location":"Android/boot.img/#introducao","text":"A algum tempo venho tentando desbravar o mundo do Android embarcado. Sem sombra de d\u00favidas \u00e9 uma \u00e1rea super interessante, mas os desafios s\u00e3o enormes. O sistema est\u00e1 crescendo desenfreadamente e os livros e fontes de estudo n\u00e3o est\u00e3o conseguindo acompanhar essa evolu\u00e7\u00e3o. Al\u00e9m disso, a documenta\u00e7\u00e3o na parte do sistema \u00e9 muito superficial, ao contr\u00e1rio da parte de desenvolvimento de aplica\u00e7\u00f5es ( documenta\u00e7\u00e3o ) que tamb\u00e9m possuem v\u00e1rios cursos pela Internet.","title":"Introdu\u00e7\u00e3o"},{"location":"Android/boot.img/#dispositivo-usado","text":"[Em breve]","title":"Dispositivo usado"},{"location":"Android/boot.img/#antes-de-comecar","text":"[Em breve] Instalando Depend\u00eancias Instalando o Repo []","title":"Antes de Come\u00e7ar"},{"location":"Bootloader/VIM3/u-boot/","text":"U-boot na VIM3 (SD Card) U-boot logo baseado no tutorial do pr\u00f3prio u-boot no readthedocs Organizando a estrutura de pastas Ser\u00e3o necess\u00e1rios v\u00e1rios arquivos e pastas durante esse post. Devido isso, iremos usar a seguinte estrutura de pastas . \u251c\u2500\u2500 fip \u251c\u2500\u2500 toolchain \u251c\u2500\u2500 u-boot-mainline \u2514\u2500\u2500 u-boot-vim3 Elas ser\u00e3o criadas ao longo deste post. Baixando o u-boot Mainline O u-boot possui um reposit\u00f3rio no github. Vamos baixa-lo dentro da pasta u-boot-mainline : git clone https://github.com/u-boot/u-boot.git u-boot-mainline Para fazer o cross compile \u00e9 necess\u00e1rio baixar as toolchain . As vers\u00f5es novas do u-boot precisam de vers\u00f5es novas de toolchain , que podem ser encontradas no site da ARM . Nesse post estou usando a vers\u00e3o gcc-arm-10.3-2021.07 (meu link de backup). Compilando o u-boot mainline Uma vez baixado a toolchain ( gcc-arm-10.3-2021.07 ), vamos criar a pasta toolchain e mover a toolchain baixada para dentro dela. Agora, precisamos descompactar a toochain e adicionar os bin\u00e1rios ao path do sistema. Para isso export PATH=CAMINHO_ABSOLUTO/toolchain/gcc-arm-10.3-2021.07-x86_64-aarch64-none-elf/bin:$PATH Observe que a pasta /bin est\u00e1 sendo adicionada ao path . Nela est\u00e3o os execut\u00e1veis que ser\u00e3o utilizados durante o processo de build. Volte para a pasta do u-boot-mainline e execute os seguintes comandos: make khadas-vim3_defconfig O = out/ make CROSS_COMPILE = aarch64-none-elf- O = out/ O par\u00e2metro O define a pasta onde os arquivos compilados ser\u00e3o salvos. O argumento CROSS_COMPILE=aarch64-none-elf- informa qual toolchain ser\u00e1 utilizada no momento da compila\u00e7\u00e3o, essa toolchain precisa estar no path do sistema (como fizemos anteriormente). Dentro os v\u00e1rios compiladores dispon\u00edveis, podemos ver que existem alguns bem conhecidos: c++ , cpp , g++ e muitos outros. toolchain/gcc-arm-10.3-2021.07-x86_64-aarch64-none-elf/bin \u251c\u2500\u2500 aarch64-none-elf-addr2line \u251c\u2500\u2500 aarch64-none-elf-ar \u251c\u2500\u2500 aarch64-none-elf-as \u251c\u2500\u2500 aarch64-none-elf-c++ \u251c\u2500\u2500 aarch64-none-elf-c++filt \u251c\u2500\u2500 aarch64-none-elf-cpp \u251c\u2500\u2500 aarch64-none-elf-elfedit \u251c\u2500\u2500 aarch64-none-elf-g++ ... Se tudo ocorrer como o esperado, uma mensagem similar a essa: aarch64-none-elf-ld.bfd: warning: -z norelro ignored OBJCOPY lib/efi_loader/initrddump.efi LD u-boot OBJCOPY u-boot.srec OBJCOPY u-boot-nodtb.bin RELOC u-boot-nodtb.bin CAT u-boot-dtb.bin COPY u-boot.bin SYM u-boot.sym LD u-boot.elf make[1]: Leaving directory 'CAMINHO_ABSOLUTO/u-boot-mainline/out' O arquivo u-boot.bin deve ter sido gerado dentro da pasta out . Baixando u-boot VIM3 A Khadas tamb\u00e9m possui um reposit\u00f3rio com as vers\u00f5es do u-boot para as diversas placas que eles produzem. Vamos baixar o brach khadas-vims-v2015.01 dentro da pasta u-boot-vim3 git clone https://github.com/khadas/u-boot.git -b khadas-vims-v2015.01 u-boot-vim3 Para fazer o cross compile \u00e9 necess\u00e1rio baixar as toolchain . Seguindo o tutorial base , precisaremos de 2 toolchain ( none-elf e none-eabi ): gcc-linaro-aarch64-none-elf-4.8-2013.11 - Linaro gcc-linaro-aarch64-none-elf-4.8-2013.11 (backup). gcc-linaro-arm-none-eabi-4.8-2013.11 - Linaro gcc-linaro-arm-none-eabi-4.8-2013.11 (backup). Compilando o u-boot VIM3 Antes de adicionar as novas toolchain ao path , limpe o terminal (abra um novo terminal). A vers\u00e3o utilizada no u-boot-mainline n\u00e3o \u00e9 compat\u00edvel com a vers\u00e3o da VIM3 Com as 2 toolchain baixadas, mova-as para a pastas toolchain e descompacte cada uma em sua respectiva pasta. Por fim, adicionar os bin\u00e1rios dos 2 toolchain ao path do sistema export PATH=CAMINHO_ABSOLUTO/toolchain/gcc-linaro-aarch64-none-elf-4.8-2013.11_linux/bin:$PATH export PATH=CAMINHO_ABSOLUTO/toolchain/gcc-linaro-arm-none-eabi-4.8-2013.11_linux/bin:$PATH Com os caminhos adicionados, podemos compilar o u-boot-vim3: make kvim3_defconfig O = out/ make CROSS_COMPILE = aarch64-none-elf- O = out/ O par\u00e2metro O define a pasta onde os arquivos compilados ser\u00e3o salvos. Se tudo ocorrer bem, uma mensagem similar deve aparecer: LD CAMINHO_ABSOLUTO/u-boot-vim3/out/board/khadas/kvim3/firmware/acs.elf OD CAMINHO_ABSOLUTO/u-boot-vim3/out/board/khadas/kvim3/firmware/acs.dump BIN CAMINHO_ABSOLUTO/u-boot-vim3/out/board/khadas/kvim3/firmware/acs.bin Built CAMINHO_ABSOLUTO/u-boot-vim3/out/board/khadas/kvim3/firmware/acs.bin successfully CPP task_entry.s CPP user_task.lds CC task_entry.o CC user_task.o CPP misc.s CC misc.o CC uart.o CC suspend.o CC lib/string.o CC lib/delay.o LD CAMINHO_ABSOLUTO/u-boot-vim3/out/scp_task/bl301.out OBJDUMP CAMINHO_ABSOLUTO/u-boot-vim3/out/scp_task/bl301.dis OBJCOPY CAMINHO_ABSOLUTO/u-boot-vim3/out/scp_task/bl301.bin Juntando tudo O primeiro passo \u00e9 criar a pasta fip . Segundo, \u00e9 preciso baixar esse script da BayLibre ou no meu backup e mover para dentro da pasta fip Para mais informa\u00e7\u00f5es sobre o que \u00e9, acesse: FIP + compilados Terceiro, \u00e9 preciso copiar v\u00e1rios arquivos para dentro da pasta fip : # Arquivos compilados no u-boot-VIM3 cp u-boot-vim3/out/scp_task/bl301.bin fip cp u-boot-vim3/out/board/khadas/kvim3/firmware/acs.bin fip # Copia o u-boot.bin (mainline) e renomeia para bl33.bin cp u-boot-mainline/out/u-boot.bin fip/bl33.bin # Arquivos pr\u00e9-compilados (s\u00e3o fornecidos pela khadas) cp u-boot-vim3/fip/g12b/bl2.bin fip cp u-boot-vim3/fip/g12b/bl30.bin fip cp u-boot-vim3/fip/g12b/bl31.bin fip cp u-boot-vim3/fip/g12b/ddr3_1d.fw fip cp u-boot-vim3/fip/g12b/ddr4_1d.fw fip cp u-boot-vim3/fip/g12b/ddr4_2d.fw fip cp u-boot-vim3/fip/g12b/diag_lpddr4.fw fip cp u-boot-vim3/fip/g12b/lpddr3_1d.fw fip cp u-boot-vim3/fip/g12b/lpddr4_1d.fw fip cp u-boot-vim3/fip/g12b/lpddr4_2d.fw fip cp u-boot-vim3/fip/g12b/piei.fw fip cp u-boot-vim3/fip/g12b/aml_ddr.fw fip cp u-boot-vim3/fip/g12b/aml_encrypt_g12b fip Concatenando os arquivos Pra concatenar as informa\u00e7\u00f5es, vamos utilizar o script da baylibre (dentro da pasta fip ) # Adiciona um padding no bl30.bin e bl301.bin # depois concatena os dois, gerando bl30_new.bin bash blx_fix_g12a.sh bl30.bin zero_tmp bl30_zero.bin bl301.bin bl301_zero.bin bl30_new.bin bl30 # Adiciona um padding no bl2.bin e acs.bin # depois concatena os dois, gerando bl2_new.bin bash blx_fix_g12a.sh bl2.bin zero_tmp bl2_zero.bin acs.bin bl21_zero.bin bl2_new.bin bl2 Encriptando os arquivos Para mais informa\u00e7\u00f5es, acesse: link # Adiciona assinatura no cabe\u00e7alho do bin\u00e1rio ./aml_encrypt_g12b --bl2sig --input bl2_new.bin --output bl2.n.bin.sig # Adiciona assinatura no cabe\u00e7alho do bin\u00e1rio ./aml_encrypt_g12b --bl3sig --input bl31.bin --output bl31.img.enc --level v3 --type bl3 # Adiciona e encripta a assinatura no cabe\u00e7alho do bin\u00e1rio ./aml_encrypt_g12b --bl30sig --input bl30_new.bin --output bl30_new.bin.g12a.enc --level v3 ./aml_encrypt_g12b --bl3sig --input bl30_new.bin.g12a.enc --output bl30_new.bin.enc --level v3 --type bl301 # Adiciona a assinatura no cabe\u00e7alho, um padding no final do bin\u00e1rio e comprime o bin\u00e1rio ./aml_encrypt_g12b --bl3sig --input bl33.bin --compress lz4 --output bl33.bin.enc --level v3 --type bl33 --compress lz4 # Gera o bin\u00e1rio do u-boot com as assinaturas concatenadas ./aml_encrypt_g12b --bootmk --output u-boot-bin --bl2 bl2.n.bin.sig --bl30 bl30_new.bin.enc --bl31 bl31.img.enc \\ --bl33 bl33.bin.enc --ddrfw1 ddr4_1d.fw --ddrfw2 ddr4_2d.fw \\ --ddrfw3 ddr3_1d.fw --ddrfw4 piei.fw --ddrfw5 lpddr4_1d.fw \\ --ddrfw6 lpddr4_2d.fw --ddrfw7 diag_lpddr4.fw --ddrfw8 aml_ddr.fw \\ --ddrfw9 lpddr3_1d.fw --level v3 Passando o u-boot para o SD Card $ DEV=/dev/your_sd_device $ dd if=fip/u-boot.bin.sd.bin of=$DEV conv=fsync,notrunc bs=512 skip=1 seek=1 $ dd if=fip/u-boot.bin.sd.bin of=$DEV conv=fsync,notrunc bs=1 count=444","title":"U-boot na VIM3 (SD Card)"},{"location":"Bootloader/VIM3/u-boot/#u-boot-na-vim3-sd-card","text":"U-boot logo baseado no tutorial do pr\u00f3prio u-boot no readthedocs","title":"U-boot na VIM3 (SD Card)"},{"location":"Bootloader/VIM3/u-boot/#organizando-a-estrutura-de-pastas","text":"Ser\u00e3o necess\u00e1rios v\u00e1rios arquivos e pastas durante esse post. Devido isso, iremos usar a seguinte estrutura de pastas . \u251c\u2500\u2500 fip \u251c\u2500\u2500 toolchain \u251c\u2500\u2500 u-boot-mainline \u2514\u2500\u2500 u-boot-vim3 Elas ser\u00e3o criadas ao longo deste post.","title":"Organizando a estrutura de pastas"},{"location":"Bootloader/VIM3/u-boot/#baixando-o-u-boot-mainline","text":"O u-boot possui um reposit\u00f3rio no github. Vamos baixa-lo dentro da pasta u-boot-mainline : git clone https://github.com/u-boot/u-boot.git u-boot-mainline Para fazer o cross compile \u00e9 necess\u00e1rio baixar as toolchain . As vers\u00f5es novas do u-boot precisam de vers\u00f5es novas de toolchain , que podem ser encontradas no site da ARM . Nesse post estou usando a vers\u00e3o gcc-arm-10.3-2021.07 (meu link de backup).","title":"Baixando o u-boot Mainline"},{"location":"Bootloader/VIM3/u-boot/#compilando-o-u-boot-mainline","text":"Uma vez baixado a toolchain ( gcc-arm-10.3-2021.07 ), vamos criar a pasta toolchain e mover a toolchain baixada para dentro dela. Agora, precisamos descompactar a toochain e adicionar os bin\u00e1rios ao path do sistema. Para isso export PATH=CAMINHO_ABSOLUTO/toolchain/gcc-arm-10.3-2021.07-x86_64-aarch64-none-elf/bin:$PATH Observe que a pasta /bin est\u00e1 sendo adicionada ao path . Nela est\u00e3o os execut\u00e1veis que ser\u00e3o utilizados durante o processo de build. Volte para a pasta do u-boot-mainline e execute os seguintes comandos: make khadas-vim3_defconfig O = out/ make CROSS_COMPILE = aarch64-none-elf- O = out/ O par\u00e2metro O define a pasta onde os arquivos compilados ser\u00e3o salvos. O argumento CROSS_COMPILE=aarch64-none-elf- informa qual toolchain ser\u00e1 utilizada no momento da compila\u00e7\u00e3o, essa toolchain precisa estar no path do sistema (como fizemos anteriormente). Dentro os v\u00e1rios compiladores dispon\u00edveis, podemos ver que existem alguns bem conhecidos: c++ , cpp , g++ e muitos outros. toolchain/gcc-arm-10.3-2021.07-x86_64-aarch64-none-elf/bin \u251c\u2500\u2500 aarch64-none-elf-addr2line \u251c\u2500\u2500 aarch64-none-elf-ar \u251c\u2500\u2500 aarch64-none-elf-as \u251c\u2500\u2500 aarch64-none-elf-c++ \u251c\u2500\u2500 aarch64-none-elf-c++filt \u251c\u2500\u2500 aarch64-none-elf-cpp \u251c\u2500\u2500 aarch64-none-elf-elfedit \u251c\u2500\u2500 aarch64-none-elf-g++ ... Se tudo ocorrer como o esperado, uma mensagem similar a essa: aarch64-none-elf-ld.bfd: warning: -z norelro ignored OBJCOPY lib/efi_loader/initrddump.efi LD u-boot OBJCOPY u-boot.srec OBJCOPY u-boot-nodtb.bin RELOC u-boot-nodtb.bin CAT u-boot-dtb.bin COPY u-boot.bin SYM u-boot.sym LD u-boot.elf make[1]: Leaving directory 'CAMINHO_ABSOLUTO/u-boot-mainline/out' O arquivo u-boot.bin deve ter sido gerado dentro da pasta out .","title":"Compilando o u-boot mainline"},{"location":"Bootloader/VIM3/u-boot/#baixando-u-boot-vim3","text":"A Khadas tamb\u00e9m possui um reposit\u00f3rio com as vers\u00f5es do u-boot para as diversas placas que eles produzem. Vamos baixar o brach khadas-vims-v2015.01 dentro da pasta u-boot-vim3 git clone https://github.com/khadas/u-boot.git -b khadas-vims-v2015.01 u-boot-vim3 Para fazer o cross compile \u00e9 necess\u00e1rio baixar as toolchain . Seguindo o tutorial base , precisaremos de 2 toolchain ( none-elf e none-eabi ): gcc-linaro-aarch64-none-elf-4.8-2013.11 - Linaro gcc-linaro-aarch64-none-elf-4.8-2013.11 (backup). gcc-linaro-arm-none-eabi-4.8-2013.11 - Linaro gcc-linaro-arm-none-eabi-4.8-2013.11 (backup).","title":"Baixando u-boot VIM3"},{"location":"Bootloader/VIM3/u-boot/#compilando-o-u-boot-vim3","text":"Antes de adicionar as novas toolchain ao path , limpe o terminal (abra um novo terminal). A vers\u00e3o utilizada no u-boot-mainline n\u00e3o \u00e9 compat\u00edvel com a vers\u00e3o da VIM3 Com as 2 toolchain baixadas, mova-as para a pastas toolchain e descompacte cada uma em sua respectiva pasta. Por fim, adicionar os bin\u00e1rios dos 2 toolchain ao path do sistema export PATH=CAMINHO_ABSOLUTO/toolchain/gcc-linaro-aarch64-none-elf-4.8-2013.11_linux/bin:$PATH export PATH=CAMINHO_ABSOLUTO/toolchain/gcc-linaro-arm-none-eabi-4.8-2013.11_linux/bin:$PATH Com os caminhos adicionados, podemos compilar o u-boot-vim3: make kvim3_defconfig O = out/ make CROSS_COMPILE = aarch64-none-elf- O = out/ O par\u00e2metro O define a pasta onde os arquivos compilados ser\u00e3o salvos. Se tudo ocorrer bem, uma mensagem similar deve aparecer: LD CAMINHO_ABSOLUTO/u-boot-vim3/out/board/khadas/kvim3/firmware/acs.elf OD CAMINHO_ABSOLUTO/u-boot-vim3/out/board/khadas/kvim3/firmware/acs.dump BIN CAMINHO_ABSOLUTO/u-boot-vim3/out/board/khadas/kvim3/firmware/acs.bin Built CAMINHO_ABSOLUTO/u-boot-vim3/out/board/khadas/kvim3/firmware/acs.bin successfully CPP task_entry.s CPP user_task.lds CC task_entry.o CC user_task.o CPP misc.s CC misc.o CC uart.o CC suspend.o CC lib/string.o CC lib/delay.o LD CAMINHO_ABSOLUTO/u-boot-vim3/out/scp_task/bl301.out OBJDUMP CAMINHO_ABSOLUTO/u-boot-vim3/out/scp_task/bl301.dis OBJCOPY CAMINHO_ABSOLUTO/u-boot-vim3/out/scp_task/bl301.bin","title":"Compilando o u-boot VIM3"},{"location":"Bootloader/VIM3/u-boot/#juntando-tudo","text":"O primeiro passo \u00e9 criar a pasta fip . Segundo, \u00e9 preciso baixar esse script da BayLibre ou no meu backup e mover para dentro da pasta fip Para mais informa\u00e7\u00f5es sobre o que \u00e9, acesse: FIP + compilados Terceiro, \u00e9 preciso copiar v\u00e1rios arquivos para dentro da pasta fip : # Arquivos compilados no u-boot-VIM3 cp u-boot-vim3/out/scp_task/bl301.bin fip cp u-boot-vim3/out/board/khadas/kvim3/firmware/acs.bin fip # Copia o u-boot.bin (mainline) e renomeia para bl33.bin cp u-boot-mainline/out/u-boot.bin fip/bl33.bin # Arquivos pr\u00e9-compilados (s\u00e3o fornecidos pela khadas) cp u-boot-vim3/fip/g12b/bl2.bin fip cp u-boot-vim3/fip/g12b/bl30.bin fip cp u-boot-vim3/fip/g12b/bl31.bin fip cp u-boot-vim3/fip/g12b/ddr3_1d.fw fip cp u-boot-vim3/fip/g12b/ddr4_1d.fw fip cp u-boot-vim3/fip/g12b/ddr4_2d.fw fip cp u-boot-vim3/fip/g12b/diag_lpddr4.fw fip cp u-boot-vim3/fip/g12b/lpddr3_1d.fw fip cp u-boot-vim3/fip/g12b/lpddr4_1d.fw fip cp u-boot-vim3/fip/g12b/lpddr4_2d.fw fip cp u-boot-vim3/fip/g12b/piei.fw fip cp u-boot-vim3/fip/g12b/aml_ddr.fw fip cp u-boot-vim3/fip/g12b/aml_encrypt_g12b fip","title":"Juntando tudo"},{"location":"Bootloader/VIM3/u-boot/#concatenando-os-arquivos","text":"Pra concatenar as informa\u00e7\u00f5es, vamos utilizar o script da baylibre (dentro da pasta fip ) # Adiciona um padding no bl30.bin e bl301.bin # depois concatena os dois, gerando bl30_new.bin bash blx_fix_g12a.sh bl30.bin zero_tmp bl30_zero.bin bl301.bin bl301_zero.bin bl30_new.bin bl30 # Adiciona um padding no bl2.bin e acs.bin # depois concatena os dois, gerando bl2_new.bin bash blx_fix_g12a.sh bl2.bin zero_tmp bl2_zero.bin acs.bin bl21_zero.bin bl2_new.bin bl2","title":"Concatenando os arquivos"},{"location":"Bootloader/VIM3/u-boot/#encriptando-os-arquivos","text":"Para mais informa\u00e7\u00f5es, acesse: link # Adiciona assinatura no cabe\u00e7alho do bin\u00e1rio ./aml_encrypt_g12b --bl2sig --input bl2_new.bin --output bl2.n.bin.sig # Adiciona assinatura no cabe\u00e7alho do bin\u00e1rio ./aml_encrypt_g12b --bl3sig --input bl31.bin --output bl31.img.enc --level v3 --type bl3 # Adiciona e encripta a assinatura no cabe\u00e7alho do bin\u00e1rio ./aml_encrypt_g12b --bl30sig --input bl30_new.bin --output bl30_new.bin.g12a.enc --level v3 ./aml_encrypt_g12b --bl3sig --input bl30_new.bin.g12a.enc --output bl30_new.bin.enc --level v3 --type bl301 # Adiciona a assinatura no cabe\u00e7alho, um padding no final do bin\u00e1rio e comprime o bin\u00e1rio ./aml_encrypt_g12b --bl3sig --input bl33.bin --compress lz4 --output bl33.bin.enc --level v3 --type bl33 --compress lz4 # Gera o bin\u00e1rio do u-boot com as assinaturas concatenadas ./aml_encrypt_g12b --bootmk --output u-boot-bin --bl2 bl2.n.bin.sig --bl30 bl30_new.bin.enc --bl31 bl31.img.enc \\ --bl33 bl33.bin.enc --ddrfw1 ddr4_1d.fw --ddrfw2 ddr4_2d.fw \\ --ddrfw3 ddr3_1d.fw --ddrfw4 piei.fw --ddrfw5 lpddr4_1d.fw \\ --ddrfw6 lpddr4_2d.fw --ddrfw7 diag_lpddr4.fw --ddrfw8 aml_ddr.fw \\ --ddrfw9 lpddr3_1d.fw --level v3","title":"Encriptando os arquivos"},{"location":"Bootloader/VIM3/u-boot/#passando-o-u-boot-para-o-sd-card","text":"$ DEV=/dev/your_sd_device $ dd if=fip/u-boot.bin.sd.bin of=$DEV conv=fsync,notrunc bs=512 skip=1 seek=1 $ dd if=fip/u-boot.bin.sd.bin of=$DEV conv=fsync,notrunc bs=1 count=444","title":"Passando o u-boot para o SD Card"},{"location":"Bootloader/qemu/U-boot_qemu/","text":"U-boot no QEMU Image by PublicDomainPictures from Pixabay Introdu\u00e7\u00e3o A fim de ter um ambiente de testes para aprender sobre o U-Boot, o mais recomendado \u00e9 criar um ambiente virtual. Para isso, eu escolhi o QEMU, que \u00e9 altamente configur\u00e1vel. Essa postagem tem como base a arquitetura aarch64 , devido sua larga utiliza\u00e7\u00e3o em sistemas embarcados. Baixando o U-Boot mainline Basta copiar e colar o c\u00f3digo abaixo: git clone https://source.denx.de/u-boot/u-boot.git Buildando o U-boot A seguir s\u00e3o definidos alguns passos para gerar o bin\u00e1rio do U-boot, que ser\u00e1 utilizado pelo QEMU. Instalando Depend\u00eancias Dependendo do sistema utilizado, alguns pacotes ser\u00e3o necess\u00e1rios para que o processo de build tenha sucesso. No meu ambiente ( ubuntu 22.04 ), foram necess\u00e1rio os seguintes pacotes: sudo apt install \\ flex \\ bison \\ gcc-aarch64-linux-gnu \\ Definindo a Arquitetura Para criar um sistema de build limpo, o par\u00e2metro O= foi utilizado. Dentro da pasta do U-Boot, cole o c\u00f3digo abaixo: make O=../out qemu_arm64_defconfig -j16 Se tudo ocorrer bem, a mensagem a seguir deve aparecer: Uma pasta out foi criada, adicionando todos os itens necess\u00e1rios para a build. Gerando o Bin\u00e1rio Dentro da pasta out , cole o c\u00f3digo abaixo: make CROSS_COMPILE=aarch64-linux-gnu- -j16 Se tudo ocorrer corretamente o arquivo u-boot.bin ser\u00e1 criado. Carregando o U-boot com QEMU Para utilizar o QEMU para arquiteturas ARM64 \u00e9 necess\u00e1rio instalar o pacote: sudo apt install qemu-system-arm Dentro da pasta out , execute o seguinte comando: qemu-system-aarch64 -M virt -nographic -cpu cortex-a57 -bios u-boot.bin onde o par\u00e2metro -bios \u00e9 o binario que acabou de ser criado pela nossa build. Ap\u00f3s executar o comando, o u-boot dever\u00e1 iniciar normalmente:","title":"U-boot no QEMU"},{"location":"Bootloader/qemu/U-boot_qemu/#u-boot-no-qemu","text":"Image by PublicDomainPictures from Pixabay","title":"U-boot no QEMU"},{"location":"Bootloader/qemu/U-boot_qemu/#introducao","text":"A fim de ter um ambiente de testes para aprender sobre o U-Boot, o mais recomendado \u00e9 criar um ambiente virtual. Para isso, eu escolhi o QEMU, que \u00e9 altamente configur\u00e1vel. Essa postagem tem como base a arquitetura aarch64 , devido sua larga utiliza\u00e7\u00e3o em sistemas embarcados.","title":"Introdu\u00e7\u00e3o"},{"location":"Bootloader/qemu/U-boot_qemu/#baixando-o-u-boot-mainline","text":"Basta copiar e colar o c\u00f3digo abaixo: git clone https://source.denx.de/u-boot/u-boot.git","title":"Baixando o U-Boot mainline"},{"location":"Bootloader/qemu/U-boot_qemu/#buildando-o-u-boot","text":"A seguir s\u00e3o definidos alguns passos para gerar o bin\u00e1rio do U-boot, que ser\u00e1 utilizado pelo QEMU.","title":"Buildando o U-boot"},{"location":"Bootloader/qemu/U-boot_qemu/#instalando-dependencias","text":"Dependendo do sistema utilizado, alguns pacotes ser\u00e3o necess\u00e1rios para que o processo de build tenha sucesso. No meu ambiente ( ubuntu 22.04 ), foram necess\u00e1rio os seguintes pacotes: sudo apt install \\ flex \\ bison \\ gcc-aarch64-linux-gnu \\","title":"Instalando Depend\u00eancias"},{"location":"Bootloader/qemu/U-boot_qemu/#definindo-a-arquitetura","text":"Para criar um sistema de build limpo, o par\u00e2metro O= foi utilizado. Dentro da pasta do U-Boot, cole o c\u00f3digo abaixo: make O=../out qemu_arm64_defconfig -j16 Se tudo ocorrer bem, a mensagem a seguir deve aparecer: Uma pasta out foi criada, adicionando todos os itens necess\u00e1rios para a build.","title":"Definindo a Arquitetura"},{"location":"Bootloader/qemu/U-boot_qemu/#gerando-o-binario","text":"Dentro da pasta out , cole o c\u00f3digo abaixo: make CROSS_COMPILE=aarch64-linux-gnu- -j16 Se tudo ocorrer corretamente o arquivo u-boot.bin ser\u00e1 criado.","title":"Gerando o Bin\u00e1rio"},{"location":"Bootloader/qemu/U-boot_qemu/#carregando-o-u-boot-com-qemu","text":"Para utilizar o QEMU para arquiteturas ARM64 \u00e9 necess\u00e1rio instalar o pacote: sudo apt install qemu-system-arm Dentro da pasta out , execute o seguinte comando: qemu-system-aarch64 -M virt -nographic -cpu cortex-a57 -bios u-boot.bin onde o par\u00e2metro -bios \u00e9 o binario que acabou de ser criado pela nossa build. Ap\u00f3s executar o comando, o u-boot dever\u00e1 iniciar normalmente:","title":"Carregando o U-boot com QEMU"},{"location":"Documenta%C3%A7%C3%A3o/Parti%C3%A7%C3%B5es/GPT/","text":"Tabela de Parti\u00e7\u00e3o GUID baseado nos link1 , link2 e link3 Considera\u00e7\u00f5es iniciais Vamos utilizar um cart\u00e3o micro SD de 32GB. Para identificarmos o cart\u00e3o no sistema, utilizamos o comando lsblk , o resultado ser\u00e1 similar a essa \u2570\u2500 lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT sda 8 :0 0 894 ,3G 0 disk \u2514\u2500sda1 8 :1 0 894 ,3G 0 part /run/timeshift/backup sdc 8 :32 1 29 ,1G 0 disk \u2514\u2500sdc1 8 :33 1 29 ,1G 0 part nvme0n1 259 :0 0 465 ,8G 0 disk \u251c\u2500nvme0n1p1 259 :1 0 476M 0 part /boot/efi \u251c\u2500nvme0n1p2 259 :2 0 30 ,5G 0 part [ SWAP ] \u2514\u2500nvme0n1p3 259 :3 0 434 ,8G 0 part / Para ter certeza qual \u00e9 o cart\u00e3o SD, execute o lsblk com o cart\u00e3o n\u00e3o conectado e depois conecte o cart\u00e3o e execute o comando novamente (simples ). No caso acima, o cart\u00e3o SD \u00e9 o /dev/sdc . Para facilitar a visualiza\u00e7\u00e3o das altera\u00e7\u00f5es que iremos fazer, vamos zerar os primeiros 10240 bytes do cart\u00e3o. Para isso, utilizaremos o comando dd sudo dd if = /dev/zero of = /dev/sdc bs = 1024 count = 10 Podemos visualizar conte\u00fado do cart\u00e3o, com o comando hexdump sudo hexdump -C /dev/sdc -n 10240 O resultado deve ser similar a esse 00000000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | ................ | * 00002800 o n\u00famero 00002800 \u00e9 em hexadecimal e seu equivalente em decimal \u00e9 10240 (ou 10 kB). Formatando o cart\u00e3o com GPT Com os primeiros bytes do cart\u00e3o SD zerados, vamos adicionar a parti\u00e7\u00e3o GPT ao cart\u00e3o com o comando fdisk sudo fdisk /dev/sdc Um menu ir\u00e1 aparecer: Digite g Depois digite n Partition number (1-128, default 1): Enter First sector (2048-61067230, default 2048): Enter Last sector, +/-sectors or +/-size{K,M,G,T,P} (2048-61067230, default 61067230): Enter Por fim, digite w Agora o cart\u00e3o est\u00e1 com o particionamento GPT. Para checar, vamos visualizar novamente o conte\u00fado do cart\u00e3o SD 00000000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | ................ | * 000001c0 02 00 ee ff ff ff 01 00 00 00 ff cf a3 03 00 00 | ................ | 000001d0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | ................ | * 000001f0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 55 aa | ..............U. | 00000200 45 46 49 20 50 41 52 54 00 00 01 00 5c 00 00 00 | EFI PART.... \\. .. | 00000210 fc d8 3a 53 00 00 00 00 01 00 00 00 00 00 00 00 | ..:S............ | 00000220 ff cf a3 03 00 00 00 00 00 08 00 00 00 00 00 00 | ................ | 00000230 de cf a3 03 00 00 00 00 90 30 7b d4 f3 72 46 59 | .........0 { ..rFY | 00000240 89 2c 7f 77 9e b0 00 e6 02 00 00 00 00 00 00 00 | .,.w............ | 00000250 80 00 00 00 80 00 00 00 f1 ae 2f f5 00 00 00 00 | ........../..... | 00000260 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | ................ | * 00000400 af 3d c6 0f 83 84 72 47 8e 79 3d 69 d8 47 7d e4 | . = ....rG.y = i.G } . | 00000410 9c 58 84 76 3e 65 45 92 a4 ec 96 ed 84 df 22 99 | .X.v>eE....... \".| 00000420 00 08 00 00 00 00 00 00 de cf a3 03 00 00 00 00 |................| 00000430 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 00002800 Esses dados mostram que o GPT est\u00e1 sendo usando no cart\u00e3o SD. O Backup de seguran\u00e7a Como uma forma de seguran\u00e7a contra perda de dados, o GPT faz um backup da parti\u00e7\u00e3o no final disco. Para checar basta utilizar o comando: sudo tail -c 10M /dev/sdc | hexdump -C Visualizando os \u00faltimos 10 MB do cart\u00e3o SD, encontramos o seguinte conte\u00fado 747900000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | ................ | * 7479fbe00 af 3d c6 0f 83 84 72 47 8e 79 3d 69 d8 47 7d e4 | . = ....rG.y = i.G } . | 7479fbe10 9c 58 84 76 3e 65 45 92 a4 ec 96 ed 84 df 22 99 | .X.v>eE....... \".| 7479fbe20 00 08 00 00 00 00 00 00 de cf a3 03 00 00 00 00 |................| 7479fbe30 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 7479ffe00 45 46 49 20 50 41 52 54 00 00 01 00 5c 00 00 00 |EFI PART....\\...| 7479ffe10 66 9b 01 67 00 00 00 00 ff cf a3 03 00 00 00 00 |f..g............| 7479ffe20 01 00 00 00 00 00 00 00 00 08 00 00 00 00 00 00 |................| 7479ffe30 de cf a3 03 00 00 00 00 90 30 7b d4 f3 72 46 59 |.........0{..rFY| 7479ffe40 89 2c 7f 77 9e b0 00 e6 df cf a3 03 00 00 00 00 |.,.w............| 7479ffe50 80 00 00 00 80 00 00 00 f1 ae 2f f5 00 00 00 00 |........../.....| 7479ffe60 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 747a00000 Podemos perceber um espelho dos dados do inicio do disco. O Logical Block Addressing O Logical Block Addressing ou LBA, s\u00e3o blocos de informa\u00e7\u00e3o utilizado pelo GPT. Esses blocos possuem 512 bytes. LBA0 O LBA0 existe para compatibilidade com o Master Boot Record (MBR), checando os primeiros 512 bytes do cart\u00e3o SD sudo hexdump -C /dev/sdc -s 0 -n 512 Temos esse resultado: 00000000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 000001c0 02 00 ee ff ff ff 01 00 00 00 ff cf a3 03 00 00 |................| 000001d0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 000001f0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 55 aa |..............U.| 00000200 Nada relevante pode ser visto aqui (a n\u00e3o ser que voc\u00ea esteja usando MBR ) LBA1 Esse LBA possui o cabe\u00e7alho da tabela de parti\u00e7\u00e3o. Visualizando os pr\u00f3ximos 512 bytes do cart\u00e3o SD sudo hexdump -C /dev/sdc -s 512 -n 512 Temos os seguintes dados: 00000200 45 46 49 20 50 41 52 54 00 00 01 00 5c 00 00 00 |EFI PART....\\...| 00000210 d2 61 e7 36 00 00 00 00 01 00 00 00 00 00 00 00 |.a.6............| 00000220 ff cf a3 03 00 00 00 00 00 08 00 00 00 00 00 00 |................| 00000230 de cf a3 03 00 00 00 00 46 8a 0b 22 c3 8c 45 75 |........F..\"..Eu| 00000240 8c ef f5 bd 9e 32 4c 5b 02 00 00 00 00 00 00 00 |.....2L[........| 00000250 80 00 00 00 80 00 00 00 af 06 c5 b4 00 00 00 00 |................| 00000260 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 00000400 Agora vamos entender esse vetor de bytes: Esses dados s\u00e3o Little Endian . Para interpretarmos o valor em decimal, devemos converter para Big Endian A assinatura s\u00e3o os primeiros 8 bytes 00000200 45 46 49 20 50 41 52 54 |EFI PART| 00000208 A revis\u00e3o s\u00e3o os 4 pr\u00f3ximos bytes 00000208 00 00 01 00 |....| 0000020c O tamanho do cabe\u00e7alho s\u00e3o os 4 pr\u00f3ximos bytes 0000020c 5c 00 00 00 |\\...| 00000210 O CRC32 da parti\u00e7\u00e3o s\u00e3o os 4 pr\u00f3ximos bytes 00000210 d2 61 e7 36 |.a.6| 00000214 Os pr\u00f3ximos 4 bytes s\u00e3o reservados e devem ser 0's 00000214 00 00 00 00 |....| 00000218 Endere\u00e7o do LBA atual s\u00e3o os 8 pr\u00f3ximos bytes 00000218 01 00 00 00 00 00 00 00 |........| 00000220 Localiza\u00e7\u00e3o do LBA espelho (backup) s\u00e3o os 8 pr\u00f3ximos bytes 00000220 ff cf a3 03 00 00 00 00 |........| 00000228 Big Endian: 00 00 00 00 03 A3 CF FF | Decimal 61067263. Isso indica que o LBA espelho est\u00e1 no setor 61067263. Para acessa-lo podemos utilizar o comando: sudo dd if=/dev/sdc bs=512 count=1 skip=61067263 Primeiro setor dispon\u00edvel para parti\u00e7\u00e3o s\u00e3o os pr\u00f3ximos 8 bytes 00000228 00 08 00 00 00 00 00 00 |........| 00000230 00 00 08 00 00 00 00 00 -> 2048 \u00daltimo setor dispon\u00edvel para parti\u00e7\u00e3o s\u00e3o os pr\u00f3ximos 8 bytes 00000230 de cf a3 03 00 00 00 00 |........| 00000238 Big endian: 0000000003A3CFDE | Decimal: 61067230. O \u00faltimo setor dispon\u00edvel \u00e9 o 61067230. O GUID s\u00e3o os pr\u00f3ximos 16 bytes 00000238 46 8a 0b 22 c3 8c 45 75 8c ef f5 bd 9e 32 4c 5b |F..\"..Eu.....2L[| 00000248 O GUID possui segmenta\u00e7\u00f5es: 468a0b22-c38c-4575-8cef-f5bd9e324c5b. Os primeiros 8 bytes s\u00e3o convertidos para big endian e o restante n\u00e3o \u00e9 convertido, resultando em: 220B8A46-8CC3-7545-8CEF-F5BD9E324C5B O setor que inicia as tabelas de parti\u00e7\u00e3o s\u00e3o os pr\u00f3ximos 8 bytes 00000248 02 00 00 00 00 00 00 00 |........| 00000250 Quantidades poss\u00edveis de parti\u00e7\u00f5es s\u00e3o os pr\u00f3ximos 4 bytes 00000250 80 00 00 00 |....| 00000254 Tamanho de um entrada da tabela de parti\u00e7\u00e3o s\u00e3o os pr\u00f3ximos 4 bytes 00000254 80 00 00 00 |....| 00000258 CRC32 de todas as entradas de parti\u00e7\u00e3o do disco s\u00e3o os pr\u00f3ximos 4 bytes 00000258 af 06 c5 b4 |....| 0000025c Restante do espa\u00e7o s\u00e3o 420 bytes 0000025c 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 00000400 LB2 - LBN 00000400 af 3d c6 0f 83 84 72 47 8e 79 3d 69 d8 47 7d e4 |.=....rG.y=i.G}.| 00000410 a0 d5 b4 b0 cf d0 4d fe b7 09 a8 3f 44 67 bd b7 |......M....?Dg..| 00000420 00 08 00 00 00 00 00 00 de cf a3 03 00 00 00 00 |................| 00000430 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 00000480 Tipo de parti\u00e7\u00e3o GUID s\u00e3o os primeiros 16 bytes 00000400 af 3d c6 0f 83 84 72 47 8e 79 3d 69 d8 47 7d e4 |.=....rG.y=i.G}.| 00000410 GUID \u00fanico s\u00e3o os pr\u00f3ximos 16 bytes 00000410 a0 d5 b4 b0 cf d0 4d fe b7 09 a8 3f 44 67 bd b7 |......M....?Dg..| 00000420 Primeiro setor dispon\u00edvel para parti\u00e7\u00e3o s\u00e3o os pr\u00f3ximos 8 bytes 00000420 00 08 00 00 00 00 00 00 |........| 00000428 \u00daltimo setor dispon\u00edvel para parti\u00e7\u00e3o s\u00e3o os pr\u00f3ximos 8 bytes 00000428 de cf a3 03 00 00 00 00 |........| 00000430 Os atributos s\u00e3o os pr\u00f3ximos 8 bytes 00000430 00 00 00 00 00 00 00 00 |........| 00000438 O nome da parti\u00e7\u00e3o s\u00e3o os pr\u00f3ximos 72 bytes 00000438 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 00000480","title":"Tabela de Parti\u00e7\u00e3o GUID"},{"location":"Documenta%C3%A7%C3%A3o/Parti%C3%A7%C3%B5es/GPT/#tabela-de-particao-guid","text":"baseado nos link1 , link2 e link3","title":"Tabela de Parti\u00e7\u00e3o GUID"},{"location":"Documenta%C3%A7%C3%A3o/Parti%C3%A7%C3%B5es/GPT/#consideracoes-iniciais","text":"Vamos utilizar um cart\u00e3o micro SD de 32GB. Para identificarmos o cart\u00e3o no sistema, utilizamos o comando lsblk , o resultado ser\u00e1 similar a essa \u2570\u2500 lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT sda 8 :0 0 894 ,3G 0 disk \u2514\u2500sda1 8 :1 0 894 ,3G 0 part /run/timeshift/backup sdc 8 :32 1 29 ,1G 0 disk \u2514\u2500sdc1 8 :33 1 29 ,1G 0 part nvme0n1 259 :0 0 465 ,8G 0 disk \u251c\u2500nvme0n1p1 259 :1 0 476M 0 part /boot/efi \u251c\u2500nvme0n1p2 259 :2 0 30 ,5G 0 part [ SWAP ] \u2514\u2500nvme0n1p3 259 :3 0 434 ,8G 0 part / Para ter certeza qual \u00e9 o cart\u00e3o SD, execute o lsblk com o cart\u00e3o n\u00e3o conectado e depois conecte o cart\u00e3o e execute o comando novamente (simples ). No caso acima, o cart\u00e3o SD \u00e9 o /dev/sdc . Para facilitar a visualiza\u00e7\u00e3o das altera\u00e7\u00f5es que iremos fazer, vamos zerar os primeiros 10240 bytes do cart\u00e3o. Para isso, utilizaremos o comando dd sudo dd if = /dev/zero of = /dev/sdc bs = 1024 count = 10 Podemos visualizar conte\u00fado do cart\u00e3o, com o comando hexdump sudo hexdump -C /dev/sdc -n 10240 O resultado deve ser similar a esse 00000000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | ................ | * 00002800 o n\u00famero 00002800 \u00e9 em hexadecimal e seu equivalente em decimal \u00e9 10240 (ou 10 kB).","title":"Considera\u00e7\u00f5es iniciais"},{"location":"Documenta%C3%A7%C3%A3o/Parti%C3%A7%C3%B5es/GPT/#formatando-o-cartao-com-gpt","text":"Com os primeiros bytes do cart\u00e3o SD zerados, vamos adicionar a parti\u00e7\u00e3o GPT ao cart\u00e3o com o comando fdisk sudo fdisk /dev/sdc Um menu ir\u00e1 aparecer: Digite g Depois digite n Partition number (1-128, default 1): Enter First sector (2048-61067230, default 2048): Enter Last sector, +/-sectors or +/-size{K,M,G,T,P} (2048-61067230, default 61067230): Enter Por fim, digite w Agora o cart\u00e3o est\u00e1 com o particionamento GPT. Para checar, vamos visualizar novamente o conte\u00fado do cart\u00e3o SD 00000000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | ................ | * 000001c0 02 00 ee ff ff ff 01 00 00 00 ff cf a3 03 00 00 | ................ | 000001d0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | ................ | * 000001f0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 55 aa | ..............U. | 00000200 45 46 49 20 50 41 52 54 00 00 01 00 5c 00 00 00 | EFI PART.... \\. .. | 00000210 fc d8 3a 53 00 00 00 00 01 00 00 00 00 00 00 00 | ..:S............ | 00000220 ff cf a3 03 00 00 00 00 00 08 00 00 00 00 00 00 | ................ | 00000230 de cf a3 03 00 00 00 00 90 30 7b d4 f3 72 46 59 | .........0 { ..rFY | 00000240 89 2c 7f 77 9e b0 00 e6 02 00 00 00 00 00 00 00 | .,.w............ | 00000250 80 00 00 00 80 00 00 00 f1 ae 2f f5 00 00 00 00 | ........../..... | 00000260 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | ................ | * 00000400 af 3d c6 0f 83 84 72 47 8e 79 3d 69 d8 47 7d e4 | . = ....rG.y = i.G } . | 00000410 9c 58 84 76 3e 65 45 92 a4 ec 96 ed 84 df 22 99 | .X.v>eE....... \".| 00000420 00 08 00 00 00 00 00 00 de cf a3 03 00 00 00 00 |................| 00000430 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 00002800 Esses dados mostram que o GPT est\u00e1 sendo usando no cart\u00e3o SD.","title":"Formatando o cart\u00e3o com GPT"},{"location":"Documenta%C3%A7%C3%A3o/Parti%C3%A7%C3%B5es/GPT/#o-backup-de-seguranca","text":"Como uma forma de seguran\u00e7a contra perda de dados, o GPT faz um backup da parti\u00e7\u00e3o no final disco. Para checar basta utilizar o comando: sudo tail -c 10M /dev/sdc | hexdump -C Visualizando os \u00faltimos 10 MB do cart\u00e3o SD, encontramos o seguinte conte\u00fado 747900000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | ................ | * 7479fbe00 af 3d c6 0f 83 84 72 47 8e 79 3d 69 d8 47 7d e4 | . = ....rG.y = i.G } . | 7479fbe10 9c 58 84 76 3e 65 45 92 a4 ec 96 ed 84 df 22 99 | .X.v>eE....... \".| 7479fbe20 00 08 00 00 00 00 00 00 de cf a3 03 00 00 00 00 |................| 7479fbe30 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 7479ffe00 45 46 49 20 50 41 52 54 00 00 01 00 5c 00 00 00 |EFI PART....\\...| 7479ffe10 66 9b 01 67 00 00 00 00 ff cf a3 03 00 00 00 00 |f..g............| 7479ffe20 01 00 00 00 00 00 00 00 00 08 00 00 00 00 00 00 |................| 7479ffe30 de cf a3 03 00 00 00 00 90 30 7b d4 f3 72 46 59 |.........0{..rFY| 7479ffe40 89 2c 7f 77 9e b0 00 e6 df cf a3 03 00 00 00 00 |.,.w............| 7479ffe50 80 00 00 00 80 00 00 00 f1 ae 2f f5 00 00 00 00 |........../.....| 7479ffe60 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 747a00000 Podemos perceber um espelho dos dados do inicio do disco.","title":"O Backup de seguran\u00e7a"},{"location":"Documenta%C3%A7%C3%A3o/Parti%C3%A7%C3%B5es/GPT/#o-logical-block-addressing","text":"O Logical Block Addressing ou LBA, s\u00e3o blocos de informa\u00e7\u00e3o utilizado pelo GPT. Esses blocos possuem 512 bytes.","title":"O Logical Block Addressing"},{"location":"Documenta%C3%A7%C3%A3o/Parti%C3%A7%C3%B5es/GPT/#lba0","text":"O LBA0 existe para compatibilidade com o Master Boot Record (MBR), checando os primeiros 512 bytes do cart\u00e3o SD sudo hexdump -C /dev/sdc -s 0 -n 512 Temos esse resultado: 00000000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 000001c0 02 00 ee ff ff ff 01 00 00 00 ff cf a3 03 00 00 |................| 000001d0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 000001f0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 55 aa |..............U.| 00000200 Nada relevante pode ser visto aqui (a n\u00e3o ser que voc\u00ea esteja usando MBR )","title":"LBA0"},{"location":"Documenta%C3%A7%C3%A3o/Parti%C3%A7%C3%B5es/GPT/#lba1","text":"Esse LBA possui o cabe\u00e7alho da tabela de parti\u00e7\u00e3o. Visualizando os pr\u00f3ximos 512 bytes do cart\u00e3o SD sudo hexdump -C /dev/sdc -s 512 -n 512 Temos os seguintes dados: 00000200 45 46 49 20 50 41 52 54 00 00 01 00 5c 00 00 00 |EFI PART....\\...| 00000210 d2 61 e7 36 00 00 00 00 01 00 00 00 00 00 00 00 |.a.6............| 00000220 ff cf a3 03 00 00 00 00 00 08 00 00 00 00 00 00 |................| 00000230 de cf a3 03 00 00 00 00 46 8a 0b 22 c3 8c 45 75 |........F..\"..Eu| 00000240 8c ef f5 bd 9e 32 4c 5b 02 00 00 00 00 00 00 00 |.....2L[........| 00000250 80 00 00 00 80 00 00 00 af 06 c5 b4 00 00 00 00 |................| 00000260 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 00000400 Agora vamos entender esse vetor de bytes: Esses dados s\u00e3o Little Endian . Para interpretarmos o valor em decimal, devemos converter para Big Endian A assinatura s\u00e3o os primeiros 8 bytes 00000200 45 46 49 20 50 41 52 54 |EFI PART| 00000208 A revis\u00e3o s\u00e3o os 4 pr\u00f3ximos bytes 00000208 00 00 01 00 |....| 0000020c O tamanho do cabe\u00e7alho s\u00e3o os 4 pr\u00f3ximos bytes 0000020c 5c 00 00 00 |\\...| 00000210 O CRC32 da parti\u00e7\u00e3o s\u00e3o os 4 pr\u00f3ximos bytes 00000210 d2 61 e7 36 |.a.6| 00000214 Os pr\u00f3ximos 4 bytes s\u00e3o reservados e devem ser 0's 00000214 00 00 00 00 |....| 00000218 Endere\u00e7o do LBA atual s\u00e3o os 8 pr\u00f3ximos bytes 00000218 01 00 00 00 00 00 00 00 |........| 00000220 Localiza\u00e7\u00e3o do LBA espelho (backup) s\u00e3o os 8 pr\u00f3ximos bytes 00000220 ff cf a3 03 00 00 00 00 |........| 00000228 Big Endian: 00 00 00 00 03 A3 CF FF | Decimal 61067263. Isso indica que o LBA espelho est\u00e1 no setor 61067263. Para acessa-lo podemos utilizar o comando: sudo dd if=/dev/sdc bs=512 count=1 skip=61067263 Primeiro setor dispon\u00edvel para parti\u00e7\u00e3o s\u00e3o os pr\u00f3ximos 8 bytes 00000228 00 08 00 00 00 00 00 00 |........| 00000230 00 00 08 00 00 00 00 00 -> 2048 \u00daltimo setor dispon\u00edvel para parti\u00e7\u00e3o s\u00e3o os pr\u00f3ximos 8 bytes 00000230 de cf a3 03 00 00 00 00 |........| 00000238 Big endian: 0000000003A3CFDE | Decimal: 61067230. O \u00faltimo setor dispon\u00edvel \u00e9 o 61067230. O GUID s\u00e3o os pr\u00f3ximos 16 bytes 00000238 46 8a 0b 22 c3 8c 45 75 8c ef f5 bd 9e 32 4c 5b |F..\"..Eu.....2L[| 00000248 O GUID possui segmenta\u00e7\u00f5es: 468a0b22-c38c-4575-8cef-f5bd9e324c5b. Os primeiros 8 bytes s\u00e3o convertidos para big endian e o restante n\u00e3o \u00e9 convertido, resultando em: 220B8A46-8CC3-7545-8CEF-F5BD9E324C5B O setor que inicia as tabelas de parti\u00e7\u00e3o s\u00e3o os pr\u00f3ximos 8 bytes 00000248 02 00 00 00 00 00 00 00 |........| 00000250 Quantidades poss\u00edveis de parti\u00e7\u00f5es s\u00e3o os pr\u00f3ximos 4 bytes 00000250 80 00 00 00 |....| 00000254 Tamanho de um entrada da tabela de parti\u00e7\u00e3o s\u00e3o os pr\u00f3ximos 4 bytes 00000254 80 00 00 00 |....| 00000258 CRC32 de todas as entradas de parti\u00e7\u00e3o do disco s\u00e3o os pr\u00f3ximos 4 bytes 00000258 af 06 c5 b4 |....| 0000025c Restante do espa\u00e7o s\u00e3o 420 bytes 0000025c 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 00000400","title":"LBA1"},{"location":"Documenta%C3%A7%C3%A3o/Parti%C3%A7%C3%B5es/GPT/#lb2-lbn","text":"00000400 af 3d c6 0f 83 84 72 47 8e 79 3d 69 d8 47 7d e4 |.=....rG.y=i.G}.| 00000410 a0 d5 b4 b0 cf d0 4d fe b7 09 a8 3f 44 67 bd b7 |......M....?Dg..| 00000420 00 08 00 00 00 00 00 00 de cf a3 03 00 00 00 00 |................| 00000430 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 00000480 Tipo de parti\u00e7\u00e3o GUID s\u00e3o os primeiros 16 bytes 00000400 af 3d c6 0f 83 84 72 47 8e 79 3d 69 d8 47 7d e4 |.=....rG.y=i.G}.| 00000410 GUID \u00fanico s\u00e3o os pr\u00f3ximos 16 bytes 00000410 a0 d5 b4 b0 cf d0 4d fe b7 09 a8 3f 44 67 bd b7 |......M....?Dg..| 00000420 Primeiro setor dispon\u00edvel para parti\u00e7\u00e3o s\u00e3o os pr\u00f3ximos 8 bytes 00000420 00 08 00 00 00 00 00 00 |........| 00000428 \u00daltimo setor dispon\u00edvel para parti\u00e7\u00e3o s\u00e3o os pr\u00f3ximos 8 bytes 00000428 de cf a3 03 00 00 00 00 |........| 00000430 Os atributos s\u00e3o os pr\u00f3ximos 8 bytes 00000430 00 00 00 00 00 00 00 00 |........| 00000438 O nome da parti\u00e7\u00e3o s\u00e3o os pr\u00f3ximos 72 bytes 00000438 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 00000480","title":"LB2 - LBN"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/","text":"Documenta\u00e7\u00e3o com MKDOCS Image by WikiImages from Pixabay Introdu\u00e7\u00e3o Essa postagem foi inspirado na live de python #189 . Se quiser mais informa\u00e7\u00f5es sobre MKDocs da uma olhada no v\u00eddeo e deixa o like. O MKDocs \u00e9 uma biblioteca focada em documenta\u00e7\u00e3o, desenvolvida em python. Ela possui v\u00e1rias funcionalidades e algumas delas ser\u00e3o mostradas abaixo. Para instalar: pip install mkdocs Ap\u00f3s a instala\u00e7\u00e3o basta digitar: mkdocs new TESTE Os arquivos necess\u00e1rios para iniciar a documenta\u00e7\u00e3o ser\u00e3o criados. Markdown B\u00e1sico Comandos dispon\u00edveis por padr\u00e3o na biblioteca. T\u00edtulo (H1) # Exemplo Subtitulo (H2) ## Exemplo Subsubtitulo (H3) ### Exemplo Negrito **Exemplo** Exemplo It\u00e1lico *Exemplo* Exemplo Cita\u00e7\u00e3o > Exemplo Exemplo Lista Ordenada 1. Exemplo 2. Exemplo 3. Exemplo Exemplo Exemplo Exemplo Lista N\u00e3o Ordenada - Exemplo - Exemplo - Exemplo Exemplo Exemplo Exemplo Linha de C\u00f3digo `C\u00f3digo` C\u00f3digo Link [Site do google](https://www.google.com.br) Site do google Tabela | Nome | Idade | | ---- | ----- | | Jo\u00e3o | 28 | | Pedro | 34 | Nome Idade Jo\u00e3o 28 Pedro 34 Markdown Estendido Para ter ainda mais funcionalidades, \u00e9 necess\u00e1rio instalar a biblioteca PyMdown Extensions : pip install pymdown-extensions Al\u00e9m disso, \u00e9 necess\u00e1rio adicionar quais extens\u00f5es ser\u00e3o usadas dentro do arquivo mkdocs.yml , por exemplo: markdown_extensions: - pymdownx.tasklist - pymdownx.emoji - pymdownx.mark - pymdownx.tilde Cada uma dessas extens\u00f5es ser\u00e3o mostradas a seguir. Lista de Tarefas pymdownx.tasklist - [ ] Checar. - [ ] checar. - [X] checado. Checar. checar. checado. Emoji Para mais emojis: emojipedia . Escolha um emoji e procure por Shortcodes . pymdownx.emoji :snake: :heart: :rocket: Tachado pymdownx.tilde ~~Exemplo~~ Exemplo Real\u00e7ado pymdownx.mark ==Exemplo== Exemplo Super Fences Dentro do pymdown-extensions existe uma funcionalidade que merece um t\u00f3pico a parte, chamado de superfences . Com ele, o MKDocs fica ainda mais poderoso. \u00c9 necess\u00e1rio informar para o MKDocs que o super fences ser\u00e1 utilizado, adicionando as linhas dentro do mkdocs.yml : markdown_extensions: # ... - pymdownx.superfences: custom_fences: - name: mermaid class: mermaid format: !!python/name:pymdownx.superfences.fence_div_format extra_javascript: - https://unpkg.com/mermaid@8.5.1/dist/mermaid.min.js Bloco de c\u00f3digo pymdownx.superfences ```{.py3 linenums=\"44\" title=\"teste.py\" hl_lines=\"1 3\"} def xpto(): \"\"\"Docstring\"\"\" return True ``` teste.py 44 45 46 def xpto (): \"\"\"Docstring\"\"\" return True F\u00f3rmulas pymdownx.arithmatex $$ \\operatorname{ker} f=\\{g\\in G:f(g)=e_{H}\\}{\\mbox{.}} $$ \\[ \\operatorname{ker} f=\\{g\\in G:f(g)=e_{H}\\}{\\mbox{.}} \\] The homomorphism $f$ is injective if and only if its kernel is only the singleton set $e_G$, because otherwise $\\exists a,b\\in G$ with $a\\neq b$ such that $f(a)=f(b)$. The homomorphism \\(f\\) is injective if and only if its kernel is only the singleton set \\(e_G\\) , because otherwise \\(\\exists a,b\\in G\\) with \\(a\\neq b\\) such that \\(f(a)=f(b)\\) . Custom Fences \u00c9 poss\u00edvel incorporar outras bibliotecas dentro do MKDocs, por exemplo a Mermaid que \u00e9 uma biblioteca para gerar diagramas e gr\u00e1ficos. Para isso, \u00e9 necess\u00e1rio adicionar no mkdocs.yml - pymdownx.superfences: custom_fences: - name: mermaid class: mermaid format: !!python/name:pymdownx.superfences.fence_div_format extra_javascript: - https://unpkg.com/mermaid@8.5.1/dist/mermaid.min.js ```mermaid classDiagram Pessoa <|-- Eduardo class Pessoa{ +String nome +metodo(self):bool } ``` classDiagram Pessoa <|-- Jao class Pessoa{ +String nome +metodo(self):bool }","title":"Documenta\u00e7\u00e3o com MKDOCS"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#documentacao-com-mkdocs","text":"Image by WikiImages from Pixabay","title":"Documenta\u00e7\u00e3o com MKDOCS"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#introducao","text":"Essa postagem foi inspirado na live de python #189 . Se quiser mais informa\u00e7\u00f5es sobre MKDocs da uma olhada no v\u00eddeo e deixa o like. O MKDocs \u00e9 uma biblioteca focada em documenta\u00e7\u00e3o, desenvolvida em python. Ela possui v\u00e1rias funcionalidades e algumas delas ser\u00e3o mostradas abaixo. Para instalar: pip install mkdocs Ap\u00f3s a instala\u00e7\u00e3o basta digitar: mkdocs new TESTE Os arquivos necess\u00e1rios para iniciar a documenta\u00e7\u00e3o ser\u00e3o criados.","title":"Introdu\u00e7\u00e3o"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#markdown-basico","text":"Comandos dispon\u00edveis por padr\u00e3o na biblioteca.","title":"Markdown B\u00e1sico"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#titulo-h1","text":"# Exemplo","title":"T\u00edtulo (H1)"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#subtitulo-h2","text":"## Exemplo","title":"Subtitulo (H2)"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#subsubtitulo-h3","text":"### Exemplo","title":"Subsubtitulo (H3)"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#negrito","text":"**Exemplo** Exemplo","title":"Negrito"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#italico","text":"*Exemplo* Exemplo","title":"It\u00e1lico"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#citacao","text":"> Exemplo Exemplo","title":"Cita\u00e7\u00e3o"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#lista-ordenada","text":"1. Exemplo 2. Exemplo 3. Exemplo Exemplo Exemplo Exemplo","title":"Lista Ordenada"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#lista-nao-ordenada","text":"- Exemplo - Exemplo - Exemplo Exemplo Exemplo Exemplo","title":"Lista N\u00e3o Ordenada"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#linha-de-codigo","text":"`C\u00f3digo` C\u00f3digo","title":"Linha de C\u00f3digo"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#link","text":"[Site do google](https://www.google.com.br) Site do google","title":"Link"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#tabela","text":"| Nome | Idade | | ---- | ----- | | Jo\u00e3o | 28 | | Pedro | 34 | Nome Idade Jo\u00e3o 28 Pedro 34","title":"Tabela"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#markdown-estendido","text":"Para ter ainda mais funcionalidades, \u00e9 necess\u00e1rio instalar a biblioteca PyMdown Extensions : pip install pymdown-extensions Al\u00e9m disso, \u00e9 necess\u00e1rio adicionar quais extens\u00f5es ser\u00e3o usadas dentro do arquivo mkdocs.yml , por exemplo: markdown_extensions: - pymdownx.tasklist - pymdownx.emoji - pymdownx.mark - pymdownx.tilde Cada uma dessas extens\u00f5es ser\u00e3o mostradas a seguir.","title":"Markdown Estendido"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#lista-de-tarefas","text":"pymdownx.tasklist - [ ] Checar. - [ ] checar. - [X] checado. Checar. checar. checado.","title":"Lista de Tarefas"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#emoji","text":"Para mais emojis: emojipedia . Escolha um emoji e procure por Shortcodes . pymdownx.emoji :snake: :heart: :rocket:","title":"Emoji"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#tachado","text":"pymdownx.tilde ~~Exemplo~~ Exemplo","title":"Tachado"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#realcado","text":"pymdownx.mark ==Exemplo== Exemplo","title":"Real\u00e7ado"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#super-fences","text":"Dentro do pymdown-extensions existe uma funcionalidade que merece um t\u00f3pico a parte, chamado de superfences . Com ele, o MKDocs fica ainda mais poderoso. \u00c9 necess\u00e1rio informar para o MKDocs que o super fences ser\u00e1 utilizado, adicionando as linhas dentro do mkdocs.yml : markdown_extensions: # ... - pymdownx.superfences: custom_fences: - name: mermaid class: mermaid format: !!python/name:pymdownx.superfences.fence_div_format extra_javascript: - https://unpkg.com/mermaid@8.5.1/dist/mermaid.min.js","title":"Super Fences"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#bloco-de-codigo","text":"pymdownx.superfences ```{.py3 linenums=\"44\" title=\"teste.py\" hl_lines=\"1 3\"} def xpto(): \"\"\"Docstring\"\"\" return True ``` teste.py 44 45 46 def xpto (): \"\"\"Docstring\"\"\" return True","title":"Bloco de c\u00f3digo"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#formulas","text":"pymdownx.arithmatex $$ \\operatorname{ker} f=\\{g\\in G:f(g)=e_{H}\\}{\\mbox{.}} $$ \\[ \\operatorname{ker} f=\\{g\\in G:f(g)=e_{H}\\}{\\mbox{.}} \\] The homomorphism $f$ is injective if and only if its kernel is only the singleton set $e_G$, because otherwise $\\exists a,b\\in G$ with $a\\neq b$ such that $f(a)=f(b)$. The homomorphism \\(f\\) is injective if and only if its kernel is only the singleton set \\(e_G\\) , because otherwise \\(\\exists a,b\\in G\\) with \\(a\\neq b\\) such that \\(f(a)=f(b)\\) .","title":"F\u00f3rmulas"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#custom-fences","text":"\u00c9 poss\u00edvel incorporar outras bibliotecas dentro do MKDocs, por exemplo a Mermaid que \u00e9 uma biblioteca para gerar diagramas e gr\u00e1ficos. Para isso, \u00e9 necess\u00e1rio adicionar no mkdocs.yml - pymdownx.superfences: custom_fences: - name: mermaid class: mermaid format: !!python/name:pymdownx.superfences.fence_div_format extra_javascript: - https://unpkg.com/mermaid@8.5.1/dist/mermaid.min.js ```mermaid classDiagram Pessoa <|-- Eduardo class Pessoa{ +String nome +metodo(self):bool } ``` classDiagram Pessoa <|-- Jao class Pessoa{ +String nome +metodo(self):bool }","title":"Custom Fences"},{"location":"Linguagens/Rust/Cap1/","text":"Introdu\u00e7\u00e3o Instalando o Rust no linux Escrevendo o Hello World! Usando cargo (gerenciador de pacotes e sistema de build) Instalando o Rust no linux Devemos baixar o rustup , que \u00e9 responsp\u00e1vel por baixar o rust e fazer a instala\u00e7\u00e3o curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh Algumas informa\u00e7\u00f5es devem aparecer Welcome to Rust! This will download and install the official compiler for the Rust programming language, and its package manager, Cargo. Rustup metadata and toolchains will be installed into the Rustup home directory, located at: /home/jao/Documents/Programs/rust/rustup/ This can be modified with the RUSTUP_HOME environment variable. The Cargo home directory located at: /home/jao/Documents/Programs/rust/cargo/ This can be modified with the CARGO_HOME environment variable. The cargo, rustc, rustup and other commands will be added to Cargo's bin directory , located at: /home/jao/.cargo/bin This path will then be added to your PATH environment variable by modifying the profile files located at: /home/jao/.profile /home/jao/.zshenv You can uninstall at any time with rustup self uninstall and these changes will be reverted. Current installation options: default host triple: x86_64-unknown-linux-gnu default toolchain: stable (default) profile: default modify PATH variable: yes 1) Proceed with installation (default) 2) Customize installation 3) Cancel installation Basta digitar 1 e a instala\u00e7\u00e3o ir\u00e1 come\u00e7ar. Se tudo occorrer bem, a seguinte mensagem deve aparecer Rust is installed now. Great! To get started you may need to restart your current shell. This would reload your PATH environment variable to include Cargo's bin directory (/home/jao/Documents/Programs/rust/cargo//bin). To configure your current shell, run: source /home/jao/Documents/Programs/rust/cargo//env Alguns comandos \u00fateis rustup update rustup self uninstall rustc --version rustup doc Escrevendo o Hello World! Crie um arquivo chamado main.rs e adicione o conte\u00fado main.rs fn main () { println! ( \"Hello World!\" ); } Para compilar e executar, basta digitar no terminal rustc main.rc ./main O resultado ser\u00e1 o texto Hello World! Alguns comandos \u00fateis rustfmt (para formatar o c\u00f3digo) Usando cargo (gerenciador de pacotes e sistema de build) Para criar um projeto utilizando o cargo , basta usar o comando cargo new hello_cargo Um arquivo main.rs ser\u00e1 criado dentro da pasta hello_cargo/src/ . Para compilar o c\u00f3digo, basta digitar cargo build dentro da pasta hello_cargo, a pasta target/ ser\u00e1 criada e o execut\u00e1vel est\u00e1 em hello_cargo/target/debug , chamado de hello_cargo Comandos \u00fateis cargo run (para executar o programa) cargo check (para fazer as checagens no c\u00f3digo, sem compilar) cargo build --release (para fazer uma build de release, por padr\u00e3o a build \u00e9 de debug).","title":"Introdu\u00e7\u00e3o"},{"location":"Linguagens/Rust/Cap1/#introducao","text":"Instalando o Rust no linux Escrevendo o Hello World! Usando cargo (gerenciador de pacotes e sistema de build)","title":"Introdu\u00e7\u00e3o"},{"location":"Linguagens/Rust/Cap1/#instalando-o-rust-no-linux","text":"Devemos baixar o rustup , que \u00e9 responsp\u00e1vel por baixar o rust e fazer a instala\u00e7\u00e3o curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh Algumas informa\u00e7\u00f5es devem aparecer Welcome to Rust! This will download and install the official compiler for the Rust programming language, and its package manager, Cargo. Rustup metadata and toolchains will be installed into the Rustup home directory, located at: /home/jao/Documents/Programs/rust/rustup/ This can be modified with the RUSTUP_HOME environment variable. The Cargo home directory located at: /home/jao/Documents/Programs/rust/cargo/ This can be modified with the CARGO_HOME environment variable. The cargo, rustc, rustup and other commands will be added to Cargo's bin directory , located at: /home/jao/.cargo/bin This path will then be added to your PATH environment variable by modifying the profile files located at: /home/jao/.profile /home/jao/.zshenv You can uninstall at any time with rustup self uninstall and these changes will be reverted. Current installation options: default host triple: x86_64-unknown-linux-gnu default toolchain: stable (default) profile: default modify PATH variable: yes 1) Proceed with installation (default) 2) Customize installation 3) Cancel installation Basta digitar 1 e a instala\u00e7\u00e3o ir\u00e1 come\u00e7ar. Se tudo occorrer bem, a seguinte mensagem deve aparecer Rust is installed now. Great! To get started you may need to restart your current shell. This would reload your PATH environment variable to include Cargo's bin directory (/home/jao/Documents/Programs/rust/cargo//bin). To configure your current shell, run: source /home/jao/Documents/Programs/rust/cargo//env","title":"Instalando o Rust no linux"},{"location":"Linguagens/Rust/Cap1/#alguns-comandos-uteis","text":"rustup update rustup self uninstall rustc --version rustup doc","title":"Alguns comandos \u00fateis"},{"location":"Linguagens/Rust/Cap1/#escrevendo-o-hello-world","text":"Crie um arquivo chamado main.rs e adicione o conte\u00fado main.rs fn main () { println! ( \"Hello World!\" ); } Para compilar e executar, basta digitar no terminal rustc main.rc ./main O resultado ser\u00e1 o texto Hello World!","title":"Escrevendo o Hello World!"},{"location":"Linguagens/Rust/Cap1/#alguns-comandos-uteis_1","text":"rustfmt (para formatar o c\u00f3digo)","title":"Alguns comandos \u00fateis"},{"location":"Linguagens/Rust/Cap1/#usando-cargo-gerenciador-de-pacotes-e-sistema-de-build","text":"Para criar um projeto utilizando o cargo , basta usar o comando cargo new hello_cargo Um arquivo main.rs ser\u00e1 criado dentro da pasta hello_cargo/src/ . Para compilar o c\u00f3digo, basta digitar cargo build dentro da pasta hello_cargo, a pasta target/ ser\u00e1 criada e o execut\u00e1vel est\u00e1 em hello_cargo/target/debug , chamado de hello_cargo","title":"Usando cargo (gerenciador de pacotes e sistema de build)"},{"location":"Linguagens/Rust/Cap1/#comandos-uteis","text":"cargo run (para executar o programa) cargo check (para fazer as checagens no c\u00f3digo, sem compilar) cargo build --release (para fazer uma build de release, por padr\u00e3o a build \u00e9 de debug).","title":"Comandos \u00fateis"},{"location":"RTOS/zephyr/zephyr/","text":"Zephyr + Esp32 + Blinky = \u2764\ufe0f Image by methodshop from Pixabay Introdu\u00e7\u00e3o Recentemente voltei a pesquisar sobre Internet of Things (IoT) e durante uma conversas no trabalho fiquei sabendo do Zephyr. Por sorte, um Webnar da Embarcados aconteceu e pude me interar mais sobre essa plataforma. S\u00f3 tenho uma palavra para definir: Sensacional \ud83e\udd2f Instalando depend\u00eancias Estou usando Ubuntu 22.04 . sudo apt install --no-install-recommends git cmake ninja-build gperf \\ ccache dfu-util device-tree-compiler wget \\ python3-dev python3-pip python3-setuptools python3-tk python3-wheel xz-utils file \\ make gcc gcc-multilib g++-multilib libsdl2-dev O Zephyr usa o python para gerenciar os pacotes, algumas depend\u00eancias tamb\u00e9m s\u00e3o necess\u00e1rias pip3 install west Ap\u00f3s isso, \u00e9 necess\u00e1rio definir o local onde os arquivos ser\u00e3o salvos. No exemplo vou usar o caminho /home/jao/Documents/Workspace/IoT west init /home/jao/Documents/Workspace/IoT/PASTA_DO_ZEPHYR Alguns arquivos ser\u00e3o baixados do reposit\u00f3rio . Em seguida: PS: Demora... cd /home/jao/Documents/Workspace/IoT/PASTA_DO_ZEPHYR west update Depois de terminar a atualiza\u00e7\u00e3o, \u00e9 necess\u00e1rio exportar algumas vari\u00e1veis de ambiente: west zephyr-export e ent\u00e3o instalar as dep\u00eancencias restantes do python: pip3 install -r /home/jao/Documents/Workspace/IoT/PASTA_DO_ZEPHYR/zephyr/scripts/requirements.txt Baixando a toolchain Como vamos utilizar o Esp32, a toolchain pode ser baixada aqui . No meu caso estou usando a plataforma linux-amd64 Ap\u00f3s baixar a toolchain correto, extraia e adicione o caminho da pasta a vari\u00e1vel de ambiente ESPRESSIF_TOOLCHAIN_PATH export ESPRESSIF_TOOLCHAIN_PATH=/home/jao/Documents/Workspace/IoT/xtensa-esp32-elf/xtensa-esp32-elf/ \u00c9 necess\u00e1rio adicionar outra vari\u00e1vel: export ZEPHYR_TOOLCHAIN_VARIANT=\"espressif\" Finalmente, podemos baixar os pacotes referentes ao Esp32 do Zephyr: PS: O camando deve ser dado dentro da pasta do Zephyr, no caso: /home/jao/Documents/Workspace/IoT/PASTA_DO_ZEPHYR west espressif update Ap\u00f3s esse passo, o ambiente de configura\u00e7\u00e3o para o Esp32 estar\u00e1 finalizado. Exemplo Blinky Na vers\u00e3o atual do Zephyr 3.0.0 , \u00e9 necess\u00e1rio adicionar um m\u00f3dulo no device driver para que o led built-in sej\u00e1 reconhecido. Para isso, \u00e9 necess\u00e1rio criar um arquivo dentro do exemplo do Blincky do pr\u00f3prio Zephyr touch /home/jao/Documents/Workspace/IoT/PASTA_DO_ZEPHYR/zephyr/samples/basic/blinky/esp32.overlay o arquivo deve conter o seguinte conte\u00fado: / { aliases { led0 = &led0; }; leds { compatible = \"gpio-leds\"; led0: led_0 { gpios = <&gpio0 2 GPIO_ACTIVE_HIGH>; label = \"LED 0\"; }; }; }; Na linha gpios = <&gpio0 2 GPIO_ACTIVE_HIGH>; , o n\u00famero 2 \u00e9 referente ao gpio associado ao led built-in . Agora \u00e9 s\u00f3 compilar: PS: dentro da pasta: /home/jao/Documents/Workspace/IoT/PASTA_DO_ZEPHYR/ west build -p auto -b esp32 zephyr/samples/basic/blinky Muitas vezes o arquivo CMakeCache.txt, precisa ser deletado. Ele fica localizado em : /home/jao/Documents/Workspace/IoT/PASTA_DO_ZEPHYR/build/ Se tudo ocorrer bem, a seguinte mensagem deve aparecer: [103/103] Linking C executable zephyr/zephyr.elf Memory region Used Size Region Size %age Used mcuboot_hdr: 32 B 32 B 100.00% metadata: 28 B 32 B 87.50% ROM: 31172 B 4194240 B 0.74% iram0_0_seg: 13004 B 128 KB 9.92% irom0_0_seg: 13692 B 3342304 B 0.41% dram0_0_seg: 1240 B 180736 B 0.69% dram0_1_seg: 53 KB 110032 B 49.32% drom0_0_seg: 3826 B 4194240 B 0.09% rtc_iram_seg: 0 GB 8 KB 0.00% rtc_slow_seg: 0 GB 4 KB 0.00% IDT_LIST: 0 GB 8 KB 0.00% esptool.py v3.3-dev Creating esp32 image... Merged 6 ELF sections Successfully created esp32 image. Para flashar no esp32, pasta digitar o seguinte comando: west flash O resultado deve ser algo semelhante: Flash will be erased from 0x00010000 to 0x00033fff... Flash params set to 0x0220 Wrote 32768 bytes at 0x00001000 in 0.7 seconds (390.4 kbit/s)... Hash of data verified. Wrote 16384 bytes at 0x00008000 in 0.3 seconds (515.8 kbit/s)... Hash of data verified. Wrote 147456 bytes at 0x00010000 in 2.0 seconds (594.7 kbit/s)... Hash of data verified. Leaving... Hard resetting via RTS pin... Se o seguinte erro acontecer: /dev/ttyS0 failed to connect: Failed to connect to Espressif device: No serial data received. For troubleshooting steps visit: https://docs.espressif.com/projects/esptool/en/latest/troubleshooting.html A fatal error occurred: Could not connect to an Espressif device on any of the 2 available serial ports. Talvez seja necess\u00e1rio ficar segurando o bot\u00e3o boot do Esp32. \u00c9 isso, at\u00e9 a pr\u00f3xima.","title":"Zephyr + Esp32 + Blinky = \u2764\ufe0f"},{"location":"RTOS/zephyr/zephyr/#zephyr-esp32-blinky","text":"Image by methodshop from Pixabay","title":"Zephyr + Esp32 + Blinky = \u2764\ufe0f"},{"location":"RTOS/zephyr/zephyr/#introducao","text":"Recentemente voltei a pesquisar sobre Internet of Things (IoT) e durante uma conversas no trabalho fiquei sabendo do Zephyr. Por sorte, um Webnar da Embarcados aconteceu e pude me interar mais sobre essa plataforma. S\u00f3 tenho uma palavra para definir: Sensacional \ud83e\udd2f","title":"Introdu\u00e7\u00e3o"},{"location":"RTOS/zephyr/zephyr/#instalando-dependencias","text":"Estou usando Ubuntu 22.04 . sudo apt install --no-install-recommends git cmake ninja-build gperf \\ ccache dfu-util device-tree-compiler wget \\ python3-dev python3-pip python3-setuptools python3-tk python3-wheel xz-utils file \\ make gcc gcc-multilib g++-multilib libsdl2-dev O Zephyr usa o python para gerenciar os pacotes, algumas depend\u00eancias tamb\u00e9m s\u00e3o necess\u00e1rias pip3 install west Ap\u00f3s isso, \u00e9 necess\u00e1rio definir o local onde os arquivos ser\u00e3o salvos. No exemplo vou usar o caminho /home/jao/Documents/Workspace/IoT west init /home/jao/Documents/Workspace/IoT/PASTA_DO_ZEPHYR Alguns arquivos ser\u00e3o baixados do reposit\u00f3rio . Em seguida: PS: Demora... cd /home/jao/Documents/Workspace/IoT/PASTA_DO_ZEPHYR west update Depois de terminar a atualiza\u00e7\u00e3o, \u00e9 necess\u00e1rio exportar algumas vari\u00e1veis de ambiente: west zephyr-export e ent\u00e3o instalar as dep\u00eancencias restantes do python: pip3 install -r /home/jao/Documents/Workspace/IoT/PASTA_DO_ZEPHYR/zephyr/scripts/requirements.txt","title":"Instalando depend\u00eancias"},{"location":"RTOS/zephyr/zephyr/#baixando-a-toolchain","text":"Como vamos utilizar o Esp32, a toolchain pode ser baixada aqui . No meu caso estou usando a plataforma linux-amd64 Ap\u00f3s baixar a toolchain correto, extraia e adicione o caminho da pasta a vari\u00e1vel de ambiente ESPRESSIF_TOOLCHAIN_PATH export ESPRESSIF_TOOLCHAIN_PATH=/home/jao/Documents/Workspace/IoT/xtensa-esp32-elf/xtensa-esp32-elf/ \u00c9 necess\u00e1rio adicionar outra vari\u00e1vel: export ZEPHYR_TOOLCHAIN_VARIANT=\"espressif\" Finalmente, podemos baixar os pacotes referentes ao Esp32 do Zephyr: PS: O camando deve ser dado dentro da pasta do Zephyr, no caso: /home/jao/Documents/Workspace/IoT/PASTA_DO_ZEPHYR west espressif update Ap\u00f3s esse passo, o ambiente de configura\u00e7\u00e3o para o Esp32 estar\u00e1 finalizado.","title":"Baixando a toolchain"},{"location":"RTOS/zephyr/zephyr/#exemplo-blinky","text":"Na vers\u00e3o atual do Zephyr 3.0.0 , \u00e9 necess\u00e1rio adicionar um m\u00f3dulo no device driver para que o led built-in sej\u00e1 reconhecido. Para isso, \u00e9 necess\u00e1rio criar um arquivo dentro do exemplo do Blincky do pr\u00f3prio Zephyr touch /home/jao/Documents/Workspace/IoT/PASTA_DO_ZEPHYR/zephyr/samples/basic/blinky/esp32.overlay o arquivo deve conter o seguinte conte\u00fado: / { aliases { led0 = &led0; }; leds { compatible = \"gpio-leds\"; led0: led_0 { gpios = <&gpio0 2 GPIO_ACTIVE_HIGH>; label = \"LED 0\"; }; }; }; Na linha gpios = <&gpio0 2 GPIO_ACTIVE_HIGH>; , o n\u00famero 2 \u00e9 referente ao gpio associado ao led built-in . Agora \u00e9 s\u00f3 compilar: PS: dentro da pasta: /home/jao/Documents/Workspace/IoT/PASTA_DO_ZEPHYR/ west build -p auto -b esp32 zephyr/samples/basic/blinky Muitas vezes o arquivo CMakeCache.txt, precisa ser deletado. Ele fica localizado em : /home/jao/Documents/Workspace/IoT/PASTA_DO_ZEPHYR/build/ Se tudo ocorrer bem, a seguinte mensagem deve aparecer: [103/103] Linking C executable zephyr/zephyr.elf Memory region Used Size Region Size %age Used mcuboot_hdr: 32 B 32 B 100.00% metadata: 28 B 32 B 87.50% ROM: 31172 B 4194240 B 0.74% iram0_0_seg: 13004 B 128 KB 9.92% irom0_0_seg: 13692 B 3342304 B 0.41% dram0_0_seg: 1240 B 180736 B 0.69% dram0_1_seg: 53 KB 110032 B 49.32% drom0_0_seg: 3826 B 4194240 B 0.09% rtc_iram_seg: 0 GB 8 KB 0.00% rtc_slow_seg: 0 GB 4 KB 0.00% IDT_LIST: 0 GB 8 KB 0.00% esptool.py v3.3-dev Creating esp32 image... Merged 6 ELF sections Successfully created esp32 image. Para flashar no esp32, pasta digitar o seguinte comando: west flash O resultado deve ser algo semelhante: Flash will be erased from 0x00010000 to 0x00033fff... Flash params set to 0x0220 Wrote 32768 bytes at 0x00001000 in 0.7 seconds (390.4 kbit/s)... Hash of data verified. Wrote 16384 bytes at 0x00008000 in 0.3 seconds (515.8 kbit/s)... Hash of data verified. Wrote 147456 bytes at 0x00010000 in 2.0 seconds (594.7 kbit/s)... Hash of data verified. Leaving... Hard resetting via RTS pin... Se o seguinte erro acontecer: /dev/ttyS0 failed to connect: Failed to connect to Espressif device: No serial data received. For troubleshooting steps visit: https://docs.espressif.com/projects/esptool/en/latest/troubleshooting.html A fatal error occurred: Could not connect to an Espressif device on any of the 2 available serial ports. Talvez seja necess\u00e1rio ficar segurando o bot\u00e3o boot do Esp32. \u00c9 isso, at\u00e9 a pr\u00f3xima.","title":"Exemplo Blinky"}]}
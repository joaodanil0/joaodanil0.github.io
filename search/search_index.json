{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"D\u00favidas Gerais Como saber qual o endere\u00e7o que o SOC vai buscar, ap\u00f3s iniciar ? (Datasheet ?) Como o u-boot carrega o kernel linux ? Como colocar o Android em um SD card ? VIM3 Raspberry Como foi feito o port do Android ? Git do projeto site com os arquivos compilados Beaglebone Fazer o curso da udemy Embedded Linux Step by Step Using Beaglebone Black","title":"D\u00favidas"},{"location":"#duvidas","text":"","title":"D\u00favidas"},{"location":"#gerais","text":"Como saber qual o endere\u00e7o que o SOC vai buscar, ap\u00f3s iniciar ? (Datasheet ?) Como o u-boot carrega o kernel linux ? Como colocar o Android em um SD card ?","title":"Gerais"},{"location":"#vim3","text":"","title":"VIM3"},{"location":"#raspberry","text":"Como foi feito o port do Android ? Git do projeto site com os arquivos compilados","title":"Raspberry"},{"location":"#beaglebone","text":"Fazer o curso da udemy Embedded Linux Step by Step Using Beaglebone Black","title":"Beaglebone"},{"location":"Android/boot.img/","text":"Boot.img Image by dexmac from Pixabay Introdu\u00e7\u00e3o A algum tempo venho tentando desbravar o mundo do Android embarcado. Sem sombra de d\u00favidas \u00e9 uma \u00e1rea super interessante, mas os desafios s\u00e3o enormes. O sistema est\u00e1 crescendo desenfreadamente e os livros e fontes de estudo n\u00e3o est\u00e3o conseguindo acompanhar essa evolu\u00e7\u00e3o. Al\u00e9m disso, a documenta\u00e7\u00e3o na parte do sistema \u00e9 muito superficial, ao contr\u00e1rio da parte de desenvolvimento de aplica\u00e7\u00f5es ( documenta\u00e7\u00e3o ) que tamb\u00e9m possuem v\u00e1rios cursos pela Internet. Dispositivo usado [Em breve] Antes de Come\u00e7ar [Em breve] Instalando Depend\u00eancias Instalando o Repo []","title":"Boot.img"},{"location":"Android/boot.img/#bootimg","text":"Image by dexmac from Pixabay","title":"Boot.img"},{"location":"Android/boot.img/#introducao","text":"A algum tempo venho tentando desbravar o mundo do Android embarcado. Sem sombra de d\u00favidas \u00e9 uma \u00e1rea super interessante, mas os desafios s\u00e3o enormes. O sistema est\u00e1 crescendo desenfreadamente e os livros e fontes de estudo n\u00e3o est\u00e3o conseguindo acompanhar essa evolu\u00e7\u00e3o. Al\u00e9m disso, a documenta\u00e7\u00e3o na parte do sistema \u00e9 muito superficial, ao contr\u00e1rio da parte de desenvolvimento de aplica\u00e7\u00f5es ( documenta\u00e7\u00e3o ) que tamb\u00e9m possuem v\u00e1rios cursos pela Internet.","title":"Introdu\u00e7\u00e3o"},{"location":"Android/boot.img/#dispositivo-usado","text":"[Em breve]","title":"Dispositivo usado"},{"location":"Android/boot.img/#antes-de-comecar","text":"[Em breve] Instalando Depend\u00eancias Instalando o Repo []","title":"Antes de Come\u00e7ar"},{"location":"Android/HAL/AIDL/","text":"Implementando a AIDL Image by methodshop from Pixabay Baseado no curso: Android 12 Internals material, labs and discussion Introdu\u00e7\u00e3o A partir do Android 12, novas Hardware Abstraction Layer (HAL) passam a ser obrigatoriamente implementadas utilizando Android Interface Definition Language (AIDL). Por isso, criei esse post. Implementa\u00e7\u00e3o Vou tentar dividir em alguns t\u00f3picos para facilitar. HAL Na pasta raiz do AOSP , criei o seguinte caminho: mkdir -p device/casa/emulator/interfaces/foo/aidl/ Dentro da pasta, criei o seguinte arquivo: Android.bp aidl_interface { name: \"mypackage.mysubpackage.fooAIDL\", vendor: true, srcs: [\"mypackage/mysubpackage/fooAIDL/*.aidl\"], stability: \"vintf\", owner: \"CASA\", backend: { cpp: { enabled: true, }, java: { sdk_version: \"module_current\", }, }, } ainda dentro da pasta, criei o seguinte caminho: mkdir -p mypackage/mysubpackage/fooAIDL/ com o seguinte arquivo: ITest.aidl package mypackage.mysubpackage.fooAIDL; @VintfStability interface ITest { String getTest(); boolean setTest(in String param); } O resultado foi esse: device/casa/emulator/interfaces/foo/aidl \u251c\u2500\u2500 Android.bp \u2514\u2500\u2500 mypackage \u2514\u2500\u2500 mysubpackage \u2514\u2500\u2500 fooAIDL \u2514\u2500\u2500 ITest.aidl Agora no arquivo do produto, no meu caso: emulator.mk ... PRODUCT_PACKAGES += \\ mypackage.mysubpackage.fooAIDL \\ Na pasta raiz do AOSP, digite: m mypackage.mysubpackage.fooAIDL-update-api Esse comando vai gerar a pasta aidl_api : device/casa/emulator/interfaces/foo/aidl \u251c\u2500\u2500 aidl_api \u2502 \u2514\u2500\u2500 mypackage.mysubpackage.fooAIDL \u2502 \u2514\u2500\u2500 current \u2502 \u2514\u2500\u2500 mypackage \u2502 \u2514\u2500\u2500 mysubpackage \u2502 \u2514\u2500\u2500 fooAIDL \u2502 \u2514\u2500\u2500 ITest.aidl \u251c\u2500\u2500 Android.bp \u2514\u2500\u2500 mypackage \u2514\u2500\u2500 mysubpackage \u2514\u2500\u2500 fooAIDL \u2514\u2500\u2500 ITest.aidl Esse comando faz uma esp\u00e9cie de versionamento da AIDL. Agora dentro da pasta device/casa/emulator/interfaces/foo/aidl , digite o comando: mm Ela ir\u00e1 gerar as classes necess\u00e1rias dentro da pasta : out/soong/.intermediates/device/casa/emulator/interfaces/foo/aidl \u251c\u2500\u2500 mypackage.mysubpackage.fooAIDL-api \u251c\u2500\u2500 mypackage.mysubpackage.fooAIDL-V1-cpp \u251c\u2500\u2500 mypackage.mysubpackage.fooAIDL-V1-cpp-source \u251c\u2500\u2500 mypackage.mysubpackage.fooAIDL-V1-java \u251c\u2500\u2500 mypackage.mysubpackage.fooAIDL-V1-java-source \u251c\u2500\u2500 mypackage.mysubpackage.fooAIDL-V1-ndk \u251c\u2500\u2500 mypackage.mysubpackage.fooAIDL-V1-ndk_platform \u251c\u2500\u2500 mypackage.mysubpackage.fooAIDL-V1-ndk_platform-source \u2514\u2500\u2500 mypackage.mysubpackage.fooAIDL-V1-ndk-source Servi\u00e7o Criei a pasta device/casa/emulator/interfaces/foo/aidl/default/ , e dentro dela os arquivos: Test.h #pragma once // Mesmo caminho ap\u00f3s: // mypackage.mysubpackage.fooAIDL-V1-ndk_platform-source/gen/include/ // dentro da pasta : // out/soong/.intermediates/device/casa/emulator/interfaces/foo/aidl #include <aidl/mypackage/mysubpackage/fooAIDL/BnTest.h> namespace aidl :: mypackage :: mysubpackage :: fooAIDL { class Test : public BnTest { public : ndk :: ScopedAStatus getTest ( std :: string * _aidl_return ) override ; ndk :: ScopedAStatus setTest ( const std :: string & in_param , bool * _aidl_return ) override ; }; } // namespace aidl::mypackage::mysubpackage::fooAIDL Test.cpp #include \"Test.h\" #include <utils/Log.h> #include <sys/stat.h> namespace aidl :: mypackage :: mysubpackage :: fooAIDL { // conservative|powersave|performance|schedutil static const char SCALING_GOVERNOR [] = \\ \"/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor\" ; static int write_value ( const char * file , const char * value ) { int to_write , written , ret , fd ; fd = TEMP_FAILURE_RETRY ( open ( file , O_WRONLY )); if ( fd < 0 ) { return -1 ; } to_write = strlen ( value ) + 1 ; written = TEMP_FAILURE_RETRY ( write ( fd , value , to_write )); if ( written == -1 ) { ret = -2 ; } else if ( written != to_write ) { ret = -3 ; } else { ret = 0 ; } errno = 0 ; close ( fd ); return ret ; } ndk :: ScopedAStatus Test::getTest ( std :: string * _aidl_return ) { char str [ 20 ]; int fd ; ssize_t ret = 0 ; struct stat info ; void * data = NULL ; size_t size ; // If open returns error code EINTR, retry again until error code // is not a temporary failure fd = TEMP_FAILURE_RETRY ( open ( SCALING_GOVERNOR , O_RDONLY )); if ( fd < 0 ) { ndk :: ScopedAStatus :: fromServiceSpecificError ( -1 ); } fstat ( fd , & info ); size = info . st_size ; data = malloc ( size ); if ( data == NULL ) { * _aidl_return = \"error can't malloc\" ; goto exit ; } ret = read ( fd , data , size ); if ( ret < 0 ) { * _aidl_return = \"error reading fd\" ; goto exit ; } snprintf ( str , sizeof ( str ), \"%s\" , ( const unsigned char * ) data ); ALOGI ( \"Test AIDL::getTest data=(%s)\" , str ); * _aidl_return = str ; exit : close ( fd ); free ( data ); return ndk :: ScopedAStatus :: ok (); } ndk :: ScopedAStatus Test::setTest ( const std :: string & in_param , bool * _aidl_return ) { ALOGI ( \"Test AIDL::setTest data=(%s)\" , in_param . c_str ()); * _aidl_return = write_value ( SCALING_GOVERNOR , in_param . c_str ()) == 0 ; return ndk :: ScopedAStatus :: ok (); } } // namespace aidl::vendor::eightman::cpu service.cpp #define LOG_TAG \"mypackage.mysubpackage.fooAIDL-service\" #include <android-base/logging.h> #include <android/binder_process.h> #include <binder/ProcessState.h> #include <android/binder_manager.h> #include <binder/IServiceManager.h> #include \"Test.h\" using aidl :: mypackage :: mysubpackage :: fooAIDL :: Test ; using std :: string_literals :: operator \"\" s ; int main () { // Enable vndbinder to allow vendor-to-vendor binder calls. android :: ProcessState :: initWithDriver ( \"/dev/vndbinder\" ); ABinderProcess_startThreadPool (); LOG ( INFO ) << \"Test aidl service for fooAIDL is starting.,,\" ; std :: shared_ptr < Test > test = ndk :: SharedRefBase :: make < Test > (); const std :: string name = Test :: descriptor + \"/default\" s ; CHECK_EQ ( STATUS_OK , AServiceManager_addService ( test -> asBinder (). get (), name . c_str ())); LOG ( INFO ) << \"Initialized fooAIDL cpu\" ; ABinderProcess_joinThreadPool (); return EXIT_FAILURE ; // should not reach } Android.bp cc_binary { name: \"mypackage.mysubpackage.fooAIDL-service\", vendor: true, relative_install_path: \"hw\", init_rc: [\"mypackage.mysubpackage.fooAIDL-service.rc\"], vintf_fragments: [\"mypackage.mysubpackage.fooAIDL-service.xml\"], srcs: [ \"service.cpp\", \"Test.cpp\" ], cflags: [ \"-Wall\", \"-Werror\", ], shared_libs: [ \"libbase\", \"liblog\", \"libhardware\", \"libbinder_ndk\", \"libbinder\", \"libutils\", \"mypackage.mysubpackage.fooAIDL-V1-ndk_platform\", ], } mypackage.mysubpackage.fooAIDL-service.rc service mypackage.mysubpackage.fooAIDL-service /vendor/bin/hw/mypackage.mysubpackage.fooAIDL-service interface aidl mypackage.mysubpackage.fooAIDL-service.ITest/default class hal user system group system on boot chown system system /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor chmod 0660 /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor mypackage.mysubpackage.fooAIDL-service.xml <manifest version= \"1.0\" type= \"device\" > <hal format= \"aidl\" > <name> mypackage.mysubpackage.fooAIDL </name> <version> 1 </version> <fqname> ITest/default </fqname> </hal> </manifest> Agora s\u00f3 resta adicionar o servi\u00e7o no produto: emulator.mk ... PRODUCT_PACKAGES += \\ mypackage.mysubpackage.fooAIDL \\ mypackage.mysubpackage.fooAIDL-service Permiss\u00f5es Rebuildando e checando o dmesg : 10 - 08 07 : 51 : 06.674 0 0 I init : Parsing file / vendor / etc / init / mypackage . mysubpackage . fooAIDL - service . rc ... 10 - 08 07 : 51 : 10.482 0 0 E init : Could not start service 'mypackage.mysubpackage.fooAIDL-service' as part of class ' hal ': File /vendor/bin/hw/mypackage.mysubpackage.fooAIDL-service(labeled \"u:object_r:vendor_file:s0\") has incorrect label or no domain transition from u:r:init:s0 to another SELinux domain defined. Have you configured your service correctly? https://source.android.com/security/selinux/device-policy#label_new_services_and_address_denials. Note: this error shows up even in permissive mode in order to make auditing denials possible. 10 - 08 07 : 51 : 10.560 0 0 I init : processing action ( boot ) from ( / vendor / etc / init / mypackage . mysubpackage . fooAIDL - service . rc : 7 ) Para resolver esse problema, criei uma pasta: mkdir -p /device/casa/emulator/sepolicy e dentro dela os arquivos: file_contexts /vendor/bin/hw/mypackage\\.mysubpackage\\.fooAIDL-service u:object_r:hal_fooAIDL_default_exec:s0 hal_fooAIDL_default.te type hal_fooAIDL_default, domain; type hal_fooAIDL_default_exec, exec_type, vendor_file_type, file_type; init_daemon_domain(hal_fooAIDL_default); Rebuildando e checando o dmesg : 10 - 08 08 : 11 : 08.392 0 0 I init : starting service 'mypackage.mysubpackage.fooAIDL-service' ... 10 - 08 08 : 11 : 09.375 1932 1932 I mypackage . mysubpackage . fooAIDL - service : Test aidl service for fooAIDL is starting . ,, 10 - 08 08 : 11 : 09.369 1932 1932 W mypackage . mysub : type = 1400 audit ( 0.0 : 20 ): avc : denied { read } for name = \"vndbinder\" dev = \"binder\" ino = 6 scontext = u : r : hal_fooAIDL_default : s0 tcontext = u : object_r : vndbinder_device : s0 tclass = chr_file permissive = 0 10 - 08 08 : 11 : 09.369 1932 1932 W Binder : 1932_2 : type = 1400 audit ( 0.0 : 21 ): avc : denied { call } for scontext = u : r : hal_fooAIDL_default : s0 tcontext = u : r : servicemanager : s0 tclass = binder permissive = 0 10 - 08 08 : 11 : 09.378 1932 1932 F mypackage . mysubpackage . fooAIDL - service : Check failed : STATUS_OK == AServiceManager_addService ( test -> asBinder () . get (), name . c_str ()) ( STATUS_OK = 0 , AServiceManager_addService ( test -> asBinder () . get (), name . c_str ()) =- 129 ) 10 - 08 08 : 11 : 09.373 1932 1932 W Binder : 1932_2 : type = 1400 audit ( 0.0 : 22 ): avc : denied { call } for scontext = u : r : hal_fooAIDL_default : s0 tcontext = u : r : servicemanager : s0 tclass = binder permissive = 0 10 - 08 08 : 11 : 09.389 1937 1937 F DEBUG : Cmdline : / vendor / bin / hw / mypackage . mysubpackage . fooAIDL - service 10 - 08 08 : 11 : 09.389 1937 1937 F DEBUG : pid : 1932 , tid : 1932 , name : Binder : 1932_2 >>> / vendor / bin / hw / mypackage . mysubpackage . fooAIDL - service <<< 10 - 08 08 : 11 : 09.390 1937 1937 F DEBUG : #03 pc 00000000000031a9 /vendor/bin/hw/mypackage.mysubpackage.fooAIDL-service (main+889) (BuildId: fdbc2fbc6416778b0057ade844657474) 10 - 08 08 : 11 : 08.424 0 0 I init : Service 'mypackage.mysubpackage.fooAIDL-service' ( pid 1932 ) received signal 6 10 - 08 08 : 11 : 08.424 0 0 I init : Sending signal 9 to service 'mypackage.mysubpackage.fooAIDL-service' ( pid 1932 ) process group ... 10 - 08 08 : 11 : 08.425 0 0 E init : process with updatable components 'mypackage.mysubpackage.fooAIDL-service' exited 4 times in 4 minutes Para resolver, criei os seguintes arquivos: service_contexts mypackage.mysubpackage.fooAIDL.ITest/default u:object_r:fooAIDL_service:s0 service.te type fooAIDL_service, service_manager_type, vendor_service; e adicionando essas configura\u00e7\u00f5es no arquivo: hal_fooAIDL_default.te type hal_fooAIDL_default, domain; type hal_fooAIDL_default_exec, exec_type, vendor_file_type, file_type; init_daemon_domain(hal_fooAIDL_default); vndbinder_use(hal_fooAIDL_default); add_service(hal_fooAIDL_default, fooAIDL_service); Rebuildando e checando o dmesg : 10 - 08 08 : 32 : 41.525 0 0 E apexd : Native process 'mypackage.mysubpackage.fooAIDL-service' is crashing . Attempting a revert 10 - 08 08 : 32 : 46.496 0 0 I init : starting service 'mypackage.mysubpackage.fooAIDL-service' ... 10 - 08 08 : 32 : 46.622 1949 1949 I mypackage . mysubpackage . fooAIDL - service : Test aidl service for fooAIDL is starting . ,, 10 - 08 08 : 32 : 46.618 1949 1949 W Binder : 1949_2 : type = 1400 audit ( 0.0 : 15 ): avc : denied { call } for scontext = u : r : hal_fooAIDL_default : s0 tcontext = u : r : servicemanager : s0 tclass = binder permissive = 0 10 - 08 08 : 32 : 46.625 1949 1949 F mypackage . mysubpackage . fooAIDL - service : Check failed : STATUS_OK == AServiceManager_addService ( test -> asBinder () . get (), name . c_str ()) ( STATUS_OK = 0 , AServiceManager_addService ( test -> asBinder () . get (), name . c_str ()) =- 129 ) 10 - 08 08 : 32 : 46.622 1949 1949 W Binder : 1949_2 : type = 1400 audit ( 0.0 : 16 ): avc : denied { call } for scontext = u : r : hal_fooAIDL_default : s0 tcontext = u : r : servicemanager : s0 tclass = binder permissive = 0 10 - 08 08 : 32 : 46.638 1954 1954 F DEBUG : Cmdline : / vendor / bin / hw / mypackage . mysubpackage . fooAIDL - service 10 - 08 08 : 32 : 46.638 1954 1954 F DEBUG : pid : 1949 , tid : 1949 , name : Binder : 1949_2 >>> / vendor / bin / hw / mypackage . mysubpackage . fooAIDL - service <<< 10 - 08 08 : 32 : 46.639 1954 1954 F DEBUG : #03 pc 00000000000031a9 /vendor/bin/hw/mypackage.mysubpackage.fooAIDL-service (main+889) (BuildId: fdbc2fbc6416778b0057ade844657474) 10 - 08 08 : 32 : 46.527 0 0 I init : Service 'mypackage.mysubpackage.fooAIDL-service' ( pid 1949 ) received signal 6 10 - 08 08 : 32 : 46.527 0 0 I init : Sending signal 9 to service 'mypackage.mysubpackage.fooAIDL-service' ( pid 1949 ) process group ... 10 - 08 08 : 32 : 46.533 0 0 E init : process with updatable components 'mypackage.mysubpackage.fooAIDL-service' exited 4 times in 4 minutes Para resolver, foi adicionado a seguinte configura\u00e7\u00e3o ao arquivo: hal_fooAIDL_default.te type hal_fooAIDL_default, domain; type hal_fooAIDL_default_exec, exec_type, vendor_file_type, file_type; init_daemon_domain(hal_fooAIDL_default); vndbinder_use(hal_fooAIDL_default); add_service(hal_fooAIDL_default, fooAIDL_service); allow hal_fooAIDL_service servicemanager:binder { call transfer }; Rebuildando e checando o dmesg : 10 - 08 08 : 47 : 08.591 0 0 I init : Parsing file / vendor / etc / init / mypackage . mysubpackage . fooAIDL - service . rc ... 10 - 08 08 : 47 : 13.008 0 0 I init : starting service 'mypackage.mysubpackage.fooAIDL-service' ... 10 - 08 08 : 47 : 13.054 0 0 I init : processing action ( boot ) from ( / vendor / etc / init / mypackage . mysubpackage . fooAIDL - service . rc : 7 ) 10 - 08 08 : 47 : 13.049 369 369 I mypackage . mysubpackage . fooAIDL - service : Test aidl service for fooAIDL is starting . ,, 10 - 08 08 : 47 : 13.049 170 170 I servicemanager : Found mypackage . mysubpackage . fooAIDL . ITest / default in device VINTF manifest . 10 - 08 08 : 47 : 13.049 369 369 I mypackage . mysubpackage . fooAIDL - service : Initialized fooAIDL cpu At\u00e9 aqui, tudo certo \ud83d\ude04. Testando Para testar a HAL, criei a pasta: mkdir -p /device/casa/emulator/interfaces/foo/aidl/default/halTest e dentro dela os seguintes arquivos: HalTest.cpp #include <aidl/mypackage/mysubpackage/fooAIDL/ITest.h> #include <iostream> #include <string> #include <android/binder_manager.h> using :: aidl :: mypackage :: mysubpackage :: fooAIDL :: ITest ; int main ( int argc , char * argv []) { std :: shared_ptr < ITest > mHal ; std :: string a ; bool c ; if ( argc != 2 ) { std :: cout << \"USAGE ./cpu_client <conservative|powersave|performance|schedutil> \\n \" ; exit ( 0 ); } AIBinder * binder = AServiceManager_waitForService ( \"mypackage.mysubpackage.fooAIDL.ITest/default\" ); if ( binder == nullptr ){ std :: cout << \"Failed to get cpu service \\n \" ; exit ( -1 ); } mHal = ITest :: fromBinder ( ndk :: SpAIBinder ( binder )); mHal -> getTest ( & a ); std :: cout << \"getScalingGovernor:\" << a << std :: endl ; mHal -> setTest ( argv [ 1 ], & c ); std :: cout << \"setScalingGovernor:\" << c << std :: endl ; mHal -> getTest ( & a ); std :: cout << \"getScalingGovernor:\" << a << std :: endl ; return 0 ; } Android.bp cc_binary { name: \"foo_AIDL_tester\", vendor: true, relative_install_path: \"hw\", srcs: [\"HalTest.cpp\"], shared_libs: [ \"libbase\", \"liblog\", \"libhardware\", \"libbinder_ndk\", \"libbinder\", \"libutils\", \"mypackage.mysubpackage.fooAIDL-V1-ndk_platform\" ], } Rebuildando utilizando o comando: adb root adb shell \"/vendor/bin/hw/foo_AIDL_tester performance\" o programa deve retorna a seguinte mensagem: getScalingGovernor:schedutil setScalingGovernor:0 getScalingGovernor:schedutil N\u00e3o houve altera\u00e7\u00e3o para performance , continuou em schedutil . Checando o dmesg : 10 - 09 06 : 38 : 08.315 370 383 I mypackage . mysubpackage . fooAIDL - service : Test AIDL :: getTest data = ( schedutil 10 - 09 06 : 38 : 08.315 370 383 I mypackage . mysubpackage . fooAIDL - service : ) 10 - 09 06 : 38 : 08.316 370 383 I mypackage . mysubpackage . fooAIDL - service : Test AIDL :: setTest data = ( performance ) 10 - 09 06 : 38 : 08.311 370 370 W Binder : 370_1 : type = 1400 audit ( 0.0 : 6 ): avc : denied { write } for name = \"scaling_governor\" dev = \"sysfs\" ino = 19629 scontext = u : r : hal_fooAIDL_default : s0 tcontext = u : object_r : sysfs_devices_system_cpu : s0 tclass = file permissive = 0 10 - 09 06 : 38 : 08.317 370 383 I mypackage . mysubpackage . fooAIDL - service : Test AIDL :: getTest data = ( schedutil 10 - 09 06 : 38 : 08.317 370 383 I mypackage . mysubpackage . fooAIDL - service : ) Para resolver isso, devemos adicionar ao arquivo: hal_fooAIDL_default.te type hal_fooAIDL_default, domain; type hal_fooAIDL_default_exec, exec_type, vendor_file_type, file_type; init_daemon_domain(hal_fooAIDL_default); vndbinder_use(hal_fooAIDL_default); add_service(hal_fooAIDL_default, fooAIDL_service); allow hal_fooAIDL_service servicemanager:binder { call transfer }; allow hal_fooAIDL_default sysfs_devices_system_cpu:file write; Rebuildando e executando o comando: adb root adb shell \"/vendor/bin/hw/foo_AIDL_tester performance\" O programa deve retornar a seguinte mensagem: getScalingGovernor:schedutil setScalingGovernor:1 getScalingGovernor:performance Agora houve a altera\u00e7\u00e3o de schedutil \u27a1\ufe0f performance . Conclus\u00e3o Implementar a AIDL \u00e9 relativamente mais simples que a HIDL. Durante a implementa\u00e7\u00e3o, percebi que os m\u00e9todos implementados que sobrep\u00f5em os m\u00e9todos virtuais retornam um valor para o binder . Por isso, se quisermos ter alguma informa\u00e7\u00e3o externada, \u00e9 preciso passar algum ponteiro para dentro do m\u00e9todo, adicionar as informa\u00e7\u00f5es relevantes e depois acessa-lo externamente ao m\u00e9todo. Como ocorre no arquivo HalTest.cpp , para as vari\u00e1veis a e c .","title":"Implementando a AIDL"},{"location":"Android/HAL/AIDL/#implementando-a-aidl","text":"Image by methodshop from Pixabay Baseado no curso: Android 12 Internals material, labs and discussion","title":"Implementando a AIDL"},{"location":"Android/HAL/AIDL/#introducao","text":"A partir do Android 12, novas Hardware Abstraction Layer (HAL) passam a ser obrigatoriamente implementadas utilizando Android Interface Definition Language (AIDL). Por isso, criei esse post.","title":"Introdu\u00e7\u00e3o"},{"location":"Android/HAL/AIDL/#implementacao","text":"Vou tentar dividir em alguns t\u00f3picos para facilitar.","title":"Implementa\u00e7\u00e3o"},{"location":"Android/HAL/AIDL/#hal","text":"Na pasta raiz do AOSP , criei o seguinte caminho: mkdir -p device/casa/emulator/interfaces/foo/aidl/ Dentro da pasta, criei o seguinte arquivo: Android.bp aidl_interface { name: \"mypackage.mysubpackage.fooAIDL\", vendor: true, srcs: [\"mypackage/mysubpackage/fooAIDL/*.aidl\"], stability: \"vintf\", owner: \"CASA\", backend: { cpp: { enabled: true, }, java: { sdk_version: \"module_current\", }, }, } ainda dentro da pasta, criei o seguinte caminho: mkdir -p mypackage/mysubpackage/fooAIDL/ com o seguinte arquivo: ITest.aidl package mypackage.mysubpackage.fooAIDL; @VintfStability interface ITest { String getTest(); boolean setTest(in String param); } O resultado foi esse: device/casa/emulator/interfaces/foo/aidl \u251c\u2500\u2500 Android.bp \u2514\u2500\u2500 mypackage \u2514\u2500\u2500 mysubpackage \u2514\u2500\u2500 fooAIDL \u2514\u2500\u2500 ITest.aidl Agora no arquivo do produto, no meu caso: emulator.mk ... PRODUCT_PACKAGES += \\ mypackage.mysubpackage.fooAIDL \\ Na pasta raiz do AOSP, digite: m mypackage.mysubpackage.fooAIDL-update-api Esse comando vai gerar a pasta aidl_api : device/casa/emulator/interfaces/foo/aidl \u251c\u2500\u2500 aidl_api \u2502 \u2514\u2500\u2500 mypackage.mysubpackage.fooAIDL \u2502 \u2514\u2500\u2500 current \u2502 \u2514\u2500\u2500 mypackage \u2502 \u2514\u2500\u2500 mysubpackage \u2502 \u2514\u2500\u2500 fooAIDL \u2502 \u2514\u2500\u2500 ITest.aidl \u251c\u2500\u2500 Android.bp \u2514\u2500\u2500 mypackage \u2514\u2500\u2500 mysubpackage \u2514\u2500\u2500 fooAIDL \u2514\u2500\u2500 ITest.aidl Esse comando faz uma esp\u00e9cie de versionamento da AIDL. Agora dentro da pasta device/casa/emulator/interfaces/foo/aidl , digite o comando: mm Ela ir\u00e1 gerar as classes necess\u00e1rias dentro da pasta : out/soong/.intermediates/device/casa/emulator/interfaces/foo/aidl \u251c\u2500\u2500 mypackage.mysubpackage.fooAIDL-api \u251c\u2500\u2500 mypackage.mysubpackage.fooAIDL-V1-cpp \u251c\u2500\u2500 mypackage.mysubpackage.fooAIDL-V1-cpp-source \u251c\u2500\u2500 mypackage.mysubpackage.fooAIDL-V1-java \u251c\u2500\u2500 mypackage.mysubpackage.fooAIDL-V1-java-source \u251c\u2500\u2500 mypackage.mysubpackage.fooAIDL-V1-ndk \u251c\u2500\u2500 mypackage.mysubpackage.fooAIDL-V1-ndk_platform \u251c\u2500\u2500 mypackage.mysubpackage.fooAIDL-V1-ndk_platform-source \u2514\u2500\u2500 mypackage.mysubpackage.fooAIDL-V1-ndk-source","title":"HAL"},{"location":"Android/HAL/AIDL/#servico","text":"Criei a pasta device/casa/emulator/interfaces/foo/aidl/default/ , e dentro dela os arquivos: Test.h #pragma once // Mesmo caminho ap\u00f3s: // mypackage.mysubpackage.fooAIDL-V1-ndk_platform-source/gen/include/ // dentro da pasta : // out/soong/.intermediates/device/casa/emulator/interfaces/foo/aidl #include <aidl/mypackage/mysubpackage/fooAIDL/BnTest.h> namespace aidl :: mypackage :: mysubpackage :: fooAIDL { class Test : public BnTest { public : ndk :: ScopedAStatus getTest ( std :: string * _aidl_return ) override ; ndk :: ScopedAStatus setTest ( const std :: string & in_param , bool * _aidl_return ) override ; }; } // namespace aidl::mypackage::mysubpackage::fooAIDL Test.cpp #include \"Test.h\" #include <utils/Log.h> #include <sys/stat.h> namespace aidl :: mypackage :: mysubpackage :: fooAIDL { // conservative|powersave|performance|schedutil static const char SCALING_GOVERNOR [] = \\ \"/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor\" ; static int write_value ( const char * file , const char * value ) { int to_write , written , ret , fd ; fd = TEMP_FAILURE_RETRY ( open ( file , O_WRONLY )); if ( fd < 0 ) { return -1 ; } to_write = strlen ( value ) + 1 ; written = TEMP_FAILURE_RETRY ( write ( fd , value , to_write )); if ( written == -1 ) { ret = -2 ; } else if ( written != to_write ) { ret = -3 ; } else { ret = 0 ; } errno = 0 ; close ( fd ); return ret ; } ndk :: ScopedAStatus Test::getTest ( std :: string * _aidl_return ) { char str [ 20 ]; int fd ; ssize_t ret = 0 ; struct stat info ; void * data = NULL ; size_t size ; // If open returns error code EINTR, retry again until error code // is not a temporary failure fd = TEMP_FAILURE_RETRY ( open ( SCALING_GOVERNOR , O_RDONLY )); if ( fd < 0 ) { ndk :: ScopedAStatus :: fromServiceSpecificError ( -1 ); } fstat ( fd , & info ); size = info . st_size ; data = malloc ( size ); if ( data == NULL ) { * _aidl_return = \"error can't malloc\" ; goto exit ; } ret = read ( fd , data , size ); if ( ret < 0 ) { * _aidl_return = \"error reading fd\" ; goto exit ; } snprintf ( str , sizeof ( str ), \"%s\" , ( const unsigned char * ) data ); ALOGI ( \"Test AIDL::getTest data=(%s)\" , str ); * _aidl_return = str ; exit : close ( fd ); free ( data ); return ndk :: ScopedAStatus :: ok (); } ndk :: ScopedAStatus Test::setTest ( const std :: string & in_param , bool * _aidl_return ) { ALOGI ( \"Test AIDL::setTest data=(%s)\" , in_param . c_str ()); * _aidl_return = write_value ( SCALING_GOVERNOR , in_param . c_str ()) == 0 ; return ndk :: ScopedAStatus :: ok (); } } // namespace aidl::vendor::eightman::cpu service.cpp #define LOG_TAG \"mypackage.mysubpackage.fooAIDL-service\" #include <android-base/logging.h> #include <android/binder_process.h> #include <binder/ProcessState.h> #include <android/binder_manager.h> #include <binder/IServiceManager.h> #include \"Test.h\" using aidl :: mypackage :: mysubpackage :: fooAIDL :: Test ; using std :: string_literals :: operator \"\" s ; int main () { // Enable vndbinder to allow vendor-to-vendor binder calls. android :: ProcessState :: initWithDriver ( \"/dev/vndbinder\" ); ABinderProcess_startThreadPool (); LOG ( INFO ) << \"Test aidl service for fooAIDL is starting.,,\" ; std :: shared_ptr < Test > test = ndk :: SharedRefBase :: make < Test > (); const std :: string name = Test :: descriptor + \"/default\" s ; CHECK_EQ ( STATUS_OK , AServiceManager_addService ( test -> asBinder (). get (), name . c_str ())); LOG ( INFO ) << \"Initialized fooAIDL cpu\" ; ABinderProcess_joinThreadPool (); return EXIT_FAILURE ; // should not reach } Android.bp cc_binary { name: \"mypackage.mysubpackage.fooAIDL-service\", vendor: true, relative_install_path: \"hw\", init_rc: [\"mypackage.mysubpackage.fooAIDL-service.rc\"], vintf_fragments: [\"mypackage.mysubpackage.fooAIDL-service.xml\"], srcs: [ \"service.cpp\", \"Test.cpp\" ], cflags: [ \"-Wall\", \"-Werror\", ], shared_libs: [ \"libbase\", \"liblog\", \"libhardware\", \"libbinder_ndk\", \"libbinder\", \"libutils\", \"mypackage.mysubpackage.fooAIDL-V1-ndk_platform\", ], } mypackage.mysubpackage.fooAIDL-service.rc service mypackage.mysubpackage.fooAIDL-service /vendor/bin/hw/mypackage.mysubpackage.fooAIDL-service interface aidl mypackage.mysubpackage.fooAIDL-service.ITest/default class hal user system group system on boot chown system system /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor chmod 0660 /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor mypackage.mysubpackage.fooAIDL-service.xml <manifest version= \"1.0\" type= \"device\" > <hal format= \"aidl\" > <name> mypackage.mysubpackage.fooAIDL </name> <version> 1 </version> <fqname> ITest/default </fqname> </hal> </manifest> Agora s\u00f3 resta adicionar o servi\u00e7o no produto: emulator.mk ... PRODUCT_PACKAGES += \\ mypackage.mysubpackage.fooAIDL \\ mypackage.mysubpackage.fooAIDL-service","title":"Servi\u00e7o"},{"location":"Android/HAL/AIDL/#permissoes","text":"Rebuildando e checando o dmesg : 10 - 08 07 : 51 : 06.674 0 0 I init : Parsing file / vendor / etc / init / mypackage . mysubpackage . fooAIDL - service . rc ... 10 - 08 07 : 51 : 10.482 0 0 E init : Could not start service 'mypackage.mysubpackage.fooAIDL-service' as part of class ' hal ': File /vendor/bin/hw/mypackage.mysubpackage.fooAIDL-service(labeled \"u:object_r:vendor_file:s0\") has incorrect label or no domain transition from u:r:init:s0 to another SELinux domain defined. Have you configured your service correctly? https://source.android.com/security/selinux/device-policy#label_new_services_and_address_denials. Note: this error shows up even in permissive mode in order to make auditing denials possible. 10 - 08 07 : 51 : 10.560 0 0 I init : processing action ( boot ) from ( / vendor / etc / init / mypackage . mysubpackage . fooAIDL - service . rc : 7 ) Para resolver esse problema, criei uma pasta: mkdir -p /device/casa/emulator/sepolicy e dentro dela os arquivos: file_contexts /vendor/bin/hw/mypackage\\.mysubpackage\\.fooAIDL-service u:object_r:hal_fooAIDL_default_exec:s0 hal_fooAIDL_default.te type hal_fooAIDL_default, domain; type hal_fooAIDL_default_exec, exec_type, vendor_file_type, file_type; init_daemon_domain(hal_fooAIDL_default); Rebuildando e checando o dmesg : 10 - 08 08 : 11 : 08.392 0 0 I init : starting service 'mypackage.mysubpackage.fooAIDL-service' ... 10 - 08 08 : 11 : 09.375 1932 1932 I mypackage . mysubpackage . fooAIDL - service : Test aidl service for fooAIDL is starting . ,, 10 - 08 08 : 11 : 09.369 1932 1932 W mypackage . mysub : type = 1400 audit ( 0.0 : 20 ): avc : denied { read } for name = \"vndbinder\" dev = \"binder\" ino = 6 scontext = u : r : hal_fooAIDL_default : s0 tcontext = u : object_r : vndbinder_device : s0 tclass = chr_file permissive = 0 10 - 08 08 : 11 : 09.369 1932 1932 W Binder : 1932_2 : type = 1400 audit ( 0.0 : 21 ): avc : denied { call } for scontext = u : r : hal_fooAIDL_default : s0 tcontext = u : r : servicemanager : s0 tclass = binder permissive = 0 10 - 08 08 : 11 : 09.378 1932 1932 F mypackage . mysubpackage . fooAIDL - service : Check failed : STATUS_OK == AServiceManager_addService ( test -> asBinder () . get (), name . c_str ()) ( STATUS_OK = 0 , AServiceManager_addService ( test -> asBinder () . get (), name . c_str ()) =- 129 ) 10 - 08 08 : 11 : 09.373 1932 1932 W Binder : 1932_2 : type = 1400 audit ( 0.0 : 22 ): avc : denied { call } for scontext = u : r : hal_fooAIDL_default : s0 tcontext = u : r : servicemanager : s0 tclass = binder permissive = 0 10 - 08 08 : 11 : 09.389 1937 1937 F DEBUG : Cmdline : / vendor / bin / hw / mypackage . mysubpackage . fooAIDL - service 10 - 08 08 : 11 : 09.389 1937 1937 F DEBUG : pid : 1932 , tid : 1932 , name : Binder : 1932_2 >>> / vendor / bin / hw / mypackage . mysubpackage . fooAIDL - service <<< 10 - 08 08 : 11 : 09.390 1937 1937 F DEBUG : #03 pc 00000000000031a9 /vendor/bin/hw/mypackage.mysubpackage.fooAIDL-service (main+889) (BuildId: fdbc2fbc6416778b0057ade844657474) 10 - 08 08 : 11 : 08.424 0 0 I init : Service 'mypackage.mysubpackage.fooAIDL-service' ( pid 1932 ) received signal 6 10 - 08 08 : 11 : 08.424 0 0 I init : Sending signal 9 to service 'mypackage.mysubpackage.fooAIDL-service' ( pid 1932 ) process group ... 10 - 08 08 : 11 : 08.425 0 0 E init : process with updatable components 'mypackage.mysubpackage.fooAIDL-service' exited 4 times in 4 minutes Para resolver, criei os seguintes arquivos: service_contexts mypackage.mysubpackage.fooAIDL.ITest/default u:object_r:fooAIDL_service:s0 service.te type fooAIDL_service, service_manager_type, vendor_service; e adicionando essas configura\u00e7\u00f5es no arquivo: hal_fooAIDL_default.te type hal_fooAIDL_default, domain; type hal_fooAIDL_default_exec, exec_type, vendor_file_type, file_type; init_daemon_domain(hal_fooAIDL_default); vndbinder_use(hal_fooAIDL_default); add_service(hal_fooAIDL_default, fooAIDL_service); Rebuildando e checando o dmesg : 10 - 08 08 : 32 : 41.525 0 0 E apexd : Native process 'mypackage.mysubpackage.fooAIDL-service' is crashing . Attempting a revert 10 - 08 08 : 32 : 46.496 0 0 I init : starting service 'mypackage.mysubpackage.fooAIDL-service' ... 10 - 08 08 : 32 : 46.622 1949 1949 I mypackage . mysubpackage . fooAIDL - service : Test aidl service for fooAIDL is starting . ,, 10 - 08 08 : 32 : 46.618 1949 1949 W Binder : 1949_2 : type = 1400 audit ( 0.0 : 15 ): avc : denied { call } for scontext = u : r : hal_fooAIDL_default : s0 tcontext = u : r : servicemanager : s0 tclass = binder permissive = 0 10 - 08 08 : 32 : 46.625 1949 1949 F mypackage . mysubpackage . fooAIDL - service : Check failed : STATUS_OK == AServiceManager_addService ( test -> asBinder () . get (), name . c_str ()) ( STATUS_OK = 0 , AServiceManager_addService ( test -> asBinder () . get (), name . c_str ()) =- 129 ) 10 - 08 08 : 32 : 46.622 1949 1949 W Binder : 1949_2 : type = 1400 audit ( 0.0 : 16 ): avc : denied { call } for scontext = u : r : hal_fooAIDL_default : s0 tcontext = u : r : servicemanager : s0 tclass = binder permissive = 0 10 - 08 08 : 32 : 46.638 1954 1954 F DEBUG : Cmdline : / vendor / bin / hw / mypackage . mysubpackage . fooAIDL - service 10 - 08 08 : 32 : 46.638 1954 1954 F DEBUG : pid : 1949 , tid : 1949 , name : Binder : 1949_2 >>> / vendor / bin / hw / mypackage . mysubpackage . fooAIDL - service <<< 10 - 08 08 : 32 : 46.639 1954 1954 F DEBUG : #03 pc 00000000000031a9 /vendor/bin/hw/mypackage.mysubpackage.fooAIDL-service (main+889) (BuildId: fdbc2fbc6416778b0057ade844657474) 10 - 08 08 : 32 : 46.527 0 0 I init : Service 'mypackage.mysubpackage.fooAIDL-service' ( pid 1949 ) received signal 6 10 - 08 08 : 32 : 46.527 0 0 I init : Sending signal 9 to service 'mypackage.mysubpackage.fooAIDL-service' ( pid 1949 ) process group ... 10 - 08 08 : 32 : 46.533 0 0 E init : process with updatable components 'mypackage.mysubpackage.fooAIDL-service' exited 4 times in 4 minutes Para resolver, foi adicionado a seguinte configura\u00e7\u00e3o ao arquivo: hal_fooAIDL_default.te type hal_fooAIDL_default, domain; type hal_fooAIDL_default_exec, exec_type, vendor_file_type, file_type; init_daemon_domain(hal_fooAIDL_default); vndbinder_use(hal_fooAIDL_default); add_service(hal_fooAIDL_default, fooAIDL_service); allow hal_fooAIDL_service servicemanager:binder { call transfer }; Rebuildando e checando o dmesg : 10 - 08 08 : 47 : 08.591 0 0 I init : Parsing file / vendor / etc / init / mypackage . mysubpackage . fooAIDL - service . rc ... 10 - 08 08 : 47 : 13.008 0 0 I init : starting service 'mypackage.mysubpackage.fooAIDL-service' ... 10 - 08 08 : 47 : 13.054 0 0 I init : processing action ( boot ) from ( / vendor / etc / init / mypackage . mysubpackage . fooAIDL - service . rc : 7 ) 10 - 08 08 : 47 : 13.049 369 369 I mypackage . mysubpackage . fooAIDL - service : Test aidl service for fooAIDL is starting . ,, 10 - 08 08 : 47 : 13.049 170 170 I servicemanager : Found mypackage . mysubpackage . fooAIDL . ITest / default in device VINTF manifest . 10 - 08 08 : 47 : 13.049 369 369 I mypackage . mysubpackage . fooAIDL - service : Initialized fooAIDL cpu At\u00e9 aqui, tudo certo \ud83d\ude04.","title":"Permiss\u00f5es"},{"location":"Android/HAL/AIDL/#testando","text":"Para testar a HAL, criei a pasta: mkdir -p /device/casa/emulator/interfaces/foo/aidl/default/halTest e dentro dela os seguintes arquivos: HalTest.cpp #include <aidl/mypackage/mysubpackage/fooAIDL/ITest.h> #include <iostream> #include <string> #include <android/binder_manager.h> using :: aidl :: mypackage :: mysubpackage :: fooAIDL :: ITest ; int main ( int argc , char * argv []) { std :: shared_ptr < ITest > mHal ; std :: string a ; bool c ; if ( argc != 2 ) { std :: cout << \"USAGE ./cpu_client <conservative|powersave|performance|schedutil> \\n \" ; exit ( 0 ); } AIBinder * binder = AServiceManager_waitForService ( \"mypackage.mysubpackage.fooAIDL.ITest/default\" ); if ( binder == nullptr ){ std :: cout << \"Failed to get cpu service \\n \" ; exit ( -1 ); } mHal = ITest :: fromBinder ( ndk :: SpAIBinder ( binder )); mHal -> getTest ( & a ); std :: cout << \"getScalingGovernor:\" << a << std :: endl ; mHal -> setTest ( argv [ 1 ], & c ); std :: cout << \"setScalingGovernor:\" << c << std :: endl ; mHal -> getTest ( & a ); std :: cout << \"getScalingGovernor:\" << a << std :: endl ; return 0 ; } Android.bp cc_binary { name: \"foo_AIDL_tester\", vendor: true, relative_install_path: \"hw\", srcs: [\"HalTest.cpp\"], shared_libs: [ \"libbase\", \"liblog\", \"libhardware\", \"libbinder_ndk\", \"libbinder\", \"libutils\", \"mypackage.mysubpackage.fooAIDL-V1-ndk_platform\" ], } Rebuildando utilizando o comando: adb root adb shell \"/vendor/bin/hw/foo_AIDL_tester performance\" o programa deve retorna a seguinte mensagem: getScalingGovernor:schedutil setScalingGovernor:0 getScalingGovernor:schedutil N\u00e3o houve altera\u00e7\u00e3o para performance , continuou em schedutil . Checando o dmesg : 10 - 09 06 : 38 : 08.315 370 383 I mypackage . mysubpackage . fooAIDL - service : Test AIDL :: getTest data = ( schedutil 10 - 09 06 : 38 : 08.315 370 383 I mypackage . mysubpackage . fooAIDL - service : ) 10 - 09 06 : 38 : 08.316 370 383 I mypackage . mysubpackage . fooAIDL - service : Test AIDL :: setTest data = ( performance ) 10 - 09 06 : 38 : 08.311 370 370 W Binder : 370_1 : type = 1400 audit ( 0.0 : 6 ): avc : denied { write } for name = \"scaling_governor\" dev = \"sysfs\" ino = 19629 scontext = u : r : hal_fooAIDL_default : s0 tcontext = u : object_r : sysfs_devices_system_cpu : s0 tclass = file permissive = 0 10 - 09 06 : 38 : 08.317 370 383 I mypackage . mysubpackage . fooAIDL - service : Test AIDL :: getTest data = ( schedutil 10 - 09 06 : 38 : 08.317 370 383 I mypackage . mysubpackage . fooAIDL - service : ) Para resolver isso, devemos adicionar ao arquivo: hal_fooAIDL_default.te type hal_fooAIDL_default, domain; type hal_fooAIDL_default_exec, exec_type, vendor_file_type, file_type; init_daemon_domain(hal_fooAIDL_default); vndbinder_use(hal_fooAIDL_default); add_service(hal_fooAIDL_default, fooAIDL_service); allow hal_fooAIDL_service servicemanager:binder { call transfer }; allow hal_fooAIDL_default sysfs_devices_system_cpu:file write; Rebuildando e executando o comando: adb root adb shell \"/vendor/bin/hw/foo_AIDL_tester performance\" O programa deve retornar a seguinte mensagem: getScalingGovernor:schedutil setScalingGovernor:1 getScalingGovernor:performance Agora houve a altera\u00e7\u00e3o de schedutil \u27a1\ufe0f performance .","title":"Testando"},{"location":"Android/HAL/AIDL/#conclusao","text":"Implementar a AIDL \u00e9 relativamente mais simples que a HIDL. Durante a implementa\u00e7\u00e3o, percebi que os m\u00e9todos implementados que sobrep\u00f5em os m\u00e9todos virtuais retornam um valor para o binder . Por isso, se quisermos ter alguma informa\u00e7\u00e3o externada, \u00e9 preciso passar algum ponteiro para dentro do m\u00e9todo, adicionar as informa\u00e7\u00f5es relevantes e depois acessa-lo externamente ao m\u00e9todo. Como ocorre no arquivo HalTest.cpp , para as vari\u00e1veis a e c .","title":"Conclus\u00e3o"},{"location":"Android/HAL/HIDL/","text":"Implementando a HIDL Image by methodshop from Pixabay Baseado no curso: Android 12 Internals material, labs and discussion Introdu\u00e7\u00e3o Umas das coisas mais dif\u00edceis que eu encontrei durante o processo de entender o sistema Android, foi sobre Hardware Abstraction Layer (HAL). Que \u00e9 a forma de conectar o framework do Android com a parte do hardware . Atualmente, a forma mais disseminada de fazer essa conex\u00e3o \u00e9 utilizando a HAL Interface Definition Language (HIDL). Que irei abordar nesse post. Defini\u00e7\u00f5es Quando um aplicativo A precisa se comunicar com um aplicativo B , existem duas formas grosseiramente de se fazer isso. A primeira \u00e9 passando diretamente a regi\u00e3o de mem\u00f3ria do aplicativo A para o aplicativo B . A segunda \u00e9 utilizando um mecanismo que gerencie essa troca de informa\u00e7\u00e3o entre o aplicativo A e o aplicativo B . Essa comunica\u00e7\u00e3o entre aplicativos \u00e9 conhecida como inter-process communication (IPC), que utilizam proxy e stub para fazer a comunica\u00e7\u00e3o, como uma esp\u00e9cie de cliente-servidor. No Android, esse mecanismo \u00e9 o Binder e o \"protocolo\" que esse mecanismo utiliza \u00e9 a HAL, que por sua vez pode ser implementada com a HIDL. Nesse sistema os equivalentes do proxy e stub s\u00e3o o Binder Proxy (Bp) e Binder Native (Bn). Dessa forma, as siglas Bp e Bn ir\u00e3o aparecer constantemente no processo de implementa\u00e7\u00e3o da HAL do Android. N\u00e3o confundir com a extens\u00e3o .Bp (Blueprint) que faz refer\u00eancia aos arquivos de build do Android. Implementa\u00e7\u00e3o Vou tentar dividir em alguns t\u00f3picos para facilitar. HAL Na pasta raiz do AOSP , criei o seguinte caminho: mkdir - p device / casa / emulator / interfaces / foo / 1.0 A pasta foo/ \u00e9 o nome da HAL e a pasta 1.0/ seria a vers\u00e3o dessa HAL. Dentro da pasta 1.0/ criei os arquivos: Android.bp hidl_interface { name: \"mypackage.mysubpackage.foo@1.0\", root: \"mypackage.mysubpackage\", srcs: [ \"ITest.hal\", ], interfaces: [ \"android.hidl.base@1.0\", ], gen_java: true, product_specific: true, } ITest.hal package mypackage.mysubpackage.foo@1.0; interface ITest { getTest() generates (string res); setTest(string param) generates (bool res); }; Algumas coisas que podem causar confus\u00e3o e geralmente d\u00e3o problema de compila\u00e7\u00e3o s\u00e3o os nomes. Nesse caso, no arquivo Android.bp a tag root \u00e9 um prefixo para a tag name ( mypackage.mysubpackage ), que \u00e9 seguida do nome da HAL (foo) com sua vers\u00e3o (1.0). No arquivo ITest.hal , o package deve ser o mesmo nome da tag name do Android.bp . Agora dentro da pasta interfaces/ ( device/casa/emulator/interfaces ), criei outro arquivo: Android.bp hidl_package_root { name: \"mypackage.mysubpackage\", path: \"device/casa/emulator/interfaces\", } A tag name desse arquivo \u00e9 igual ao da tag root do outro arquivo Android.bp . A tag path \u00e9 o caminho relativo da pasta raiz do AOSP at\u00e9 a pasta interfaces . Finalmente, dentro da pasta device/casa/emulator/interfaces/foo/1.0 o seguinte comando foi usado: mm -j8 Ele compila a HAL foo. Ao final do processo uma mensagem similar deve aparecer: ============================================ [100% 149/149] Copy: out/target/product/emulator/data/nativetest/product/mypackage.mysubpackage.foo@1.0-adapter/mypackage.mysubpackage.foo@1.0.so.toc build completed successfully (7 seconds) #### Os arquivos gerados est\u00e3o dentro do diret\u00f3rio: out/soong/.intermediates/device/casa/emulator/interfaces/foo/1.0 No curso Android 12 Internals \u00e9 dado mais detalhes sobre alguns arquivos dentro dessa pasta. Por fim, \u00e9 necess\u00e1rio adicionar a HAL foo ao final do produto, no meu caso, emulator.mk ( device/casa/emulator/emulator.mk ), da seguinte forma: emulator.mk ... PRODUCT_PACKAGES += \\ mypackage.mysubpackage.foo@1.0 Agora \u00e9 s\u00f3 rebuildar o AOSP m -j8 . Ap\u00f3s o build terminar, na pasta do produto dentro da pasta out/ \u00e9 poss\u00edvel ver onde a HAL foi adicionada: ./vendor/lib/mypackage.mysubpackage.foo@1.0.so ./vendor/lib/mypackage.mysubpackage.foo@1.0-adapter-helper.so ./vendor/lib64/mypackage.mysubpackage.foo@1.0.so ./vendor/lib64/mypackage.mysubpackage.foo@1.0-adapter-helper.so ./product/lib/mypackage.mysubpackage.foo@1.0.so ./product/lib/mypackage.mysubpackage.foo@1.0-adapter-helper.so ./product/lib64/mypackage.mysubpackage.foo@1.0.so ./product/lib64/mypackage.mysubpackage.foo@1.0-adapter-helper.so ./product/framework/mypackage.mysubpackage.foo-V1.0-java.jar ./product/framework/mypackage.mysubpackage.foo-V1.0-java-shallow.jar Ser\u00e3o adicionados na imagem vendor.img e product.img . Servi\u00e7o Antes de criar o servi\u00e7o, precisamos implementar o que ser\u00e1 processado dentro das duas fun\u00e7\u00f5es que definidas no ITest.hal . Quando compilamos a HAL no passo anterior, o Android criou 2 m\u00e9todos virtuais dentro do arquivo: out/soong/.intermediates/device/casa/emulator/interfaces/foo/1.0/mypackage.mysubpackage.foo@1.0_genc++_headers/gen/mypackage/mysubpackage/foo/1.0/ITest.h Os m\u00e9todos s\u00e3o: ITest.h /** * Return callback for getTest */ using getTest_cb = std :: function < void ( const :: android :: hardware :: hidl_string & res ) > ; virtual :: android :: hardware :: Return < void > getTest ( getTest_cb _hidl_cb ) = 0 ; virtual :: android :: hardware :: Return < bool > setTest ( const :: android :: hardware :: hidl_string & param ) = 0 ; Para fazer a implementa\u00e7\u00e3o desses m\u00e9todos, criei dentro da pasta device/casa/emulator/interfaces/foo/1.0/default os arquivos: Test.h #ifndef MYPACKAGE_MYSUBPACKAGE_FOO_V1_0_ITEST_H #define MYPACKAGE_MYSUBPACKAGE_FOO_V1_0_ITEST_H // Mesmo caminho ap\u00f3s: // mypackage.mysubpackage.foo@1.0_genc++_headers/gen/ // dentro da pasta out/ #include <mypackage/mysubpackage/foo/1.0/ITest.h> namespace mypackage { namespace mysubpackage { namespace foo { namespace V1_0 { namespace implementation { using :: android :: hardware :: hidl_string ; // const hidl_string using :: android :: hardware :: Return ; // Return<void> using :: android :: hardware :: Void ; // return Void(); using :: mypackage :: mysubpackage :: foo :: V1_0 :: ITest ; // public ITest class Test : public ITest { public : Return < bool > setTest ( const hidl_string & param ) override ; Return < void > getTest ( getTest_cb _hidl_c ) override ; }; extern \"C\" ITest * HIDL_FETCH_ITest ( const char * name ); } // namespace implementation } // namespace V1_0 } // namespace foo } // namespace mysubpackage } // namespace mypackage #endif Test.cpp #include \"Test.h\" #include <utils/Log.h> //ALOGI e ALOGE #include <sys/stat.h> // struct stat info namespace mypackage { namespace mysubpackage { namespace foo { namespace V1_0 { namespace implementation { // conservative|powersave|performance|schedutil static const char SCALING_GOVERNOR [] = \"/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor\" ; static int write_value ( const char * file , const char * value ) { int to_write , written , ret , fd ; fd = TEMP_FAILURE_RETRY ( open ( file , O_WRONLY )); if ( fd < 0 ) { ALOGE ( \"write_value failed to open\" ); return -1 ; } to_write = strlen ( value ) + 1 ; written = TEMP_FAILURE_RETRY ( write ( fd , value , to_write )); if ( written == -1 ) { ret = -2 ; } else if ( written != to_write ) { ret = -3 ; } else { ret = 0 ; } errno = 0 ; close ( fd ); return ret ; } Return < bool > Test :: setTest ( const hidl_string & param ) { ALOGI ( \"Test::setTest data=(%s)\" , param . c_str ()); return write_value ( SCALING_GOVERNOR , param . c_str ()) == 0 ; } Return < void > Test :: getTest ( getTest_cb _hidl_cb ) { char str [ 20 ]; int fd ; ssize_t ret = 0 ; struct stat info ; void * data = NULL ; size_t size ; // If open returns error code EINTR, retry again until error code // is not a temporary failure fd = TEMP_FAILURE_RETRY ( open ( SCALING_GOVERNOR , O_RDONLY )); if ( fd < 0 ) { _hidl_cb ( \"error can open fd\" ); return Void (); } fstat ( fd , & info ); size = info . st_size ; data = malloc ( size ); if ( data == NULL ) { _hidl_cb ( \"error can't malloc\" ); close ( fd ); free ( data ); return Void (); } ret = read ( fd , data , size ); if ( ret < 0 ) { _hidl_cb ( \"error reading fd\" ); close ( fd ); free ( data ); return Void (); } snprintf ( str , sizeof ( str ), \"%s\" , ( const unsigned char * ) data ); ALOGI ( \"Test:getTest data=(%s)\" , str ); _hidl_cb ( str ); } // Methods from ::android::hidl::base::V1_0::IBase follow. ITest * HIDL_FETCH_ITest ( const char * /* name */ ) { return new Test (); } } // namespace implementation } // namespace V1_0 } // namespace foo } // namespace mysubpackage } // namespace mypackage Fiz praticamente o mesmo c\u00f3digo do curso, ele \u00e9 capaz de alterar de checar o escalonador do processador. A ideia aqui n\u00e3o \u00e9 explicar o c\u00f3digo, e sim s\u00f3 implementar alguma coisa nos 2 m\u00e9todos. Voce pode implementar qualquer outra coisa. Uma vez que o c\u00f3digo foi implementado, precisamos criar o servi\u00e7o que deixar\u00e1 o mesmo dispon\u00edvel. Dentro da mesma pasta foi criado o arquivo: service.cpp #define LOG_TAG \"mypackage.mysubpackage.foo@1.0-service\" #include <mypackage/mysubpackage/foo/1.0/ITest.h> #include <log/log.h> #include <hidl/HidlTransportSupport.h> #include \"Test.h\" using android :: sp ; using android :: status_t ; using android :: OK ; // libhwbinder: using android :: hardware :: configureRpcThreadpool ; using android :: hardware :: joinRpcThreadpool ; // Generated HIDL files using mypackage :: mysubpackage :: foo :: V1_0 :: ITest ; using mypackage :: mysubpackage :: foo :: V1_0 :: implementation :: Test ; using namespace mypackage ; int main ( int /* argc */ , char ** /* argv */ ) { ALOGI ( \"Foo Service 1.0 for test is starting.\" ); // Android Strong Pointer (don't GC until exit) sp < ITest > service = new Test (); if ( service == nullptr ) { ALOGE ( \"Can not create an instance of ITest HAL, exiting.\" ); return 1 ; } // system/libhidl/transport/include/hidl/HidlTransportSupport.h // Configures the threadpool used for handling incoming RPC calls in this process: // @param maxThreads maximum number of threads in this process // @param callerWillJoin whether the caller will join the threadpool later. configureRpcThreadpool ( 1 , true /*callerWillJoin*/ ); // registerAsService calls registerAsServiceInternal in // system/libhidl/transport/ServiceManagement.cpp // registerAsServiceInternal registers with hwservicemanager status_t status = service -> registerAsService (); if ( status != OK ) { ALOGE ( \"Could not register service for ITest HAL (%d), exiting.\" , status ); return 1 ; } ALOGI ( \"Test Service is ready\" ); // system/libhidl/transport/include/hidl/HidlTransportSupport.h // Joins a threadpool that you configured earlier joinRpcThreadpool (); // In normal operation, we don't expect the thread pool to exit ALOGE ( \"Test Service is shutting down\" ); return 1 ; } De modo geral, a implementa\u00e7\u00e3o \u00e9 a mesma. S\u00f3 precisa ficar atento ao nome da HAL, nesse caso Test . Agora \u00e9 necess\u00e1rio criar o arquivo: Android.bp cc_binary { relative_install_path: \"hw\", name: \"mypackage.mysubpackage.foo@1.0-service\", init_rc: [\"mypackage.mysubpackage.foo@1.0-service.rc\"], srcs: [\"service.cpp\", \"Test.cpp\"], vendor: true, // system_ext_specific: true, vintf_fragments: [\"mypackage.mysubpackage.foo@1.0-service.xml\"], shared_libs: [ \"libhidlbase\", \"liblog\", \"libutils\", \"libhardware\", \"mypackage.mysubpackage.foo@1.0\", ], } Precisamos agora criar 2 arquivos mypackage.mysubpackage.foo@1.0-service.rc e mypackage.mysubpackage.foo@1.0-service.xml , referente as tags init_rc e vintf_fragments respectivamente. mypackage.mysubpackage.foo@1.0-service.rc service mysubpackage_foo_hal_service /vendor/bin/hw/mypackage.mysubpackage.foo@1.0-service interface mypackage.mysubpackage.foo@1.0::ITest default class hal user system group system mypackage.mysubpackage.foo@1.0-service.xml <manifest version= \"1.0\" type= \"device\" > <hal format= \"hidl\" > <name> mypackage.mysubpackage.foo </name> <transport> hwbinder </transport> <version> 1.0 </version> <interface> <name> ITest </name> <instance> default </instance> </interface> <fqname> @1.0::ITest/default </fqname> </hal> </manifest> Agora \u00e9 s\u00f3 fazer um rebuild m -j8 . Podemos checar dentro da pasta /out/target/product/emulator/vendor os seguintes arquivos ap\u00f3s o build: ./bin/hw/mypackage.mysubpackage.foo@1.0-service ./lib/mypackage.mysubpackage.foo@1.0.so ./lib/mypackage.mysubpackage.foo@1.0-adapter-helper.so ./lib64/mypackage.mysubpackage.foo@1.0.so ./lib64/mypackage.mysubpackage.foo@1.0-adapter-helper.so ./etc/init/mypackage.mysubpackage.foo@1.0-service.rc ./etc/vintf/manifest/mypackage.mysubpackage.foo@1.0-service.xml Permiss\u00e3o Iniciando dispositivo, e capturando o log do dmesg , \u00e9 poss\u00edvel encontrar a seguinte mensagem: 10 - 02 11 : 57 : 23.566 0 0 I init : Parsing file / vendor / etc / init / mypackage . mysubpackage . foo @ 1.0 - service . rc ... 10 - 02 11 : 57 : 27.172 0 0 E init : Could not start service 'mysubpackage_foo_hal_service' as part of class ' hal ': File /vendor/bin/hw/mypackage.mysubpackage.foo@1.0-service(labeled \"u:object_r:vendor_file:s0\") has incorrect label or no domain transition from u:r:init:s0 to another SELinux domain defined. Have you configured your service correctly? https://source.android.com/security/selinux/device-policy#label_new_services_and_address_denials. Note: this error shows up even in permissive mode in order to make auditing denials possible. Esse erro \u00e9 referente a falta de permiss\u00e3o que nosso servi\u00e7o possui. Vamos fazer as devidas configura\u00e7\u00f5es. Criei a pasta Sepolicy dentro do produto: mkdir -p device/casa/emulator/sepolicy Dentro da pasta foi criado os arquivos: file_contexts / vendor / bin / hw / mypackage \\ . mysubpackage \\ . foo @ 1 \\ .0 - service u : object_r : hal_mysubpackage_default_exec : s0 hal_mysubpackage_default.te type hal_mysubpackage_default , domain ; type hal_mysubpackage_default_exec , exec_type , vendor_file_type , file_type ; init_daemon_domain ( hal_mysubpackage_default ); Al\u00e9m disso, \u00e9 necess\u00e1rio adicionar a pasta na compila\u00e7\u00e3o do AOSP. Isso \u00e9 feito dentro do BoardConfig.mk do produto, no meu caso device/casa/emulator/BoardConfig.mk : BoardConfig.mk ... BOARD_SEPOLICY_DIRS += device/casa/emulator/sepolicy Agora \u00e9 s\u00f3 recompilar o AOSP. Ap\u00f3s o build, capturando o log do dmesg , podemos encontrar a seguinte mensagem: 10 - 02 14 : 30 : 53.735 370 370 W mypackage . mysub : type = 1400 audit ( 0.0 : 1020 ): avc : denied { read } for name = \"u:object_r:hwservicemanager_prop:s0\" dev = \"tmpfs\" ino = 168 scontext = u : r : hal_mysubpackage_default : s0 tcontext = u : object_r : hwservicemanager_prop : s0 tclass = file permissive = 0 Essa mensagem \u00e9 referente ao SELinux audit messages e para resolve-las \u00e9 necessario criar as SELinux allow rules . Para isso, pode se usar o policycoreutils , que pode ser instalado com o comando: sudo apt install policycoreutils-python-utils Agora precisamos baixar o arquivo policy do device, para isso \u00e9 usado o comando: adb pull /sys/fs/selinux/policy Na mesma pasta onde foi baixado o arquivo policy , foi usado o seguinte comando: adb logcat -b all -d | audit2allow -p policy Foi retornado a seguinte mensagem: ============= hal_mysubpackage_default ============== allow hal_mysubpackage_default hwservicemanager_prop:file read; Essa mensagem diz que a HAL precisa de permiss\u00e3o de leitura em hwservicemanager_prop . Para fazer isso, adicionamos a seguinte linha no arquivo: hal_mysubpackage_default.te type hal_mysubpackage_default , domain ; type hal_mysubpackage_default_exec , exec_type , vendor_file_type , file_type ; init_daemon_domain ( hal_mysubpackage_default ); # allow hal_mysubpackage_default hwservicemanager_prop:file read; get_prop ( hal_mysubpackage_default , hwservicemanager_prop ); Rebuildando e checando o dmesg , agora encontramos as seguinte mensagem: 10 - 02 14 : 53 : 10.769 0 0 I init : starting service 'mysubpackage_foo_hal_service' ... 10 - 02 14 : 53 : 11.162 1855 1855 I mypackage . mysubpackage . foo @ 1.0 - service : Foo Service 1.0 for test is starting . 10 - 02 14 : 53 : 11.163 1855 1855 E HidlServiceManagement : Could not get transport for mypackage . mysubpackage . foo @ 1.0 :: ITest / default : Status ( EX_TRANSACTION_FAILED ): 'FAILED_TRANSACTION: ' 10 - 02 14 : 53 : 11.163 1855 1855 E mypackage . mysubpackage . foo @ 1.0 - service : Could not register service for ITest HAL ( - 2147483648 ), exiting . 10 - 02 14 : 53 : 11.160 1855 1855 W mypackage . mysub : type = 1400 audit ( 0.0 : 11 ): avc : denied { call } for scontext = u : r : hal_mysubpackage_default : s0 tcontext = u : r : hwservicemanager : s0 tclass = binder permissive = 0 10 - 02 14 : 53 : 10.783 0 0 I init : Service 'mysubpackage_foo_hal_service' ( pid 1855 ) exited with status 1 10 - 02 14 : 53 : 10.785 0 0 I init : Sending signal 9 to service 'mysubpackage_foo_hal_service' ( pid 1855 ) process group ... 10 - 02 14 : 53 : 10.786 0 0 E init : process with updatable components 'mysubpackage_foo_hal_service' exited 4 times in 4 minutes Para resolver, vamos novamente usar os seguintes comandos: adb pull /sys/fs/selinux/policy adb logcat -b all -d | audit2allow -p policy Ele retorna a seguinte mensagem: ============= hal_mysubpackage_default ============== allow hal_mysubpackage_default hwservicemanager:binder call; Ela informa que \u00e9 necess\u00e1rio fazer a chamada do hwservicemanager . Para isso, adicionamos ao arquivo: hal_mysubpackage_default.te type hal_mysubpackage_default , domain ; type hal_mysubpackage_default_exec , exec_type , vendor_file_type , file_type ; init_daemon_domain ( hal_mysubpackage_default ); # allow hal_mysubpackage_default hwservicemanager_prop:file read; get_prop ( hal_mysubpackage_default , hwservicemanager_prop ); # allow hal_mysubpackage_default hwservicemanager:binder call; hwbinder_use ( hal_mysubpackage_default ); Rebuildando e checando o dmesg , temos a seguinte mensagem: 10 - 02 15 : 05 : 28.709 0 0 I init : starting service 'mysubpackage_foo_hal_service' ... 10 - 02 15 : 05 : 29.551 1891 1891 I mypackage . mysubpackage . foo @ 1.0 - service : Foo Service 1.0 for test is starting . 10 - 02 15 : 05 : 29.551 172 172 E SELinux : avc : denied { find } for interface = mypackage . mysubpackage . foo :: ITest sid = u : r : hal_mysubpackage_default : s0 pid = 1891 scontext = u : r : hal_mysubpackage_default : s0 tcontext = u : object_r : default_android_hwservice : s0 tclass = hwservice_manager permissive = 0 10 - 02 15 : 05 : 29.551 1891 1891 E HidlServiceManagement : Service mypackage . mysubpackage . foo @ 1.0 :: ITest / default must be in VINTF manifest in order to register / get . 10 - 02 15 : 05 : 29.551 1891 1891 E mypackage . mysubpackage . foo @ 1.0 - service : Could not register service for ITest HAL ( - 2147483648 ), exiting . 10 - 02 15 : 05 : 28.722 0 0 I init : Service 'mysubpackage_foo_hal_service' ( pid 1891 ) exited with status 1 10 - 02 15 : 05 : 28.722 0 0 I init : Sending signal 9 to service 'mysubpackage_foo_hal_service' ( pid 1891 ) process group ... 10 - 02 15 : 05 : 28.723 0 0 E init : process with updatable components 'mysubpackage_foo_hal_service' exited 4 times in 4 minutes Esse erro ocorre devido ao conflito de regras do domain , definido no arquivo hal_mysubpackage_default.te . Para obter mais informa\u00e7\u00f5es, sugiro checar o curso. Para resolver, vamos novamente usar os seguintes comandos: adb pull /sys/fs/selinux/policy adb logcat -b all -d | audit2allow -p policy Ele retorna a seguinte mensagem: ============= hal_mysubpackage_default ============== allow hal_mysubpackage_default default_android_hwservice:hwservice_manager find; Para resolver isso, foi criado dentro da pasta device/casa/emulator/sepolicy os arquivos: hwservice.te type hal_mysubpackage_hwservice , hwservice_manager_type ; hwservice_contexts mypackage . mysubpackage . foo :: ITest u : object_r : hal_mysubpackage_hwservice : s0 E adicionamos as seguintes linhas ao arquivo: hal_mysubpackage_default.te type hal_mysubpackage_default , domain ; type hal_mysubpackage_default_exec , exec_type , vendor_file_type , file_type ; init_daemon_domain ( hal_mysubpackage_default ); # allow hal_mysubpackage_default hwservicemanager_prop:file read; get_prop ( hal_mysubpackage_default , hwservicemanager_prop ); # allow hal_mysubpackage_default hwservicemanager:binder call; hwbinder_use ( hal_mysubpackage_default ); # allow hal_mysubpackage_default default_android_hwservice:hwservice_manager find; add_hwservice ( hal_mysubpackage_default , hal_mysubpackage_hwservice ); Rebuildando e checando o dmesg , temos a seguinte mensagem: 10 - 02 15 : 27 : 27.714 0 0 I init : Parsing file / vendor / etc / init / mypackage . mysubpackage . foo @ 1.0 - service . rc ... 10 - 02 15 : 27 : 35.135 0 0 I init : starting service 'mysubpackage_foo_hal_service' ... 10 - 02 15 : 27 : 35.135 370 370 I mypackage . mysubpackage . foo @ 1.0 - service : Foo Service 1.0 for test is starting . 10 - 02 15 : 27 : 35.141 370 370 I HidlServiceManagement : Registered mypackage . mysubpackage . foo @ 1.0 :: ITest / default 10 - 02 15 : 27 : 35.141 370 370 I HidlServiceManagement : Removing namespace from process name mypackage . mysubpackage . foo @ 1.0 - service to foo @ 1.0 - service . 10 - 02 15 : 27 : 35.141 370 370 I mypackage . mysubpackage . foo @ 1.0 - service : Test Service is ready Agora nosso servi\u00e7o est\u00e1 com todas as permiss\u00f5es necess\u00e1rias. Observe que algumas das mensagens foram implementadas no arquivo service.cpp Testando Para criar um bin\u00e1rio para teste, foi criado na pasta device/casa/emulator/interfaces/foo/1.0/default/halTest os seguintes arquivos: HalTest.cpp #include <mypackage/mysubpackage/foo/1.0/ITest.h> #include <hidl/Status.h> #include <hidl/LegacySupport.h> #include <utils/misc.h> #include <hidl/HidlSupport.h> #include <iostream> #include <cstdlib> #include <string> using :: android :: sp ; using :: mypackage :: mysubpackage :: foo :: V1_0 :: ITest ; using android :: hardware :: hidl_string ; int main ( int argc , char * argv []) { if ( argc != 2 ) { std :: cout << \"USAGE ./cpu_client <conservative|powersave|performance|schedutil> \\n \" ; exit ( 0 ); } android :: sp < ITest > cpuService = ITest :: getService (); if ( cpuService == nullptr ) { std :: cout << \"Failed to get cpu service \\n \" ; exit ( -1 ); } cpuService -> getTest ([ & ]( hidl_string result ) { std :: cout << \"getScalingGovernor:\" << result << std :: endl ; }); bool result = cpuService -> setTest ( argv [ 1 ]); std :: cout << \"setScalingGovernor:\" << result << std :: endl ; cpuService -> getTest ([ & ]( hidl_string result ) { std :: cout << \"getScalingGovernor:\" << result << std :: endl ; }); return 0 ; } Android.bp cc_binary { relative_install_path: \"hw\", defaults: [\"hidl_defaults\"], name: \"subpackage_foo_tester\", srcs: [\"HalTest.cpp\"], vendor: true, shared_libs: [ \"liblog\", \"libhardware\", \"libhidlbase\", \"libutils\", \"mypackage.mysubpackage.foo@1.0\", ], } Agora adicionando o bin\u00e1rio ao produto, no arquivo: emulator.mk ... PRODUCT_PACKAGES += \\ mypackage.mysubpackage.foo@1.0 PRODUCT_PACKAGES_DEBUG += \\ subpackage_foo_tester Re-buildando o AOSP e executando os seguintes comandos: 1 2 3 adb root adb shell vendor/bin/hw/subpackage_foo_tester performance O caminho do bin\u00e1rio \u00e9 relativo a vendor=true (vendor/), cc_binary (bin/) e relative_install_path (hw/). O resultado do caminho \u00e9 vendor/bin/hw/ . Checando o dmesg , encontramos a seguinte mensagem: 10 - 02 21 : 03 : 19.861 371 371 I mypackage . mysubpackage . foo @ 1.0 - service : Test : getTest data = ( schedutil 10 - 02 21 : 03 : 19.861 371 371 I mypackage . mysubpackage . foo @ 1.0 - service : ) 10 - 02 21 : 03 : 19.861 371 371 I mypackage . mysubpackage . foo @ 1.0 - service : Test :: setTest data = ( performance ) 10 - 02 21 : 03 : 19.861 371 371 E mypackage . mysubpackage . foo @ 1.0 - service : write_value failed to open 10 - 02 21 : 03 : 19.861 371 371 I mypackage . mysubpackage . foo @ 1.0 - service : Test : getTest data = ( schedutil 10 - 02 21 : 03 : 19.861 371 371 I mypackage . mysubpackage . foo @ 1.0 - service : ) Isso se deve porque somente o usu\u00e1rio root tem permiss\u00e3o para escrever no caminho /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor (definido no arquivo Teste.cpp ). Ent\u00e3o precisamos dar permiss\u00e3o para o nosso aplicativo, para isso vamos adicionar ao arquivo: mypackage.mysubpackage.foo@1.0-service.rc service mysubpackage_foo_hal_service /vendor/bin/hw/mypackage.mysubpackage.foo@1.0-service interface mypackage.mysubpackage.foo@1.0::ITest default class hal user system group system on boot chown system system /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor chmod 0664 /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor Rebuildando e execuntado o bin\u00e1rio de teste, temos a seguinte mensagem : getScalingGovernor:schedutil setScalingGovernor:0 getScalingGovernor:schedutil Obervar que o ScalingGovernor n\u00e3o foi alterado. No log de dmesg , temos essa: 10 - 02 21 : 09 : 09.854 370 370 I mypackage . mysubpackage . foo @ 1.0 - service : Test : getTest data = ( schedutil 10 - 02 21 : 09 : 09.854 370 370 I mypackage . mysubpackage . foo @ 1.0 - service : ) 10 - 02 21 : 09 : 09.854 370 370 I mypackage . mysubpackage . foo @ 1.0 - service : Test :: setTest data = ( performance ) 10 - 02 21 : 09 : 09.854 370 370 E mypackage . mysubpackage . foo @ 1.0 - service : write_value failed to open 10 - 02 21 : 09 : 09.853 370 370 W foo @ 1.0 - service : type = 1400 audit ( 0.0 : 5 ): avc : denied { write } for name = \"scaling_governor\" dev = \"sysfs\" ino = 19629 scontext = u : r : hal_mysubpackage_default : s0 tcontext = u : object_r : sysfs_devices_system_cpu : s0 tclass = file permissive = 0 10 - 02 21 : 09 : 09.858 370 370 I mypackage . mysubpackage . foo @ 1.0 - service : Test : getTest data = ( schedutil 10 - 02 21 : 09 : 09.858 370 370 I mypackage . mysubpackage . foo @ 1.0 - service : ) Como \u00e9 um problema do audit , repetimos os passos: adb pull /sys/fs/selinux/policy adb logcat -b all -d | audit2allow -p policy retornando a mensagem: ============= hal_mysubpackage_default ============== allow hal_mysubpackage_default sysfs_devices_system_cpu:file write; Foi preciso adicionar ao arquivo: hal_mysubpackage_default.te type hal_mysubpackage_default , domain ; type hal_mysubpackage_default_exec , exec_type , vendor_file_type , file_type ; init_daemon_domain ( hal_mysubpackage_default ); # allow hal_mysubpackage_default hwservicemanager_prop:file read; get_prop ( hal_mysubpackage_default , hwservicemanager_prop ); # allow hal_mysubpackage_default hwservicemanager:binder call; hwbinder_use ( hal_mysubpackage_default ); # allow hal_mysubpackage_default default_android_hwservice:hwservice_manager find; add_hwservice ( hal_mysubpackage_default , hal_mysubpackage_hwservice ); allow hal_mysubpackage_default sysfs_devices_system_cpu : file write ; Rebuildando e execuntado o bin\u00e1rio de teste, temos a seguinte mensagem : getScalingGovernor:schedutil setScalingGovernor:1 getScalingGovernor:performance Obervar que o ScalingGovernor foi alterado para performance . No log de dmesg , n\u00e3o encontramos nenhum tipo de erro: 10 - 02 21 : 16 : 46.620 375 375 I mypackage . mysubpackage . foo @ 1.0 - service : Test : getTest data = ( schedutil 10 - 02 21 : 16 : 46.620 375 375 I mypackage . mysubpackage . foo @ 1.0 - service : ) 10 - 02 21 : 16 : 46.620 375 375 I mypackage . mysubpackage . foo @ 1.0 - service : Test :: setTest data = ( performance ) 10 - 02 21 : 16 : 46.639 375 375 I mypackage . mysubpackage . foo @ 1.0 - service : Test : getTest data = ( performance 10 - 02 21 : 16 : 46.639 375 375 I mypackage . mysubpackage . foo @ 1.0 - service : ) Conclus\u00e3o Nesse post eu tentei mostrar de forma mais pr\u00e1tica, como \u00e9 implementado uma HIDL. Existe muita teoria envolvida, principalmente na parte de permiss\u00f5es, que s\u00e3o abordadas de uma forma um pouco mais profunda no curso Android 12 Internals material, labs and discussion . Ao final, fiz um aplicativo para testar a implementa\u00e7\u00e3o. \ud83e\udd47","title":"Implementando a HIDL"},{"location":"Android/HAL/HIDL/#implementando-a-hidl","text":"Image by methodshop from Pixabay Baseado no curso: Android 12 Internals material, labs and discussion","title":"Implementando a HIDL"},{"location":"Android/HAL/HIDL/#introducao","text":"Umas das coisas mais dif\u00edceis que eu encontrei durante o processo de entender o sistema Android, foi sobre Hardware Abstraction Layer (HAL). Que \u00e9 a forma de conectar o framework do Android com a parte do hardware . Atualmente, a forma mais disseminada de fazer essa conex\u00e3o \u00e9 utilizando a HAL Interface Definition Language (HIDL). Que irei abordar nesse post.","title":"Introdu\u00e7\u00e3o"},{"location":"Android/HAL/HIDL/#definicoes","text":"Quando um aplicativo A precisa se comunicar com um aplicativo B , existem duas formas grosseiramente de se fazer isso. A primeira \u00e9 passando diretamente a regi\u00e3o de mem\u00f3ria do aplicativo A para o aplicativo B . A segunda \u00e9 utilizando um mecanismo que gerencie essa troca de informa\u00e7\u00e3o entre o aplicativo A e o aplicativo B . Essa comunica\u00e7\u00e3o entre aplicativos \u00e9 conhecida como inter-process communication (IPC), que utilizam proxy e stub para fazer a comunica\u00e7\u00e3o, como uma esp\u00e9cie de cliente-servidor. No Android, esse mecanismo \u00e9 o Binder e o \"protocolo\" que esse mecanismo utiliza \u00e9 a HAL, que por sua vez pode ser implementada com a HIDL. Nesse sistema os equivalentes do proxy e stub s\u00e3o o Binder Proxy (Bp) e Binder Native (Bn). Dessa forma, as siglas Bp e Bn ir\u00e3o aparecer constantemente no processo de implementa\u00e7\u00e3o da HAL do Android. N\u00e3o confundir com a extens\u00e3o .Bp (Blueprint) que faz refer\u00eancia aos arquivos de build do Android.","title":"Defini\u00e7\u00f5es"},{"location":"Android/HAL/HIDL/#implementacao","text":"Vou tentar dividir em alguns t\u00f3picos para facilitar.","title":"Implementa\u00e7\u00e3o"},{"location":"Android/HAL/HIDL/#hal","text":"Na pasta raiz do AOSP , criei o seguinte caminho: mkdir - p device / casa / emulator / interfaces / foo / 1.0 A pasta foo/ \u00e9 o nome da HAL e a pasta 1.0/ seria a vers\u00e3o dessa HAL. Dentro da pasta 1.0/ criei os arquivos: Android.bp hidl_interface { name: \"mypackage.mysubpackage.foo@1.0\", root: \"mypackage.mysubpackage\", srcs: [ \"ITest.hal\", ], interfaces: [ \"android.hidl.base@1.0\", ], gen_java: true, product_specific: true, } ITest.hal package mypackage.mysubpackage.foo@1.0; interface ITest { getTest() generates (string res); setTest(string param) generates (bool res); }; Algumas coisas que podem causar confus\u00e3o e geralmente d\u00e3o problema de compila\u00e7\u00e3o s\u00e3o os nomes. Nesse caso, no arquivo Android.bp a tag root \u00e9 um prefixo para a tag name ( mypackage.mysubpackage ), que \u00e9 seguida do nome da HAL (foo) com sua vers\u00e3o (1.0). No arquivo ITest.hal , o package deve ser o mesmo nome da tag name do Android.bp . Agora dentro da pasta interfaces/ ( device/casa/emulator/interfaces ), criei outro arquivo: Android.bp hidl_package_root { name: \"mypackage.mysubpackage\", path: \"device/casa/emulator/interfaces\", } A tag name desse arquivo \u00e9 igual ao da tag root do outro arquivo Android.bp . A tag path \u00e9 o caminho relativo da pasta raiz do AOSP at\u00e9 a pasta interfaces . Finalmente, dentro da pasta device/casa/emulator/interfaces/foo/1.0 o seguinte comando foi usado: mm -j8 Ele compila a HAL foo. Ao final do processo uma mensagem similar deve aparecer: ============================================ [100% 149/149] Copy: out/target/product/emulator/data/nativetest/product/mypackage.mysubpackage.foo@1.0-adapter/mypackage.mysubpackage.foo@1.0.so.toc build completed successfully (7 seconds) #### Os arquivos gerados est\u00e3o dentro do diret\u00f3rio: out/soong/.intermediates/device/casa/emulator/interfaces/foo/1.0 No curso Android 12 Internals \u00e9 dado mais detalhes sobre alguns arquivos dentro dessa pasta. Por fim, \u00e9 necess\u00e1rio adicionar a HAL foo ao final do produto, no meu caso, emulator.mk ( device/casa/emulator/emulator.mk ), da seguinte forma: emulator.mk ... PRODUCT_PACKAGES += \\ mypackage.mysubpackage.foo@1.0 Agora \u00e9 s\u00f3 rebuildar o AOSP m -j8 . Ap\u00f3s o build terminar, na pasta do produto dentro da pasta out/ \u00e9 poss\u00edvel ver onde a HAL foi adicionada: ./vendor/lib/mypackage.mysubpackage.foo@1.0.so ./vendor/lib/mypackage.mysubpackage.foo@1.0-adapter-helper.so ./vendor/lib64/mypackage.mysubpackage.foo@1.0.so ./vendor/lib64/mypackage.mysubpackage.foo@1.0-adapter-helper.so ./product/lib/mypackage.mysubpackage.foo@1.0.so ./product/lib/mypackage.mysubpackage.foo@1.0-adapter-helper.so ./product/lib64/mypackage.mysubpackage.foo@1.0.so ./product/lib64/mypackage.mysubpackage.foo@1.0-adapter-helper.so ./product/framework/mypackage.mysubpackage.foo-V1.0-java.jar ./product/framework/mypackage.mysubpackage.foo-V1.0-java-shallow.jar Ser\u00e3o adicionados na imagem vendor.img e product.img .","title":"HAL"},{"location":"Android/HAL/HIDL/#servico","text":"Antes de criar o servi\u00e7o, precisamos implementar o que ser\u00e1 processado dentro das duas fun\u00e7\u00f5es que definidas no ITest.hal . Quando compilamos a HAL no passo anterior, o Android criou 2 m\u00e9todos virtuais dentro do arquivo: out/soong/.intermediates/device/casa/emulator/interfaces/foo/1.0/mypackage.mysubpackage.foo@1.0_genc++_headers/gen/mypackage/mysubpackage/foo/1.0/ITest.h Os m\u00e9todos s\u00e3o: ITest.h /** * Return callback for getTest */ using getTest_cb = std :: function < void ( const :: android :: hardware :: hidl_string & res ) > ; virtual :: android :: hardware :: Return < void > getTest ( getTest_cb _hidl_cb ) = 0 ; virtual :: android :: hardware :: Return < bool > setTest ( const :: android :: hardware :: hidl_string & param ) = 0 ; Para fazer a implementa\u00e7\u00e3o desses m\u00e9todos, criei dentro da pasta device/casa/emulator/interfaces/foo/1.0/default os arquivos: Test.h #ifndef MYPACKAGE_MYSUBPACKAGE_FOO_V1_0_ITEST_H #define MYPACKAGE_MYSUBPACKAGE_FOO_V1_0_ITEST_H // Mesmo caminho ap\u00f3s: // mypackage.mysubpackage.foo@1.0_genc++_headers/gen/ // dentro da pasta out/ #include <mypackage/mysubpackage/foo/1.0/ITest.h> namespace mypackage { namespace mysubpackage { namespace foo { namespace V1_0 { namespace implementation { using :: android :: hardware :: hidl_string ; // const hidl_string using :: android :: hardware :: Return ; // Return<void> using :: android :: hardware :: Void ; // return Void(); using :: mypackage :: mysubpackage :: foo :: V1_0 :: ITest ; // public ITest class Test : public ITest { public : Return < bool > setTest ( const hidl_string & param ) override ; Return < void > getTest ( getTest_cb _hidl_c ) override ; }; extern \"C\" ITest * HIDL_FETCH_ITest ( const char * name ); } // namespace implementation } // namespace V1_0 } // namespace foo } // namespace mysubpackage } // namespace mypackage #endif Test.cpp #include \"Test.h\" #include <utils/Log.h> //ALOGI e ALOGE #include <sys/stat.h> // struct stat info namespace mypackage { namespace mysubpackage { namespace foo { namespace V1_0 { namespace implementation { // conservative|powersave|performance|schedutil static const char SCALING_GOVERNOR [] = \"/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor\" ; static int write_value ( const char * file , const char * value ) { int to_write , written , ret , fd ; fd = TEMP_FAILURE_RETRY ( open ( file , O_WRONLY )); if ( fd < 0 ) { ALOGE ( \"write_value failed to open\" ); return -1 ; } to_write = strlen ( value ) + 1 ; written = TEMP_FAILURE_RETRY ( write ( fd , value , to_write )); if ( written == -1 ) { ret = -2 ; } else if ( written != to_write ) { ret = -3 ; } else { ret = 0 ; } errno = 0 ; close ( fd ); return ret ; } Return < bool > Test :: setTest ( const hidl_string & param ) { ALOGI ( \"Test::setTest data=(%s)\" , param . c_str ()); return write_value ( SCALING_GOVERNOR , param . c_str ()) == 0 ; } Return < void > Test :: getTest ( getTest_cb _hidl_cb ) { char str [ 20 ]; int fd ; ssize_t ret = 0 ; struct stat info ; void * data = NULL ; size_t size ; // If open returns error code EINTR, retry again until error code // is not a temporary failure fd = TEMP_FAILURE_RETRY ( open ( SCALING_GOVERNOR , O_RDONLY )); if ( fd < 0 ) { _hidl_cb ( \"error can open fd\" ); return Void (); } fstat ( fd , & info ); size = info . st_size ; data = malloc ( size ); if ( data == NULL ) { _hidl_cb ( \"error can't malloc\" ); close ( fd ); free ( data ); return Void (); } ret = read ( fd , data , size ); if ( ret < 0 ) { _hidl_cb ( \"error reading fd\" ); close ( fd ); free ( data ); return Void (); } snprintf ( str , sizeof ( str ), \"%s\" , ( const unsigned char * ) data ); ALOGI ( \"Test:getTest data=(%s)\" , str ); _hidl_cb ( str ); } // Methods from ::android::hidl::base::V1_0::IBase follow. ITest * HIDL_FETCH_ITest ( const char * /* name */ ) { return new Test (); } } // namespace implementation } // namespace V1_0 } // namespace foo } // namespace mysubpackage } // namespace mypackage Fiz praticamente o mesmo c\u00f3digo do curso, ele \u00e9 capaz de alterar de checar o escalonador do processador. A ideia aqui n\u00e3o \u00e9 explicar o c\u00f3digo, e sim s\u00f3 implementar alguma coisa nos 2 m\u00e9todos. Voce pode implementar qualquer outra coisa. Uma vez que o c\u00f3digo foi implementado, precisamos criar o servi\u00e7o que deixar\u00e1 o mesmo dispon\u00edvel. Dentro da mesma pasta foi criado o arquivo: service.cpp #define LOG_TAG \"mypackage.mysubpackage.foo@1.0-service\" #include <mypackage/mysubpackage/foo/1.0/ITest.h> #include <log/log.h> #include <hidl/HidlTransportSupport.h> #include \"Test.h\" using android :: sp ; using android :: status_t ; using android :: OK ; // libhwbinder: using android :: hardware :: configureRpcThreadpool ; using android :: hardware :: joinRpcThreadpool ; // Generated HIDL files using mypackage :: mysubpackage :: foo :: V1_0 :: ITest ; using mypackage :: mysubpackage :: foo :: V1_0 :: implementation :: Test ; using namespace mypackage ; int main ( int /* argc */ , char ** /* argv */ ) { ALOGI ( \"Foo Service 1.0 for test is starting.\" ); // Android Strong Pointer (don't GC until exit) sp < ITest > service = new Test (); if ( service == nullptr ) { ALOGE ( \"Can not create an instance of ITest HAL, exiting.\" ); return 1 ; } // system/libhidl/transport/include/hidl/HidlTransportSupport.h // Configures the threadpool used for handling incoming RPC calls in this process: // @param maxThreads maximum number of threads in this process // @param callerWillJoin whether the caller will join the threadpool later. configureRpcThreadpool ( 1 , true /*callerWillJoin*/ ); // registerAsService calls registerAsServiceInternal in // system/libhidl/transport/ServiceManagement.cpp // registerAsServiceInternal registers with hwservicemanager status_t status = service -> registerAsService (); if ( status != OK ) { ALOGE ( \"Could not register service for ITest HAL (%d), exiting.\" , status ); return 1 ; } ALOGI ( \"Test Service is ready\" ); // system/libhidl/transport/include/hidl/HidlTransportSupport.h // Joins a threadpool that you configured earlier joinRpcThreadpool (); // In normal operation, we don't expect the thread pool to exit ALOGE ( \"Test Service is shutting down\" ); return 1 ; } De modo geral, a implementa\u00e7\u00e3o \u00e9 a mesma. S\u00f3 precisa ficar atento ao nome da HAL, nesse caso Test . Agora \u00e9 necess\u00e1rio criar o arquivo: Android.bp cc_binary { relative_install_path: \"hw\", name: \"mypackage.mysubpackage.foo@1.0-service\", init_rc: [\"mypackage.mysubpackage.foo@1.0-service.rc\"], srcs: [\"service.cpp\", \"Test.cpp\"], vendor: true, // system_ext_specific: true, vintf_fragments: [\"mypackage.mysubpackage.foo@1.0-service.xml\"], shared_libs: [ \"libhidlbase\", \"liblog\", \"libutils\", \"libhardware\", \"mypackage.mysubpackage.foo@1.0\", ], } Precisamos agora criar 2 arquivos mypackage.mysubpackage.foo@1.0-service.rc e mypackage.mysubpackage.foo@1.0-service.xml , referente as tags init_rc e vintf_fragments respectivamente. mypackage.mysubpackage.foo@1.0-service.rc service mysubpackage_foo_hal_service /vendor/bin/hw/mypackage.mysubpackage.foo@1.0-service interface mypackage.mysubpackage.foo@1.0::ITest default class hal user system group system mypackage.mysubpackage.foo@1.0-service.xml <manifest version= \"1.0\" type= \"device\" > <hal format= \"hidl\" > <name> mypackage.mysubpackage.foo </name> <transport> hwbinder </transport> <version> 1.0 </version> <interface> <name> ITest </name> <instance> default </instance> </interface> <fqname> @1.0::ITest/default </fqname> </hal> </manifest> Agora \u00e9 s\u00f3 fazer um rebuild m -j8 . Podemos checar dentro da pasta /out/target/product/emulator/vendor os seguintes arquivos ap\u00f3s o build: ./bin/hw/mypackage.mysubpackage.foo@1.0-service ./lib/mypackage.mysubpackage.foo@1.0.so ./lib/mypackage.mysubpackage.foo@1.0-adapter-helper.so ./lib64/mypackage.mysubpackage.foo@1.0.so ./lib64/mypackage.mysubpackage.foo@1.0-adapter-helper.so ./etc/init/mypackage.mysubpackage.foo@1.0-service.rc ./etc/vintf/manifest/mypackage.mysubpackage.foo@1.0-service.xml","title":"Servi\u00e7o"},{"location":"Android/HAL/HIDL/#permissao","text":"Iniciando dispositivo, e capturando o log do dmesg , \u00e9 poss\u00edvel encontrar a seguinte mensagem: 10 - 02 11 : 57 : 23.566 0 0 I init : Parsing file / vendor / etc / init / mypackage . mysubpackage . foo @ 1.0 - service . rc ... 10 - 02 11 : 57 : 27.172 0 0 E init : Could not start service 'mysubpackage_foo_hal_service' as part of class ' hal ': File /vendor/bin/hw/mypackage.mysubpackage.foo@1.0-service(labeled \"u:object_r:vendor_file:s0\") has incorrect label or no domain transition from u:r:init:s0 to another SELinux domain defined. Have you configured your service correctly? https://source.android.com/security/selinux/device-policy#label_new_services_and_address_denials. Note: this error shows up even in permissive mode in order to make auditing denials possible. Esse erro \u00e9 referente a falta de permiss\u00e3o que nosso servi\u00e7o possui. Vamos fazer as devidas configura\u00e7\u00f5es. Criei a pasta Sepolicy dentro do produto: mkdir -p device/casa/emulator/sepolicy Dentro da pasta foi criado os arquivos: file_contexts / vendor / bin / hw / mypackage \\ . mysubpackage \\ . foo @ 1 \\ .0 - service u : object_r : hal_mysubpackage_default_exec : s0 hal_mysubpackage_default.te type hal_mysubpackage_default , domain ; type hal_mysubpackage_default_exec , exec_type , vendor_file_type , file_type ; init_daemon_domain ( hal_mysubpackage_default ); Al\u00e9m disso, \u00e9 necess\u00e1rio adicionar a pasta na compila\u00e7\u00e3o do AOSP. Isso \u00e9 feito dentro do BoardConfig.mk do produto, no meu caso device/casa/emulator/BoardConfig.mk : BoardConfig.mk ... BOARD_SEPOLICY_DIRS += device/casa/emulator/sepolicy Agora \u00e9 s\u00f3 recompilar o AOSP. Ap\u00f3s o build, capturando o log do dmesg , podemos encontrar a seguinte mensagem: 10 - 02 14 : 30 : 53.735 370 370 W mypackage . mysub : type = 1400 audit ( 0.0 : 1020 ): avc : denied { read } for name = \"u:object_r:hwservicemanager_prop:s0\" dev = \"tmpfs\" ino = 168 scontext = u : r : hal_mysubpackage_default : s0 tcontext = u : object_r : hwservicemanager_prop : s0 tclass = file permissive = 0 Essa mensagem \u00e9 referente ao SELinux audit messages e para resolve-las \u00e9 necessario criar as SELinux allow rules . Para isso, pode se usar o policycoreutils , que pode ser instalado com o comando: sudo apt install policycoreutils-python-utils Agora precisamos baixar o arquivo policy do device, para isso \u00e9 usado o comando: adb pull /sys/fs/selinux/policy Na mesma pasta onde foi baixado o arquivo policy , foi usado o seguinte comando: adb logcat -b all -d | audit2allow -p policy Foi retornado a seguinte mensagem: ============= hal_mysubpackage_default ============== allow hal_mysubpackage_default hwservicemanager_prop:file read; Essa mensagem diz que a HAL precisa de permiss\u00e3o de leitura em hwservicemanager_prop . Para fazer isso, adicionamos a seguinte linha no arquivo: hal_mysubpackage_default.te type hal_mysubpackage_default , domain ; type hal_mysubpackage_default_exec , exec_type , vendor_file_type , file_type ; init_daemon_domain ( hal_mysubpackage_default ); # allow hal_mysubpackage_default hwservicemanager_prop:file read; get_prop ( hal_mysubpackage_default , hwservicemanager_prop ); Rebuildando e checando o dmesg , agora encontramos as seguinte mensagem: 10 - 02 14 : 53 : 10.769 0 0 I init : starting service 'mysubpackage_foo_hal_service' ... 10 - 02 14 : 53 : 11.162 1855 1855 I mypackage . mysubpackage . foo @ 1.0 - service : Foo Service 1.0 for test is starting . 10 - 02 14 : 53 : 11.163 1855 1855 E HidlServiceManagement : Could not get transport for mypackage . mysubpackage . foo @ 1.0 :: ITest / default : Status ( EX_TRANSACTION_FAILED ): 'FAILED_TRANSACTION: ' 10 - 02 14 : 53 : 11.163 1855 1855 E mypackage . mysubpackage . foo @ 1.0 - service : Could not register service for ITest HAL ( - 2147483648 ), exiting . 10 - 02 14 : 53 : 11.160 1855 1855 W mypackage . mysub : type = 1400 audit ( 0.0 : 11 ): avc : denied { call } for scontext = u : r : hal_mysubpackage_default : s0 tcontext = u : r : hwservicemanager : s0 tclass = binder permissive = 0 10 - 02 14 : 53 : 10.783 0 0 I init : Service 'mysubpackage_foo_hal_service' ( pid 1855 ) exited with status 1 10 - 02 14 : 53 : 10.785 0 0 I init : Sending signal 9 to service 'mysubpackage_foo_hal_service' ( pid 1855 ) process group ... 10 - 02 14 : 53 : 10.786 0 0 E init : process with updatable components 'mysubpackage_foo_hal_service' exited 4 times in 4 minutes Para resolver, vamos novamente usar os seguintes comandos: adb pull /sys/fs/selinux/policy adb logcat -b all -d | audit2allow -p policy Ele retorna a seguinte mensagem: ============= hal_mysubpackage_default ============== allow hal_mysubpackage_default hwservicemanager:binder call; Ela informa que \u00e9 necess\u00e1rio fazer a chamada do hwservicemanager . Para isso, adicionamos ao arquivo: hal_mysubpackage_default.te type hal_mysubpackage_default , domain ; type hal_mysubpackage_default_exec , exec_type , vendor_file_type , file_type ; init_daemon_domain ( hal_mysubpackage_default ); # allow hal_mysubpackage_default hwservicemanager_prop:file read; get_prop ( hal_mysubpackage_default , hwservicemanager_prop ); # allow hal_mysubpackage_default hwservicemanager:binder call; hwbinder_use ( hal_mysubpackage_default ); Rebuildando e checando o dmesg , temos a seguinte mensagem: 10 - 02 15 : 05 : 28.709 0 0 I init : starting service 'mysubpackage_foo_hal_service' ... 10 - 02 15 : 05 : 29.551 1891 1891 I mypackage . mysubpackage . foo @ 1.0 - service : Foo Service 1.0 for test is starting . 10 - 02 15 : 05 : 29.551 172 172 E SELinux : avc : denied { find } for interface = mypackage . mysubpackage . foo :: ITest sid = u : r : hal_mysubpackage_default : s0 pid = 1891 scontext = u : r : hal_mysubpackage_default : s0 tcontext = u : object_r : default_android_hwservice : s0 tclass = hwservice_manager permissive = 0 10 - 02 15 : 05 : 29.551 1891 1891 E HidlServiceManagement : Service mypackage . mysubpackage . foo @ 1.0 :: ITest / default must be in VINTF manifest in order to register / get . 10 - 02 15 : 05 : 29.551 1891 1891 E mypackage . mysubpackage . foo @ 1.0 - service : Could not register service for ITest HAL ( - 2147483648 ), exiting . 10 - 02 15 : 05 : 28.722 0 0 I init : Service 'mysubpackage_foo_hal_service' ( pid 1891 ) exited with status 1 10 - 02 15 : 05 : 28.722 0 0 I init : Sending signal 9 to service 'mysubpackage_foo_hal_service' ( pid 1891 ) process group ... 10 - 02 15 : 05 : 28.723 0 0 E init : process with updatable components 'mysubpackage_foo_hal_service' exited 4 times in 4 minutes Esse erro ocorre devido ao conflito de regras do domain , definido no arquivo hal_mysubpackage_default.te . Para obter mais informa\u00e7\u00f5es, sugiro checar o curso. Para resolver, vamos novamente usar os seguintes comandos: adb pull /sys/fs/selinux/policy adb logcat -b all -d | audit2allow -p policy Ele retorna a seguinte mensagem: ============= hal_mysubpackage_default ============== allow hal_mysubpackage_default default_android_hwservice:hwservice_manager find; Para resolver isso, foi criado dentro da pasta device/casa/emulator/sepolicy os arquivos: hwservice.te type hal_mysubpackage_hwservice , hwservice_manager_type ; hwservice_contexts mypackage . mysubpackage . foo :: ITest u : object_r : hal_mysubpackage_hwservice : s0 E adicionamos as seguintes linhas ao arquivo: hal_mysubpackage_default.te type hal_mysubpackage_default , domain ; type hal_mysubpackage_default_exec , exec_type , vendor_file_type , file_type ; init_daemon_domain ( hal_mysubpackage_default ); # allow hal_mysubpackage_default hwservicemanager_prop:file read; get_prop ( hal_mysubpackage_default , hwservicemanager_prop ); # allow hal_mysubpackage_default hwservicemanager:binder call; hwbinder_use ( hal_mysubpackage_default ); # allow hal_mysubpackage_default default_android_hwservice:hwservice_manager find; add_hwservice ( hal_mysubpackage_default , hal_mysubpackage_hwservice ); Rebuildando e checando o dmesg , temos a seguinte mensagem: 10 - 02 15 : 27 : 27.714 0 0 I init : Parsing file / vendor / etc / init / mypackage . mysubpackage . foo @ 1.0 - service . rc ... 10 - 02 15 : 27 : 35.135 0 0 I init : starting service 'mysubpackage_foo_hal_service' ... 10 - 02 15 : 27 : 35.135 370 370 I mypackage . mysubpackage . foo @ 1.0 - service : Foo Service 1.0 for test is starting . 10 - 02 15 : 27 : 35.141 370 370 I HidlServiceManagement : Registered mypackage . mysubpackage . foo @ 1.0 :: ITest / default 10 - 02 15 : 27 : 35.141 370 370 I HidlServiceManagement : Removing namespace from process name mypackage . mysubpackage . foo @ 1.0 - service to foo @ 1.0 - service . 10 - 02 15 : 27 : 35.141 370 370 I mypackage . mysubpackage . foo @ 1.0 - service : Test Service is ready Agora nosso servi\u00e7o est\u00e1 com todas as permiss\u00f5es necess\u00e1rias. Observe que algumas das mensagens foram implementadas no arquivo service.cpp","title":"Permiss\u00e3o"},{"location":"Android/HAL/HIDL/#testando","text":"Para criar um bin\u00e1rio para teste, foi criado na pasta device/casa/emulator/interfaces/foo/1.0/default/halTest os seguintes arquivos: HalTest.cpp #include <mypackage/mysubpackage/foo/1.0/ITest.h> #include <hidl/Status.h> #include <hidl/LegacySupport.h> #include <utils/misc.h> #include <hidl/HidlSupport.h> #include <iostream> #include <cstdlib> #include <string> using :: android :: sp ; using :: mypackage :: mysubpackage :: foo :: V1_0 :: ITest ; using android :: hardware :: hidl_string ; int main ( int argc , char * argv []) { if ( argc != 2 ) { std :: cout << \"USAGE ./cpu_client <conservative|powersave|performance|schedutil> \\n \" ; exit ( 0 ); } android :: sp < ITest > cpuService = ITest :: getService (); if ( cpuService == nullptr ) { std :: cout << \"Failed to get cpu service \\n \" ; exit ( -1 ); } cpuService -> getTest ([ & ]( hidl_string result ) { std :: cout << \"getScalingGovernor:\" << result << std :: endl ; }); bool result = cpuService -> setTest ( argv [ 1 ]); std :: cout << \"setScalingGovernor:\" << result << std :: endl ; cpuService -> getTest ([ & ]( hidl_string result ) { std :: cout << \"getScalingGovernor:\" << result << std :: endl ; }); return 0 ; } Android.bp cc_binary { relative_install_path: \"hw\", defaults: [\"hidl_defaults\"], name: \"subpackage_foo_tester\", srcs: [\"HalTest.cpp\"], vendor: true, shared_libs: [ \"liblog\", \"libhardware\", \"libhidlbase\", \"libutils\", \"mypackage.mysubpackage.foo@1.0\", ], } Agora adicionando o bin\u00e1rio ao produto, no arquivo: emulator.mk ... PRODUCT_PACKAGES += \\ mypackage.mysubpackage.foo@1.0 PRODUCT_PACKAGES_DEBUG += \\ subpackage_foo_tester Re-buildando o AOSP e executando os seguintes comandos: 1 2 3 adb root adb shell vendor/bin/hw/subpackage_foo_tester performance O caminho do bin\u00e1rio \u00e9 relativo a vendor=true (vendor/), cc_binary (bin/) e relative_install_path (hw/). O resultado do caminho \u00e9 vendor/bin/hw/ . Checando o dmesg , encontramos a seguinte mensagem: 10 - 02 21 : 03 : 19.861 371 371 I mypackage . mysubpackage . foo @ 1.0 - service : Test : getTest data = ( schedutil 10 - 02 21 : 03 : 19.861 371 371 I mypackage . mysubpackage . foo @ 1.0 - service : ) 10 - 02 21 : 03 : 19.861 371 371 I mypackage . mysubpackage . foo @ 1.0 - service : Test :: setTest data = ( performance ) 10 - 02 21 : 03 : 19.861 371 371 E mypackage . mysubpackage . foo @ 1.0 - service : write_value failed to open 10 - 02 21 : 03 : 19.861 371 371 I mypackage . mysubpackage . foo @ 1.0 - service : Test : getTest data = ( schedutil 10 - 02 21 : 03 : 19.861 371 371 I mypackage . mysubpackage . foo @ 1.0 - service : ) Isso se deve porque somente o usu\u00e1rio root tem permiss\u00e3o para escrever no caminho /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor (definido no arquivo Teste.cpp ). Ent\u00e3o precisamos dar permiss\u00e3o para o nosso aplicativo, para isso vamos adicionar ao arquivo: mypackage.mysubpackage.foo@1.0-service.rc service mysubpackage_foo_hal_service /vendor/bin/hw/mypackage.mysubpackage.foo@1.0-service interface mypackage.mysubpackage.foo@1.0::ITest default class hal user system group system on boot chown system system /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor chmod 0664 /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor Rebuildando e execuntado o bin\u00e1rio de teste, temos a seguinte mensagem : getScalingGovernor:schedutil setScalingGovernor:0 getScalingGovernor:schedutil Obervar que o ScalingGovernor n\u00e3o foi alterado. No log de dmesg , temos essa: 10 - 02 21 : 09 : 09.854 370 370 I mypackage . mysubpackage . foo @ 1.0 - service : Test : getTest data = ( schedutil 10 - 02 21 : 09 : 09.854 370 370 I mypackage . mysubpackage . foo @ 1.0 - service : ) 10 - 02 21 : 09 : 09.854 370 370 I mypackage . mysubpackage . foo @ 1.0 - service : Test :: setTest data = ( performance ) 10 - 02 21 : 09 : 09.854 370 370 E mypackage . mysubpackage . foo @ 1.0 - service : write_value failed to open 10 - 02 21 : 09 : 09.853 370 370 W foo @ 1.0 - service : type = 1400 audit ( 0.0 : 5 ): avc : denied { write } for name = \"scaling_governor\" dev = \"sysfs\" ino = 19629 scontext = u : r : hal_mysubpackage_default : s0 tcontext = u : object_r : sysfs_devices_system_cpu : s0 tclass = file permissive = 0 10 - 02 21 : 09 : 09.858 370 370 I mypackage . mysubpackage . foo @ 1.0 - service : Test : getTest data = ( schedutil 10 - 02 21 : 09 : 09.858 370 370 I mypackage . mysubpackage . foo @ 1.0 - service : ) Como \u00e9 um problema do audit , repetimos os passos: adb pull /sys/fs/selinux/policy adb logcat -b all -d | audit2allow -p policy retornando a mensagem: ============= hal_mysubpackage_default ============== allow hal_mysubpackage_default sysfs_devices_system_cpu:file write; Foi preciso adicionar ao arquivo: hal_mysubpackage_default.te type hal_mysubpackage_default , domain ; type hal_mysubpackage_default_exec , exec_type , vendor_file_type , file_type ; init_daemon_domain ( hal_mysubpackage_default ); # allow hal_mysubpackage_default hwservicemanager_prop:file read; get_prop ( hal_mysubpackage_default , hwservicemanager_prop ); # allow hal_mysubpackage_default hwservicemanager:binder call; hwbinder_use ( hal_mysubpackage_default ); # allow hal_mysubpackage_default default_android_hwservice:hwservice_manager find; add_hwservice ( hal_mysubpackage_default , hal_mysubpackage_hwservice ); allow hal_mysubpackage_default sysfs_devices_system_cpu : file write ; Rebuildando e execuntado o bin\u00e1rio de teste, temos a seguinte mensagem : getScalingGovernor:schedutil setScalingGovernor:1 getScalingGovernor:performance Obervar que o ScalingGovernor foi alterado para performance . No log de dmesg , n\u00e3o encontramos nenhum tipo de erro: 10 - 02 21 : 16 : 46.620 375 375 I mypackage . mysubpackage . foo @ 1.0 - service : Test : getTest data = ( schedutil 10 - 02 21 : 16 : 46.620 375 375 I mypackage . mysubpackage . foo @ 1.0 - service : ) 10 - 02 21 : 16 : 46.620 375 375 I mypackage . mysubpackage . foo @ 1.0 - service : Test :: setTest data = ( performance ) 10 - 02 21 : 16 : 46.639 375 375 I mypackage . mysubpackage . foo @ 1.0 - service : Test : getTest data = ( performance 10 - 02 21 : 16 : 46.639 375 375 I mypackage . mysubpackage . foo @ 1.0 - service : )","title":"Testando"},{"location":"Android/HAL/HIDL/#conclusao","text":"Nesse post eu tentei mostrar de forma mais pr\u00e1tica, como \u00e9 implementado uma HIDL. Existe muita teoria envolvida, principalmente na parte de permiss\u00f5es, que s\u00e3o abordadas de uma forma um pouco mais profunda no curso Android 12 Internals material, labs and discussion . Ao final, fiz um aplicativo para testar a implementa\u00e7\u00e3o. \ud83e\udd47","title":"Conclus\u00e3o"},{"location":"Boards/Beaglebone/Inicio/","text":"In\u00edcio - Beaglebone Assuntos gerais relacionados a Beaglebone Cursos Udemy Embedded Linux Step by Step Using Beaglebone Black Refer\u00eancias Wiki T\u00f3picos USB Serial","title":"In\u00edcio - Beaglebone"},{"location":"Boards/Beaglebone/Inicio/#inicio-beaglebone","text":"Assuntos gerais relacionados a Beaglebone","title":"In\u00edcio - Beaglebone"},{"location":"Boards/Beaglebone/Inicio/#cursos","text":"Udemy Embedded Linux Step by Step Using Beaglebone Black","title":"Cursos"},{"location":"Boards/Beaglebone/Inicio/#referencias","text":"Wiki","title":"Refer\u00eancias"},{"location":"Boards/Beaglebone/Inicio/#topicos","text":"USB Serial","title":"T\u00f3picos"},{"location":"Boards/Beaglebone/USB%20Serial/","text":"USB Serial na Beaglebone Para conseguir debuggar poss\u00edveis problemas, \u00e9 importante visualizar os logs da porta UART . Dispositivo Estou usando o m\u00f3dulo USB Serial equipado com um chip CP2102 M\u00f3dulo Conversor USB TTL CP2102 Serial RS232 Conex\u00f5es A Beaglebone tem seus pinos de UART separados das outras GPIOs , isso facilita na hora de fazer as conex\u00f5es. Conex\u00e3o entre a beaglebone e o m\u00f3dulo USB Serial Visualizando os logs Depois de fazer as conex\u00f5es, podemos utilizar alguns programas para visualizar os logs que saem da UART . Dentre eles, exitem: Minicom Screen Picocom E muitos outros At\u00e9 o momento estou usando o Minicom, mas j\u00e1 usei bastante o Screen. Resultado Visualizando os logs da UART Conex\u00e3o com a Beaglebone","title":"USB Serial na Beaglebone"},{"location":"Boards/Beaglebone/USB%20Serial/#usb-serial-na-beaglebone","text":"Para conseguir debuggar poss\u00edveis problemas, \u00e9 importante visualizar os logs da porta UART .","title":"USB Serial na Beaglebone"},{"location":"Boards/Beaglebone/USB%20Serial/#dispositivo","text":"Estou usando o m\u00f3dulo USB Serial equipado com um chip CP2102 M\u00f3dulo Conversor USB TTL CP2102 Serial RS232","title":"Dispositivo"},{"location":"Boards/Beaglebone/USB%20Serial/#conexoes","text":"A Beaglebone tem seus pinos de UART separados das outras GPIOs , isso facilita na hora de fazer as conex\u00f5es. Conex\u00e3o entre a beaglebone e o m\u00f3dulo USB Serial","title":"Conex\u00f5es"},{"location":"Boards/Beaglebone/USB%20Serial/#visualizando-os-logs","text":"Depois de fazer as conex\u00f5es, podemos utilizar alguns programas para visualizar os logs que saem da UART . Dentre eles, exitem: Minicom Screen Picocom E muitos outros At\u00e9 o momento estou usando o Minicom, mas j\u00e1 usei bastante o Screen.","title":"Visualizando os logs"},{"location":"Boards/Beaglebone/USB%20Serial/#resultado","text":"Visualizando os logs da UART Conex\u00e3o com a Beaglebone","title":"Resultado"},{"location":"Boards/Beaglebone/Bootloader/U-boot/","text":"U-Boot na Beaglebone Image by christoph1703 from Pixabay Introdu\u00e7\u00e3o Dando prosseguimento na minha saga por bootloader para embarcados, vou postar meus passos para usar o U-Boot com SD-Card. Baseado no curso da Udemy -> Embedded Linux Step by Step Using Beaglebone Black Baixando O reposit\u00f3rio oficial do U-Boot \u00e9 o da denx: git clone https://source.denx.de/u-boot/u-boot.git eles tamb\u00e9m mant\u00e9m um espelho no github git clone https://github.com/u-boot/u-boot.git Como a maioria das placas, os criadores portaram o U-Boot para a Beaglebone git clone https://github.com/beagleboard/u-boot.git Buildando Primeiro, foi preciso baixar o toolchain sudo apt install gcc-arm-linux-gnueabihf Tanto o U-Boot mainline quanto o U-Boot beaglebone possuem o mesmo nome de arquivo para as configura\u00e7\u00f5es padr\u00f5es: am335x_evm_defconfig No meu caso, eu utilizei o U-boot mainline . Dessa forma, para criar o .config usei o comando: make ARCH = arm CROSS_COMPILE = arm-linux-gnueabihf- am335x_evm_defconfig OBS: para limpar o ambiente compila\u00e7\u00e3o, basta usar o comando make distclean Por fim, para gerar as imagens, utilizei o comando: make ARCH = arm CROSS_COMPILE = arm-linux-gnueabihf- -j16 OBS: -j \u00e9 o par\u00e2metro que define a quantidade de n\u00facleos de processador utilizado no processo de compila\u00e7\u00e3o. Se tudo ocorrer bem, uma mensagem semelhante a essa deve aparecer: MKIMAGE MLO MKIMAGE MLO.byteswap DTC arch/arm/dts/am335x-pdu001.dtb DTC arch/arm/dts/am335x-chiliboard.dtb DTC arch/arm/dts/am335x-sl50.dtb DTC arch/arm/dts/am335x-base0033.dtb DTC arch/arm/dts/am335x-guardian.dtb DTC arch/arm/dts/am335x-wega-rdk.dtb DTC arch/arm/dts/am335x-regor-rdk.dtb SHIPPED dts/dt.dtb MKIMAGE u-boot.img CAT u-boot-dtb.bin COPY u-boot.dtb MKIMAGE u-boot-dtb.img COPY u-boot.bin Mostrando que os bin\u00e1rios MLO e u-boot.img foram criados. Est\u00e1gios A forma como a Texas Instruments desenvolveu o SOC AM335x ( mais detalhes ), se faz necess\u00e1rio que o processo de boot da placa precise de 3 est\u00e1gios BROM - que \u00e9 definido pela pr\u00f3pria Texas Instruments (n\u00e3o \u00e9 poss\u00edvel modifica-lo) SPL ou Secondary Program Loader - No U-boot chamado de MLO ou Memory LOader O U-boot em si ( u-boot.img ) Para maiores detalhes, checar o Technical Reference manual (TRM). No TRM tamb\u00e9m \u00e9 poss\u00edvel verificar que existe a possibilidade de fazer o boot sem um sistema de arquivos no SD-Card/eMMC, na se\u00e7\u00e3o 26.1.8.5.5 MMC/SD Read Sector Procedure in Raw Mode BROM O BROM faz v\u00e1rias checagens no hardware, mas o que nos interessa nesse est\u00e1gio \u00e9 o que ele busca ap\u00f3s finalizar sua execu\u00e7\u00e3o. O TRM encontramos a seguinte informa\u00e7\u00e3o The next task for the ROM Code is to find the booting file named \u201cMLO\u201d inside the Root Directory of the FAT12/16/32 file system. The file is not searched in any other location. Ou seja, no nosso SD-Card/eMMC precisamos de uma parti\u00e7\u00e3o do tipo FAT12 , FAT16 ou FAT32 . Dentro da parti\u00e7\u00e3o, um arquivo chamado MLO . MLO Resumidamente, o MLO \u00e9 respons\u00e1vel por \"habilitar\" a mem\u00f3ria ram (DRAM) e carregar a imagem do U-Boot para a mesma. Um primeiro teste foi colocar apenas o MLO no SD-Card (sem o u-boot.img ) e ver o que aconteceria. E essa foi a mensagem que retornou: U-Boot SPL 2022.04-rc3-00052-g6d3c46ed0e (Sep 11 2022 - 11:17:49 -0400) Trying to boot from MMC1 spl_load_image_fat: error reading image u-boot.img, err - -2 SPL: failed to boot from all boot devices ### ERROR ### Please RESET the board ### OBS: Para visualizar o logs de boot, cheque esse post Uma mensagem dizendo n\u00e3o foi poss\u00edvel carregar o u-boot.img . Vale ressaltar que esses logs s\u00e3o do MLO , podemos observar refer\u00eancias ao SPL nos logs. Isso j\u00e1 mostra os primeiros sinais de vida da Beaglebone, mostrando que o SD-Card foi formatado corretamente e a placa est\u00e1 conseguindo detectar o mesmo. Com essas confirma\u00e7\u00f5es, podemos seguir em frente. U-boot.img Copiando o bin\u00e1rio u-boot.img para o SD-Card \u00e9 poss\u00edvel ver o u-boot carregado, como podemos ver abaixo: U-Boot SPL 2022.04-rc3-00052-g6d3c46ed0e (Sep 11 2022 - 11:17:49 -0400) Trying to boot from MMC1 U-Boot 2022.04-rc3-00052-g6d3c46ed0e (Sep 11 2022 - 11:17:49 -0400) CPU : AM335X-GP rev 2.1 Model: TI AM335x BeagleBone Black DRAM: 512 MiB Core: 150 devices, 14 uclasses, devicetree: separate WDT: Started wdt@44e35000 with servicing (60s timeout) NAND: 0 MiB MMC: OMAP SD/MMC: 0, OMAP SD/MMC: 1 Loading Environment from FAT... Unable to read \"uboot.env\" from mmc0:1... <ethaddr> not set. Validating first E-fuse MAC Net: eth2: ethernet@4a100000, eth3: usb_ether Hit any key to stop autoboot: 0 Dessa forma, consegui compilar e rodar o U-Boot na minha Beaglebone. Pr\u00f3ximos passos Para o pr\u00f3ximo desafio, fica carregar o kernel Linux. Procurando rapidamente, percebi o u-boot deixou de dar suporte ao arquivo uEnv.txt , o que vai dificultar as coisas um pouco mais. Algumas fontes: https://forum.beagleboard.org/t/u-boot-ignores-uenv-txt/30549/3 Possivelmente esse commit desabilitou o uEnv.txt https://github.com/u-boot/u-boot/commit/ff8f277e9121c6636e21bb7d7381c4dcac2a596b\\ Mas tamb\u00e9m encontrei, que existe uma outra forma de carregar as imagens do Kernel e o DTB . Utilizando o Distro Boot ( ref ) Al\u00e9m de fazer da forma tradicional, que \u00e9 criando o pr\u00f3prio script de boot ( ref ) cat <<\"EOF\" > boot.cmd mmc dev 0 fatload mmc 0:1 ${kernel_addr_r} zImage setenv bootargs console=tty1 console=ttyAMA0,115200 earlyprintk root=/dev/mmcblk0p2 rootwait bootz ${kernel_addr_r} - ${fdt_addr} EOF tools/mkimage -C none -A arm -T script -d boot.cmd boot.scr","title":"U-Boot na Beaglebone"},{"location":"Boards/Beaglebone/Bootloader/U-boot/#u-boot-na-beaglebone","text":"Image by christoph1703 from Pixabay","title":"U-Boot na Beaglebone"},{"location":"Boards/Beaglebone/Bootloader/U-boot/#introducao","text":"Dando prosseguimento na minha saga por bootloader para embarcados, vou postar meus passos para usar o U-Boot com SD-Card. Baseado no curso da Udemy -> Embedded Linux Step by Step Using Beaglebone Black","title":"Introdu\u00e7\u00e3o"},{"location":"Boards/Beaglebone/Bootloader/U-boot/#baixando","text":"O reposit\u00f3rio oficial do U-Boot \u00e9 o da denx: git clone https://source.denx.de/u-boot/u-boot.git eles tamb\u00e9m mant\u00e9m um espelho no github git clone https://github.com/u-boot/u-boot.git Como a maioria das placas, os criadores portaram o U-Boot para a Beaglebone git clone https://github.com/beagleboard/u-boot.git","title":"Baixando"},{"location":"Boards/Beaglebone/Bootloader/U-boot/#buildando","text":"Primeiro, foi preciso baixar o toolchain sudo apt install gcc-arm-linux-gnueabihf Tanto o U-Boot mainline quanto o U-Boot beaglebone possuem o mesmo nome de arquivo para as configura\u00e7\u00f5es padr\u00f5es: am335x_evm_defconfig No meu caso, eu utilizei o U-boot mainline . Dessa forma, para criar o .config usei o comando: make ARCH = arm CROSS_COMPILE = arm-linux-gnueabihf- am335x_evm_defconfig OBS: para limpar o ambiente compila\u00e7\u00e3o, basta usar o comando make distclean Por fim, para gerar as imagens, utilizei o comando: make ARCH = arm CROSS_COMPILE = arm-linux-gnueabihf- -j16 OBS: -j \u00e9 o par\u00e2metro que define a quantidade de n\u00facleos de processador utilizado no processo de compila\u00e7\u00e3o. Se tudo ocorrer bem, uma mensagem semelhante a essa deve aparecer: MKIMAGE MLO MKIMAGE MLO.byteswap DTC arch/arm/dts/am335x-pdu001.dtb DTC arch/arm/dts/am335x-chiliboard.dtb DTC arch/arm/dts/am335x-sl50.dtb DTC arch/arm/dts/am335x-base0033.dtb DTC arch/arm/dts/am335x-guardian.dtb DTC arch/arm/dts/am335x-wega-rdk.dtb DTC arch/arm/dts/am335x-regor-rdk.dtb SHIPPED dts/dt.dtb MKIMAGE u-boot.img CAT u-boot-dtb.bin COPY u-boot.dtb MKIMAGE u-boot-dtb.img COPY u-boot.bin Mostrando que os bin\u00e1rios MLO e u-boot.img foram criados.","title":"Buildando"},{"location":"Boards/Beaglebone/Bootloader/U-boot/#estagios","text":"A forma como a Texas Instruments desenvolveu o SOC AM335x ( mais detalhes ), se faz necess\u00e1rio que o processo de boot da placa precise de 3 est\u00e1gios BROM - que \u00e9 definido pela pr\u00f3pria Texas Instruments (n\u00e3o \u00e9 poss\u00edvel modifica-lo) SPL ou Secondary Program Loader - No U-boot chamado de MLO ou Memory LOader O U-boot em si ( u-boot.img ) Para maiores detalhes, checar o Technical Reference manual (TRM). No TRM tamb\u00e9m \u00e9 poss\u00edvel verificar que existe a possibilidade de fazer o boot sem um sistema de arquivos no SD-Card/eMMC, na se\u00e7\u00e3o 26.1.8.5.5 MMC/SD Read Sector Procedure in Raw Mode","title":"Est\u00e1gios"},{"location":"Boards/Beaglebone/Bootloader/U-boot/#brom","text":"O BROM faz v\u00e1rias checagens no hardware, mas o que nos interessa nesse est\u00e1gio \u00e9 o que ele busca ap\u00f3s finalizar sua execu\u00e7\u00e3o. O TRM encontramos a seguinte informa\u00e7\u00e3o The next task for the ROM Code is to find the booting file named \u201cMLO\u201d inside the Root Directory of the FAT12/16/32 file system. The file is not searched in any other location. Ou seja, no nosso SD-Card/eMMC precisamos de uma parti\u00e7\u00e3o do tipo FAT12 , FAT16 ou FAT32 . Dentro da parti\u00e7\u00e3o, um arquivo chamado MLO .","title":"BROM"},{"location":"Boards/Beaglebone/Bootloader/U-boot/#mlo","text":"Resumidamente, o MLO \u00e9 respons\u00e1vel por \"habilitar\" a mem\u00f3ria ram (DRAM) e carregar a imagem do U-Boot para a mesma. Um primeiro teste foi colocar apenas o MLO no SD-Card (sem o u-boot.img ) e ver o que aconteceria. E essa foi a mensagem que retornou: U-Boot SPL 2022.04-rc3-00052-g6d3c46ed0e (Sep 11 2022 - 11:17:49 -0400) Trying to boot from MMC1 spl_load_image_fat: error reading image u-boot.img, err - -2 SPL: failed to boot from all boot devices ### ERROR ### Please RESET the board ### OBS: Para visualizar o logs de boot, cheque esse post Uma mensagem dizendo n\u00e3o foi poss\u00edvel carregar o u-boot.img . Vale ressaltar que esses logs s\u00e3o do MLO , podemos observar refer\u00eancias ao SPL nos logs. Isso j\u00e1 mostra os primeiros sinais de vida da Beaglebone, mostrando que o SD-Card foi formatado corretamente e a placa est\u00e1 conseguindo detectar o mesmo. Com essas confirma\u00e7\u00f5es, podemos seguir em frente.","title":"MLO"},{"location":"Boards/Beaglebone/Bootloader/U-boot/#u-bootimg","text":"Copiando o bin\u00e1rio u-boot.img para o SD-Card \u00e9 poss\u00edvel ver o u-boot carregado, como podemos ver abaixo: U-Boot SPL 2022.04-rc3-00052-g6d3c46ed0e (Sep 11 2022 - 11:17:49 -0400) Trying to boot from MMC1 U-Boot 2022.04-rc3-00052-g6d3c46ed0e (Sep 11 2022 - 11:17:49 -0400) CPU : AM335X-GP rev 2.1 Model: TI AM335x BeagleBone Black DRAM: 512 MiB Core: 150 devices, 14 uclasses, devicetree: separate WDT: Started wdt@44e35000 with servicing (60s timeout) NAND: 0 MiB MMC: OMAP SD/MMC: 0, OMAP SD/MMC: 1 Loading Environment from FAT... Unable to read \"uboot.env\" from mmc0:1... <ethaddr> not set. Validating first E-fuse MAC Net: eth2: ethernet@4a100000, eth3: usb_ether Hit any key to stop autoboot: 0 Dessa forma, consegui compilar e rodar o U-Boot na minha Beaglebone.","title":"U-boot.img"},{"location":"Boards/Beaglebone/Bootloader/U-boot/#proximos-passos","text":"Para o pr\u00f3ximo desafio, fica carregar o kernel Linux. Procurando rapidamente, percebi o u-boot deixou de dar suporte ao arquivo uEnv.txt , o que vai dificultar as coisas um pouco mais. Algumas fontes: https://forum.beagleboard.org/t/u-boot-ignores-uenv-txt/30549/3 Possivelmente esse commit desabilitou o uEnv.txt https://github.com/u-boot/u-boot/commit/ff8f277e9121c6636e21bb7d7381c4dcac2a596b\\ Mas tamb\u00e9m encontrei, que existe uma outra forma de carregar as imagens do Kernel e o DTB . Utilizando o Distro Boot ( ref ) Al\u00e9m de fazer da forma tradicional, que \u00e9 criando o pr\u00f3prio script de boot ( ref ) cat <<\"EOF\" > boot.cmd mmc dev 0 fatload mmc 0:1 ${kernel_addr_r} zImage setenv bootargs console=tty1 console=ttyAMA0,115200 earlyprintk root=/dev/mmcblk0p2 rootwait bootz ${kernel_addr_r} - ${fdt_addr} EOF tools/mkimage -C none -A arm -T script -d boot.cmd boot.scr","title":"Pr\u00f3ximos passos"},{"location":"Boards/Qemu/Bootloader/LittleKernel/","text":"LittleKernel Image by StartupStockPhotos from Pixabay Introdu\u00e7\u00e3o Recentemente descobri que grandes empresas utilizam uma alternativa ao U-Boot para bootloader . Por isso, resolvi escrever esse post sobre o LittleKernel . Ele n\u00e3o tem a popularidade do U-Boot , mas \u00e9 t\u00e3o antigo quanto. Devido sua impopularidade, vamos primeiro seguir o tutorial que utiliza o QEMU . Para que tenhamos um ambiente minimamente funcional. Baixando o LittleKernel O LittleKernel est\u00e1 hospedado no github. Para baixa-lo, basta utilizar o comando: git clone https://github.com/littlekernel/lk.git Checando o diret\u00f3rios com o comando tree -L 1 . , temos a seguinte configura\u00e7\u00e3o: . \u251c\u2500\u2500 app \u251c\u2500\u2500 arch \u251c\u2500\u2500 build-qemu-virt-arm32-test \u251c\u2500\u2500 dev \u251c\u2500\u2500 docs \u251c\u2500\u2500 engine.mk \u251c\u2500\u2500 external \u251c\u2500\u2500 kernel \u251c\u2500\u2500 lib \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 lk_inc.mk.example \u251c\u2500\u2500 make \u251c\u2500\u2500 makefile \u251c\u2500\u2500 platform \u251c\u2500\u2500 project \u251c\u2500\u2500 README.md \u251c\u2500\u2500 scripts \u251c\u2500\u2500 target \u251c\u2500\u2500 tools \u2514\u2500\u2500 top Instalando as depend\u00eancias Para esse post, vou utilizar o qemu-system-arm . Para isso, \u00e9 preciso instala-lo: sudo apt-install qemu-system-arm Na pr\u00f3pria p\u00e1gina do Littekernel tem uma sugest\u00e3o para toolchain : sudo apt-get install gcc-arm-none-eabi E essas s\u00e3o as depend\u00eancias iniciais. Buildando Os desenvolvedores do LittleKernel fornecem um script para rodar o bootloader no QEMU . Basta entrar na pasta do reposit\u00f3rio e digitar: scripts/do-qemuarm Esse comando ir\u00e1 compilar o LittleKernel e carrega-lo no QEMU . Como resultado o terminal (ou console) do bootloader ser\u00e1 carregado e as seguintes mensagens devem parecer: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 welcome to lk/MP boot args 0x0 0x0 0x0 0x0 INIT: cpu 0 , calling hook 0x8011c5ed ( version ) at level 0x3ffff, flags 0x1 version: arch: arm platform: qemu-virt-arm target: qemu-virt-arm project: qemu-virt-arm32-test buildid: L9PCS_LOCAL INIT: cpu 0 , calling hook 0x8011e18d ( vm_preheap ) at level 0x3ffff, flags 0x1 initializing heap calling constructors INIT: cpu 0 , calling hook 0x8011e1d5 ( vm ) at level 0x4ffff, flags 0x1 initializing mp initializing threads initializing timers initializing ports creating bootstrap completion thread top of bootstrap2 () INIT: cpu 0 , calling hook 0x801196e9 ( minip ) at level 0x70000, flags 0x1 INIT: cpu 0 , calling hook 0x80119eb1 ( pktbuf ) at level 0x70000, flags 0x1 pktbuf: creating 256 pktbuf entries of size 1536 ( total 393216 ) INIT: cpu 0 , calling hook 0x8011cf85 ( virtio ) at level 0x70000, flags 0x1 releasing 0 secondary cpus initializing platform PCIE: initializing pcie with ecam at 0x3f000000 found in FDT PCI: pci ecam functions installed PCI: last pci bus is 15 PCI dump: bus 0 dev 0000 :00:00.0 vid:pid 1b36:0008 base:sub:intr 6 :0:0 PCI dump post assign: bus 0 dev 0000 :00:00.0 vid:pid 1b36:0008 base:sub:intr 6 :0:0 initializing target INIT: cpu 0 , calling hook 0x8011ced5 ( e1000 ) at level 0x90001, flags 0x1 initializing apps starting app inetsrv starting internet servers starting app shell entering main console loop ] Pode digitar o comando help e come\u00e7ar a desbrav\u00e1-lo. Para sair, \u00e9 preciso usar as seguintes teclas: CTRL + A e depois c . O terminal sair\u00e1 do LittleKernel e entrar\u00e1 no QEMU : QEMU 4 .2.1 monitor - type 'help' for more information ( qemu ) Por fim, bast digitar quit . Decifrando o do-qemuarm Esse script possui muitas linhas, mas as 3 \u00faltimas linhas resumem o processo: 132 133 134 $DIR /make-parallel $MAKE_VARS $PROJECT && echo $SUDO $QEMU $ARGS $@ && $SUDO $QEMU $ARGS $@ Na linha 132 : $MAKE_VARS \u00e9 vazio $PROJECT \u00e9 \"qemu-virt-arm32-test\" Esse nome \u00e9 referente a um arquivo dentro do diret\u00f3rio projects/ na pasta raiz. Esses s\u00e3o os par\u00e2metros para compilar o LittleKernel . Na linha 133 : Mostra o comando completo para emula\u00e7\u00e3o do LittleKernel pelo QEMU : qemu-system-arm -cpu cortex-a15 -m 512 -smp 1 -machine virt,highmem = off -kernel build-qemu-virt-arm32-test/lk.elf -net none -nographic Baseado no comando gerado, pode-se observar que \u00e9 criado a pasta build-qemu-virt-arm32-test e dentro dela o arquivo lk.elf . Esse arquivo \u00e9 o bin\u00e1rio gerado pela compila\u00e7\u00e3o do LittleKernel . Na linha 134 : Executa a emula\u00e7\u00e3o. Conclus\u00e3o Com esses passos \u00e9 poss\u00edvel come\u00e7ar a explorar o LittleKernel e tirar as primeiras impress\u00f5es. Particularmente, achei a estrutura de pastas mais amig\u00e1vel que o do U-Boot . Isso n\u00e3o quer dizer que seja melhor ou pior, mas parece mais f\u00e1cil de organizar.","title":"LittleKernel"},{"location":"Boards/Qemu/Bootloader/LittleKernel/#littlekernel","text":"Image by StartupStockPhotos from Pixabay","title":"LittleKernel"},{"location":"Boards/Qemu/Bootloader/LittleKernel/#introducao","text":"Recentemente descobri que grandes empresas utilizam uma alternativa ao U-Boot para bootloader . Por isso, resolvi escrever esse post sobre o LittleKernel . Ele n\u00e3o tem a popularidade do U-Boot , mas \u00e9 t\u00e3o antigo quanto. Devido sua impopularidade, vamos primeiro seguir o tutorial que utiliza o QEMU . Para que tenhamos um ambiente minimamente funcional.","title":"Introdu\u00e7\u00e3o"},{"location":"Boards/Qemu/Bootloader/LittleKernel/#baixando-o-littlekernel","text":"O LittleKernel est\u00e1 hospedado no github. Para baixa-lo, basta utilizar o comando: git clone https://github.com/littlekernel/lk.git Checando o diret\u00f3rios com o comando tree -L 1 . , temos a seguinte configura\u00e7\u00e3o: . \u251c\u2500\u2500 app \u251c\u2500\u2500 arch \u251c\u2500\u2500 build-qemu-virt-arm32-test \u251c\u2500\u2500 dev \u251c\u2500\u2500 docs \u251c\u2500\u2500 engine.mk \u251c\u2500\u2500 external \u251c\u2500\u2500 kernel \u251c\u2500\u2500 lib \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 lk_inc.mk.example \u251c\u2500\u2500 make \u251c\u2500\u2500 makefile \u251c\u2500\u2500 platform \u251c\u2500\u2500 project \u251c\u2500\u2500 README.md \u251c\u2500\u2500 scripts \u251c\u2500\u2500 target \u251c\u2500\u2500 tools \u2514\u2500\u2500 top","title":"Baixando o LittleKernel"},{"location":"Boards/Qemu/Bootloader/LittleKernel/#instalando-as-dependencias","text":"Para esse post, vou utilizar o qemu-system-arm . Para isso, \u00e9 preciso instala-lo: sudo apt-install qemu-system-arm Na pr\u00f3pria p\u00e1gina do Littekernel tem uma sugest\u00e3o para toolchain : sudo apt-get install gcc-arm-none-eabi E essas s\u00e3o as depend\u00eancias iniciais.","title":"Instalando as depend\u00eancias"},{"location":"Boards/Qemu/Bootloader/LittleKernel/#buildando","text":"Os desenvolvedores do LittleKernel fornecem um script para rodar o bootloader no QEMU . Basta entrar na pasta do reposit\u00f3rio e digitar: scripts/do-qemuarm Esse comando ir\u00e1 compilar o LittleKernel e carrega-lo no QEMU . Como resultado o terminal (ou console) do bootloader ser\u00e1 carregado e as seguintes mensagens devem parecer: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 welcome to lk/MP boot args 0x0 0x0 0x0 0x0 INIT: cpu 0 , calling hook 0x8011c5ed ( version ) at level 0x3ffff, flags 0x1 version: arch: arm platform: qemu-virt-arm target: qemu-virt-arm project: qemu-virt-arm32-test buildid: L9PCS_LOCAL INIT: cpu 0 , calling hook 0x8011e18d ( vm_preheap ) at level 0x3ffff, flags 0x1 initializing heap calling constructors INIT: cpu 0 , calling hook 0x8011e1d5 ( vm ) at level 0x4ffff, flags 0x1 initializing mp initializing threads initializing timers initializing ports creating bootstrap completion thread top of bootstrap2 () INIT: cpu 0 , calling hook 0x801196e9 ( minip ) at level 0x70000, flags 0x1 INIT: cpu 0 , calling hook 0x80119eb1 ( pktbuf ) at level 0x70000, flags 0x1 pktbuf: creating 256 pktbuf entries of size 1536 ( total 393216 ) INIT: cpu 0 , calling hook 0x8011cf85 ( virtio ) at level 0x70000, flags 0x1 releasing 0 secondary cpus initializing platform PCIE: initializing pcie with ecam at 0x3f000000 found in FDT PCI: pci ecam functions installed PCI: last pci bus is 15 PCI dump: bus 0 dev 0000 :00:00.0 vid:pid 1b36:0008 base:sub:intr 6 :0:0 PCI dump post assign: bus 0 dev 0000 :00:00.0 vid:pid 1b36:0008 base:sub:intr 6 :0:0 initializing target INIT: cpu 0 , calling hook 0x8011ced5 ( e1000 ) at level 0x90001, flags 0x1 initializing apps starting app inetsrv starting internet servers starting app shell entering main console loop ] Pode digitar o comando help e come\u00e7ar a desbrav\u00e1-lo. Para sair, \u00e9 preciso usar as seguintes teclas: CTRL + A e depois c . O terminal sair\u00e1 do LittleKernel e entrar\u00e1 no QEMU : QEMU 4 .2.1 monitor - type 'help' for more information ( qemu ) Por fim, bast digitar quit .","title":"Buildando"},{"location":"Boards/Qemu/Bootloader/LittleKernel/#decifrando-o-do-qemuarm","text":"Esse script possui muitas linhas, mas as 3 \u00faltimas linhas resumem o processo: 132 133 134 $DIR /make-parallel $MAKE_VARS $PROJECT && echo $SUDO $QEMU $ARGS $@ && $SUDO $QEMU $ARGS $@ Na linha 132 : $MAKE_VARS \u00e9 vazio $PROJECT \u00e9 \"qemu-virt-arm32-test\" Esse nome \u00e9 referente a um arquivo dentro do diret\u00f3rio projects/ na pasta raiz. Esses s\u00e3o os par\u00e2metros para compilar o LittleKernel . Na linha 133 : Mostra o comando completo para emula\u00e7\u00e3o do LittleKernel pelo QEMU : qemu-system-arm -cpu cortex-a15 -m 512 -smp 1 -machine virt,highmem = off -kernel build-qemu-virt-arm32-test/lk.elf -net none -nographic Baseado no comando gerado, pode-se observar que \u00e9 criado a pasta build-qemu-virt-arm32-test e dentro dela o arquivo lk.elf . Esse arquivo \u00e9 o bin\u00e1rio gerado pela compila\u00e7\u00e3o do LittleKernel . Na linha 134 : Executa a emula\u00e7\u00e3o.","title":"Decifrando o do-qemuarm"},{"location":"Boards/Qemu/Bootloader/LittleKernel/#conclusao","text":"Com esses passos \u00e9 poss\u00edvel come\u00e7ar a explorar o LittleKernel e tirar as primeiras impress\u00f5es. Particularmente, achei a estrutura de pastas mais amig\u00e1vel que o do U-Boot . Isso n\u00e3o quer dizer que seja melhor ou pior, mas parece mais f\u00e1cil de organizar.","title":"Conclus\u00e3o"},{"location":"Boards/Qemu/Bootloader/U-boot_qemu/","text":"U-boot Image by PublicDomainPictures from Pixabay Introdu\u00e7\u00e3o A fim de ter um ambiente de testes para aprender sobre o U-Boot, o mais recomendado \u00e9 criar um ambiente virtual. Para isso, eu escolhi o QEMU, que \u00e9 altamente configur\u00e1vel. Essa postagem tem como base a arquitetura aarch64 , devido sua larga utiliza\u00e7\u00e3o em sistemas embarcados. Baixando o U-Boot mainline Basta copiar e colar o c\u00f3digo abaixo: git clone https://source.denx.de/u-boot/u-boot.git Buildando o U-boot A seguir s\u00e3o definidos alguns passos para gerar o bin\u00e1rio do U-boot, que ser\u00e1 utilizado pelo QEMU. Instalando Depend\u00eancias Dependendo do sistema utilizado, alguns pacotes ser\u00e3o necess\u00e1rios para que o processo de build tenha sucesso. No meu ambiente ( ubuntu 22.04 ), foram necess\u00e1rio os seguintes pacotes: sudo apt install \\ flex \\ bison \\ gcc-aarch64-linux-gnu \\ Definindo a Arquitetura Para criar um sistema de build limpo, o par\u00e2metro O= foi utilizado. Dentro da pasta do U-Boot, cole o c\u00f3digo abaixo: make O=../out qemu_arm64_defconfig -j16 Se tudo ocorrer bem, a mensagem a seguir deve aparecer: Uma pasta out foi criada, adicionando todos os itens necess\u00e1rios para a build. Gerando o Bin\u00e1rio Dentro da pasta out , cole o c\u00f3digo abaixo: make CROSS_COMPILE=aarch64-linux-gnu- -j16 Se tudo ocorrer corretamente o arquivo u-boot.bin ser\u00e1 criado. Carregando o U-boot com QEMU Para utilizar o QEMU para arquiteturas ARM64 \u00e9 necess\u00e1rio instalar o pacote: sudo apt install qemu-system-arm Dentro da pasta out , execute o seguinte comando: qemu-system-aarch64 -M virt -nographic -cpu cortex-a57 -bios u-boot.bin onde o par\u00e2metro -bios \u00e9 o binario que acabou de ser criado pela nossa build. Ap\u00f3s executar o comando, o u-boot dever\u00e1 iniciar normalmente:","title":"U-boot"},{"location":"Boards/Qemu/Bootloader/U-boot_qemu/#u-boot","text":"Image by PublicDomainPictures from Pixabay","title":"U-boot"},{"location":"Boards/Qemu/Bootloader/U-boot_qemu/#introducao","text":"A fim de ter um ambiente de testes para aprender sobre o U-Boot, o mais recomendado \u00e9 criar um ambiente virtual. Para isso, eu escolhi o QEMU, que \u00e9 altamente configur\u00e1vel. Essa postagem tem como base a arquitetura aarch64 , devido sua larga utiliza\u00e7\u00e3o em sistemas embarcados.","title":"Introdu\u00e7\u00e3o"},{"location":"Boards/Qemu/Bootloader/U-boot_qemu/#baixando-o-u-boot-mainline","text":"Basta copiar e colar o c\u00f3digo abaixo: git clone https://source.denx.de/u-boot/u-boot.git","title":"Baixando o U-Boot mainline"},{"location":"Boards/Qemu/Bootloader/U-boot_qemu/#buildando-o-u-boot","text":"A seguir s\u00e3o definidos alguns passos para gerar o bin\u00e1rio do U-boot, que ser\u00e1 utilizado pelo QEMU.","title":"Buildando o U-boot"},{"location":"Boards/Qemu/Bootloader/U-boot_qemu/#instalando-dependencias","text":"Dependendo do sistema utilizado, alguns pacotes ser\u00e3o necess\u00e1rios para que o processo de build tenha sucesso. No meu ambiente ( ubuntu 22.04 ), foram necess\u00e1rio os seguintes pacotes: sudo apt install \\ flex \\ bison \\ gcc-aarch64-linux-gnu \\","title":"Instalando Depend\u00eancias"},{"location":"Boards/Qemu/Bootloader/U-boot_qemu/#definindo-a-arquitetura","text":"Para criar um sistema de build limpo, o par\u00e2metro O= foi utilizado. Dentro da pasta do U-Boot, cole o c\u00f3digo abaixo: make O=../out qemu_arm64_defconfig -j16 Se tudo ocorrer bem, a mensagem a seguir deve aparecer: Uma pasta out foi criada, adicionando todos os itens necess\u00e1rios para a build.","title":"Definindo a Arquitetura"},{"location":"Boards/Qemu/Bootloader/U-boot_qemu/#gerando-o-binario","text":"Dentro da pasta out , cole o c\u00f3digo abaixo: make CROSS_COMPILE=aarch64-linux-gnu- -j16 Se tudo ocorrer corretamente o arquivo u-boot.bin ser\u00e1 criado.","title":"Gerando o Bin\u00e1rio"},{"location":"Boards/Qemu/Bootloader/U-boot_qemu/#carregando-o-u-boot-com-qemu","text":"Para utilizar o QEMU para arquiteturas ARM64 \u00e9 necess\u00e1rio instalar o pacote: sudo apt install qemu-system-arm Dentro da pasta out , execute o seguinte comando: qemu-system-aarch64 -M virt -nographic -cpu cortex-a57 -bios u-boot.bin onde o par\u00e2metro -bios \u00e9 o binario que acabou de ser criado pela nossa build. Ap\u00f3s executar o comando, o u-boot dever\u00e1 iniciar normalmente:","title":"Carregando o U-boot com QEMU"},{"location":"Boards/VIM3/Android/Bootloader/Carregando/","text":"Decifrando o BOOTCMD Image by Gerd Altmann from Pixabay Introdu\u00e7\u00e3o Na minha saga para desvendar o mundo dos sistemas embarcados, nesse post eu pretendo entender explicar como o u-boot mainline carrega o kernel Android na VIM3 . O bootcmd Depois que que o u-boot \u00e9 carregado, ele executa comandos para encontrar o kernel. Para isso, \u00e9 gerado um script para checar as poss\u00edveis formas de carrega-lo. O primeiro passo foi dar o comando printenv no console do u-boot, resultando nas seguintes informa\u00e7\u00f5es: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 arch = arm avb_verify = avb init ${ mmcdev } ; avb verify $slot_suffix ; baudrate = 115200 board = vim3 board_name = vim3 boot_a_script = load ${ devtype } ${ devnum } : ${ distro_bootpart } ${ scriptaddr } ${ prefix }${ script } ; source ${ scriptaddr } boot_efi_binary = load ${ devtype } ${ devnum } : ${ distro_bootpart } ${ kernel_addr_r } efi/boot/bootaa64.efi ; if fdt addr -q ${ fdt_addr_r } ; then bootefi ${ kernel_addr_r } ${ fdt_addr_r } ; else bootefi ${ kernel_addr_r } ${ fdtcontroladdr } ; fi boot_efi_bootmgr = if fdt addr -q ${ fdt_addr_r } ; then bootefi bootmgr ${ fdt_addr_r } ; else bootefi bootmgr ; fi boot_extlinux = sysboot ${ devtype } ${ devnum } : ${ distro_bootpart } any ${ scriptaddr } ${ prefix }${ boot_syslinux_conf } boot_net_usb_start = usb start boot_pci_enum = pci enum boot_prefixes = / /boot/ boot_script_dhcp = boot.scr.uimg boot_scripts = boot.scr.uimg boot.scr boot_source = sd boot_syslinux_conf = extlinux/extlinux.conf boot_targets = fastboot recovery system panic bootcmd = run distro_bootcmd bootcmd_fastboot = setenv run_fastboot 0 ; if test \" ${ boot_source } \" = \"usb\" ; then echo Fastboot forced by usb rom boot ; setenv run_fastboot 1 ; fi ; if test \" ${ run_fastboot } \" -eq 0 ; then if gpt verify mmc ${ mmcdev } ${ partitions } ; then ; else echo Broken MMC partition scheme ; setenv run_fastboot 1 ; fi ; fi ; if test \" ${ run_fastboot } \" -eq 0 ; then if bcb load 2 misc ; then if bcb test command = bootonce-bootloader ; then echo BCB: Bootloader boot... ; bcb clear command ; bcb store ; setenv run_fastboot 1 ; elif bcb test command = boot-fastboot ; then echo BCB: fastboot userspace boot... ; setenv force_recovery 1 ; fi ; else echo Warning: BCB is corrupted or does not exist ; fi ; fi ; if test \" ${ run_fastboot } \" -eq 1 ; then echo Running Fastboot... ; fastboot 0 ; fi bootcmd_panic = fastboot 0 ; reset bootcmd_recovery = pinmux dev pinctrl@14 ; pinmux dev pinctrl@40 ; setenv run_recovery 0 ; if run check_button ; then echo Recovery button is pressed ; setenv run_recovery 1 ; fi ; if bcb load 2 misc ; then if bcb test command = boot-recovery ; then echo BCB: Recovery boot... ; setenv run_recovery 1 ; fi ; else echo Warning: BCB is corrupted or does not exist ; fi ; if test \" ${ skip_recovery } \" -eq 1 ; then echo Recovery skipped by environment ; setenv run_recovery 0 ; fi ; if test \" ${ force_recovery } \" -eq 1 ; then echo Recovery forced by environment ; setenv run_recovery 1 ; fi ; if test \" ${ run_recovery } \" -eq 1 ; then echo Running Recovery... ; mmc dev ${ mmcdev } ; setenv bootargs \" ${ bootargs } androidboot.serialno= ${ serial # } \" ; if test \" ${ force_avb } \" -eq 1 ; then if run avb_verify ; then echo AVB verification OK. ; setenv bootargs \" $bootargs $avb_bootargs \" ; else echo AVB verification failed. ; exit ; fi ; else setenv bootargs \" $bootargs androidboot.verifiedbootstate=orange\" ; echo Running without AVB... ; fi ; part start mmc ${ mmcdev } recovery ${ slot_suffix } boot_start ; part size mmc ${ mmcdev } recovery ${ slot_suffix } boot_size ; if mmc read ${ loadaddr } ${ boot_start } ${ boot_size } ; then echo Preparing FDT... ; if test $board_name = sei510 ; then echo \" Reading DTB for sei510...\" ; setenv dtb_index 0 ; elif test $board_name = sei610 ; then echo \" Reading DTB for sei610...\" ; setenv dtb_index 1 ; elif test $board_name = vim3l ; then echo \" Reading DTB for vim3l...\" ; setenv dtb_index 2 ; elif test $board_name = vim3 ; then echo \" Reading DTB for vim3...\" ; setenv dtb_index 3 ; else echo Error: Android boot is not supported for $board_name ; exit ; fi ; abootimg get dtb --index = $dtb_index dtb_start dtb_size ; cp.b $dtb_start $fdt_addr_r $dtb_size ; fdt addr $fdt_addr_r 0x80000 ; if test $board_name = sei510 ; then echo \" Reading DTBO for sei510...\" ; setenv dtbo_index 0 ; elif test $board_name = sei610 ; then echo \" Reading DTBO for sei610...\" ; setenv dtbo_index 1 ; elif test $board_name = vim3l ; then echo \" Reading DTBO for vim3l...\" ; setenv dtbo_index 2 ; elif test $board_name = vim3 ; then echo \" Reading DTBO for vim3...\" ; setenv dtbo_index 3 ; else echo Error: Android boot is not supported for $board_name ; exit ; fi ; part start mmc ${ mmcdev } dtbo ${ slot_suffix } p_dtbo_start ; part size mmc ${ mmcdev } dtbo ${ slot_suffix } p_dtbo_size ; mmc read ${ dtboaddr } ${ p_dtbo_start } ${ p_dtbo_size } ; echo \" Applying DTBOs...\" ; adtimg addr $dtboaddr ; adtimg get dt --index = $dtbo_index dtbo0_addr ; fdt apply $dtbo0_addr ; setenv bootargs \" $bootargs androidboot.dtbo_idx= $dtbo_index \" ; echo Running Android Recovery... ; bootm ${ loadaddr } ${ loadaddr } ${ fdt_addr_r } ; fi ; echo Failed to boot Android... ; reset ; fi bootcmd_system = echo Loading Android boot partition... ; mmc dev ${ mmcdev } ; setenv bootargs ${ bootargs } androidboot.serialno = ${ serial # } ; if test \" ${ force_avb } \" -eq 1 ; then if run avb_verify ; then echo AVB verification OK. ; setenv bootargs \" $bootargs $avb_bootargs \" ; else echo AVB verification failed. ; exit ; fi ; else setenv bootargs \" $bootargs androidboot.verifiedbootstate=orange\" ; echo Running without AVB... ; fi ; part start mmc ${ mmcdev } boot ${ slot_suffix } boot_start ; part size mmc ${ mmcdev } boot ${ slot_suffix } boot_size ; if mmc read ${ loadaddr } ${ boot_start } ${ boot_size } ; then echo Preparing FDT... ; if test $board_name = sei510 ; then echo \" Reading DTB for sei510...\" ; setenv dtb_index 0 ; elif test $board_name = sei610 ; then echo \" Reading DTB for sei610...\" ; setenv dtb_index 1 ; elif test $board_name = vim3l ; then echo \" Reading DTB for vim3l...\" ; setenv dtb_index 2 ; elif test $board_name = vim3 ; then echo \" Reading DTB for vim3...\" ; setenv dtb_index 3 ; else echo Error: Android boot is not supported for $board_name ; exit ; fi ; abootimg get dtb --index = $dtb_index dtb_start dtb_size ; cp.b $dtb_start $fdt_addr_r $dtb_size ; fdt addr $fdt_addr_r 0x80000 ; if test $board_name = sei510 ; then echo \" Reading DTBO for sei510...\" ; setenv dtbo_index 0 ; elif test $board_name = sei610 ; then echo \" Reading DTBO for sei610...\" ; setenv dtbo_index 1 ; elif test $board_name = vim3l ; then echo \" Reading DTBO for vim3l...\" ; setenv dtbo_index 2 ; elif test $board_name = vim3 ; then echo \" Reading DTBO for vim3...\" ; setenv dtbo_index 3 ; else echo Error: Android boot is not supported for $board_name ; exit ; fi ; part start mmc ${ mmcdev } dtbo ${ slot_suffix } p_dtbo_start ; part size mmc ${ mmcdev } dtbo ${ slot_suffix } p_dtbo_size ; mmc read ${ dtboaddr } ${ p_dtbo_start } ${ p_dtbo_size } ; echo \" Applying DTBOs...\" ; adtimg addr $dtboaddr ; adtimg get dt --index = $dtbo_index dtbo0_addr ; fdt apply $dtbo0_addr ; setenv bootargs \" $bootargs androidboot.dtbo_idx= $dtbo_index \" ; setenv bootargs \" ${ bootargs } \" ; echo Running Android... ; bootm ${ loadaddr } ${ loadaddr } ${ fdt_addr_r } ; fi ; echo Failed to boot Android... ; bootdelay = 2 check_button = gpio input ${ gpio_recovery } ; test $? -eq 0 ; cpu = armv8 distro_bootcmd = setenv nvme_need_init ; for target in ${ boot_targets } ; do run bootcmd_ ${ target } ; done dtboaddr = 0x08200000 efi_dtb_prefixes = / /dtb/ /dtb/current/ ethaddr = c8:63:14:71:2d:35 fastboot_raw_partition_bootenv = 0x0 0xfff mmcpart 2 fastboot_raw_partition_bootloader = 0x1 0xfff mmcpart 1 fdt_addr_r = 0x01000000 fdtcontroladdr = f0efa100 fdtfile = amlogic/meson-g12b-a311d-khadas-vim3.dtb force_avb = 0 gpio_recovery = 88 kernel_addr_r = 0x01080000 load_efi_dtb = load ${ devtype } ${ devnum } : ${ distro_bootpart } ${ fdt_addr_r } ${ prefix }${ efi_fdtfile } load_logo = if test \" ${ boot_source } \" ! = \"usb\" && gpt verify mmc ${ mmcdev } ${ partitions } ; then ; mmc dev ${ mmcdev } ; part start mmc ${ mmcdev } logo boot_start ; part size mmc ${ mmcdev } logo boot_size ; if mmc read ${ loadaddr } ${ boot_start } ${ boot_size } ; then bmp display ${ loadaddr } m m ; fi ; fi ; loadaddr = 0x01080000 mmc_boot = if mmc dev ${ devnum } ; then devtype = mmc ; run scan_dev_for_boot_part ; fi mmcdev = 2 nvme_boot = run boot_pci_enum ; run nvme_init ; if nvme dev ${ devnum } ; then devtype = nvme ; run scan_dev_for_boot_part ; fi nvme_init = if ${ nvme_need_init } ; then setenv nvme_need_init false ; nvme scan ; fi partitions = uuid_disk = ${ uuid_gpt_disk } ; name = logo,start = 512K,size = 2M,uuid = 43a3305d-150f-4cc9-bd3b-38fca8693846 ; name = misc,size = 512K,uuid = ${ uuid_gpt_misc } ; name = dtbo,size = 8M,uuid = ${ uuid_gpt_dtbo } ; name = vbmeta,size = 512K,uuid = ${ uuid_gpt_vbmeta } ; name = boot,size = 32M,bootable,uuid = ${ uuid_gpt_boot } ; name = recovery,size = 32M,uuid = ${ uuid_gpt_recovery } ; name = cache,size = 256M,uuid = ${ uuid_gpt_cache } ; name = super,size = 1792M,uuid = ${ uuid_gpt_super } ; name = userdata,size = 12786M,uuid = ${ uuid_gpt_userdata } ; name = rootfs,size = -,uuid = ddb8c3f6-d94d-4394-b633-3134139cc2e0 ; pxefile_addr_r = 0x01080000 ramdisk_addr_r = 0x13000000 scan_dev_for_boot = echo Scanning ${ devtype } ${ devnum } : ${ distro_bootpart } ... ; for prefix in ${ boot_prefixes } ; do run scan_dev_for_extlinux ; run scan_dev_for_scripts ; done ; run scan_dev_for_efi ; scan_dev_for_boot_part = part list ${ devtype } ${ devnum } -bootable devplist ; env exists devplist || setenv devplist 1 ; for distro_bootpart in ${ devplist } ; do if fstype ${ devtype } ${ devnum } : ${ distro_bootpart } bootfstype ; then run scan_dev_for_boot ; fi ; done ; setenv devplist scan_dev_for_efi = setenv efi_fdtfile ${ fdtfile } ; for prefix in ${ efi_dtb_prefixes } ; do if test -e ${ devtype } ${ devnum } : ${ distro_bootpart } ${ prefix }${ efi_fdtfile } ; then run load_efi_dtb ; fi ; done ; run boot_efi_bootmgr ; if test -e ${ devtype } ${ devnum } : ${ distro_bootpart } efi/boot/bootaa64.efi ; then echo Found EFI removable media binary efi/boot/bootaa64.efi ; run boot_efi_binary ; echo EFI LOAD FAILED: continuing... ; fi ; setenv efi_fdtfile scan_dev_for_extlinux = if test -e ${ devtype } ${ devnum } : ${ distro_bootpart } ${ prefix }${ boot_syslinux_conf } ; then echo Found ${ prefix }${ boot_syslinux_conf } ; run boot_extlinux ; echo SCRIPT FAILED: continuing... ; fi scan_dev_for_scripts = for script in ${ boot_scripts } ; do if test -e ${ devtype } ${ devnum } : ${ distro_bootpart } ${ prefix }${ script } ; then echo Found U-Boot script ${ prefix }${ script } ; run boot_a_script ; echo SCRIPT FAILED: continuing... ; fi ; done scriptaddr = 0x08000000 serial# = C86314712D35 soc = meson stderr = vidconsole,serial stdin = usbkbd,serial stdout = vidconsole,serial usb_boot = usb start ; if usb dev ${ devnum } ; then devtype = usb ; run scan_dev_for_boot_part ; fi vendor = amlogic Environment size: 9785 /65532 bytes = > Estudaremos inicialmente essa sa\u00edda, come\u00e7ando pelo bootcmd (linha 18). Ele \u00e9 o ponta p\u00e9 inicial para o script. Podemos observar que ele executa outra fun\u00e7\u00e3o: bootcmd = run distro_bootcmd Ele executa a distro_bootcmd (linha 26). O distro_bootcmd Essa fun\u00e7\u00e3o \u00e9 um pouco mais elaborada, quebrei em v\u00e1rias linhas. Vamos analiz\u00e1-las distro_bootcmd = setenv nvme_need_init ; for target in ${ boot_targets } ; do run bootcmd_ ${ target } ; done A flag nvme_need_init n\u00e3o est\u00e1 setada, mas podemos encontrar alguns detalhes no arquivo: include/config_distro_bootcmd.h No diret\u00f3rio do c\u00f3digo fonte do u-boot, n\u00e3o vou focar nessa linha pois n\u00e3o \u00e9 de interesse utilizar o NVME (ainda ). Seguindo no c\u00f3digo, podemos obsevar que a vari\u00e1vel boot_targets (atribu\u00edda na linha 17) \u00e9 iterada com os seguintes valores: boot_targets=fastboot recovery system panic Cada valor \u00e9 concatenado com a string bootcmd_ , resultando em: bootcmd_fastboot bootcmd_recovery bootcmd_system bootcmd_panic As ramifica\u00e7\u00f5es do bootcmd_ O distro_bootcmd acaba executando outras 4 fun\u00e7\u00f5es, vamos entender o que elas fazem. O bootcmd_fastboot Atribu\u00edda na linha 19, ela possui a seguinte implementa\u00e7\u00e3o: bootcmd_fastboot = setenv run_fastboot 0 ; if test \" ${ boot_source } \" = \"usb\" ; then echo Fastboot forced by usb rom boot ; setenv run_fastboot 1 ; fi ; if test \" ${ run_fastboot } \" -eq 0 ; then if gpt verify mmc ${ mmcdev } ${ partitions } ; then ; else echo Broken MMC partition scheme ; setenv run_fastboot 1 ; fi ; fi ; if test \" ${ run_fastboot } \" -eq 0 ; then if bcb load 2 misc ; then if bcb test command = bootonce-bootloader ; then echo BCB: Bootloader boot... ; bcb clear command ; bcb store ; setenv run_fastboot 1 ; elif bcb test command = boot-fastboot ; then echo BCB: fastboot userspace boot... ; setenv force_recovery 1 ; fi ; else echo Warning: BCB is corrupted or does not exist ; fi ; fi ; if test \" ${ run_fastboot } \" -eq 1 ; then echo Running Fastboot... ; fastboot 0 ; fi A flag run_fastboot \u00e9 setada para 0. A vari\u00e1vel boot_source \u00e9 atribu\u00edda na linha 15: boot_source=sd Com isso, o primeiro if n\u00e3o \u00e9 acionado. No proximo if j\u00e1 sabemos que run_fastboot==0 , ao entrar no if \u00e9 checado a vari\u00e1vel mmcdev que \u00e9 atribu\u00edda na linha 42 e a vari\u00e1vel partitions , atribu\u00edda na linha 45: mmcdev = 2 partitions = uuid_disk = ${ uuid_gpt_disk } ; name = logo,start = 512K,size = 2M,uuid = 43a3305d-150f-4cc9-bd3b-38fca8693846 ; name = misc,size = 512K,uuid = ${ uuid_gpt_misc } ; name = dtbo,size = 8M,uuid = ${ uuid_gpt_dtbo } ; name = vbmeta,size = 512K,uuid = ${ uuid_gpt_vbmeta } ; name = boot,size = 32M,bootable,uuid = ${ uuid_gpt_boot } ; name = recovery,size = 32M,uuid = ${ uuid_gpt_recovery } ; name = cache,size = 256M,uuid = ${ uuid_gpt_cache } ; name = super,size = 1792M,uuid = ${ uuid_gpt_super } ; name = userdata,size = 12786M,uuid = ${ uuid_gpt_userdata } ; name = rootfs,size = -,uuid = ddb8c3f6-d94d-4394-b633-3134139cc2e0 ; Logo, na linha if gpt verify mmc ${mmcdev} ${partitions}; then; \u00e9 checado se as parti\u00e7\u00f5es existem, nesse caso no eMMC da placa ( mmcdev=2 ), caso contr\u00e1rio imprime a mensagem de erro Broken MMC partition scheme; e seta a flag run_fastboot para 1. Mais adiante, \u00e9 checado novamente a flag run_fastboot . Caso as parti\u00e7\u00f5es no eMMC estejam corretas, \u00e9 checado if bcb load 2 misc; then . Essa linha tenta carregar a parti\u00e7\u00e3o misc do eMMC (mais informa\u00e7\u00f5es nesse link ). Se tudo der certo, em seguida \u00e9 checado o conte\u00fado da v\u00e1ri\u00e1vel command que foi guardada dentro da parti\u00e7\u00e3o misc : if bcb test command = bootonce-bootloader; then elif bcb test command = boot-fastboot; then Caso algum problema ocorra ao carregar a parti\u00e7\u00e3o misc , a seguinte mensagem \u00e9 impressa na tela Warning: BCB is corrupted or does not exist; . O \u00faltimo if checa se a flag run_fastboot \u00e9 1, caso positivo \u00e9 impresso na tela a mensagem Running Fastboot... e entra no modo Fastboot com o comando fastboot 0 . O bootcmd_recovery Atribu\u00eddo na linha 21 e possui a seguinte implementa\u00e7\u00e3o: bootcmd_recovery = pinmux dev pinctrl@14 ; pinmux dev pinctrl@40 ; setenv run_recovery 0 ; if run check_button ; then echo Recovery button is pressed ; setenv run_recovery 1 ; fi ; if bcb load 2 misc ; then if bcb test command = boot-recovery ; then echo BCB: Recovery boot... ; setenv run_recovery 1 ; fi ; else echo Warning: BCB is corrupted or does not exist ; fi ; if test \" ${ skip_recovery } \" -eq 1 ; then echo Recovery skipped by environment ; setenv run_recovery 0 ; fi ; if test \" ${ force_recovery } \" -eq 1 ; then echo Recovery forced by environment ; setenv run_recovery 1 ; fi ; if test \" ${ run_recovery } \" -eq 1 ; then echo Running Recovery... ; mmc dev ${ mmcdev } ; setenv bootargs \" ${ bootargs } androidboot.serialno= ${ serial # } \" ; if test \" ${ force_avb } \" -eq 1 ; then if run avb_verify ; then echo AVB verification OK. ; setenv bootargs \" $bootargs $avb_bootargs \" ; else echo AVB verification failed. ; exit ; fi ; else setenv bootargs \" $bootargs androidboot.verifiedbootstate=orange\" ; echo Running without AVB... ; fi ; part start mmc ${ mmcdev } recovery ${ slot_suffix } boot_start ; part size mmc ${ mmcdev } recovery ${ slot_suffix } boot_size ; if mmc read ${ loadaddr } ${ boot_start } ${ boot_size } ; then echo Preparing FDT... ; if test $board_name = sei510 ; then echo \" Reading DTB for sei510...\" ; setenv dtb_index 0 ; elif test $board_name = sei610 ; then echo \" Reading DTB for sei610...\" ; setenv dtb_index 1 ; elif test $board_name = vim3l ; then echo \" Reading DTB for vim3l...\" ; setenv dtb_index 2 ; elif test $board_name = vim3 ; then echo \" Reading DTB for vim3...\" ; setenv dtb_index 3 ; else echo Error: Android boot is not supported for $board_name ; exit ; fi ; abootimg get dtb --index = $dtb_index dtb_start dtb_size ; cp.b $dtb_start $fdt_addr_r $dtb_size ; fdt addr $fdt_addr_r 0x80000 ; if test $board_name = sei510 ; then echo \" Reading DTBO for sei510...\" ; setenv dtbo_index 0 ; elif test $board_name = sei610 ; then echo \" Reading DTBO for sei610...\" ; setenv dtbo_index 1 ; elif test $board_name = vim3l ; then echo \" Reading DTBO for vim3l...\" ; setenv dtbo_index 2 ; elif test $board_name = vim3 ; then echo \" Reading DTBO for vim3...\" ; setenv dtbo_index 3 ; else echo Error: Android boot is not supported for $board_name ; exit ; fi ; part start mmc ${ mmcdev } dtbo ${ slot_suffix } p_dtbo_start ; part size mmc ${ mmcdev } dtbo ${ slot_suffix } p_dtbo_size ; mmc read ${ dtboaddr } ${ p_dtbo_start } ${ p_dtbo_size } ; echo \" Applying DTBOs...\" ; adtimg addr $dtboaddr ; adtimg get dt --index = $dtbo_index dtbo0_addr ; fdt apply $dtbo0_addr ; setenv bootargs \" $bootargs androidboot.dtbo_idx= $dtbo_index \" ; echo Running Android Recovery... ; bootm ${ loadaddr } ${ loadaddr } ${ fdt_addr_r } ; fi ; echo Failed to boot Android... ; reset ; fi As duas primeiras linhas: pinmux dev pinctrl@14; pinmux dev pinctrl@40; A pr\u00edncipio n\u00e3o funcionam, tentei ver o status desses pinos e retornaram pinctrl@14 not found e pinctrl@40 not found . Talvez esteja faltando alguma implementa\u00e7\u00e3o. Seguindo no c\u00f3digo, a flag run_recovery \u00e9 setada para 0 e ent\u00e3o a fun\u00e7\u00e3o check_button \u00e9 checada. Ela foi atribu\u00edda na linha 24: check_button = gpio input ${ gpio_recovery } ; test $? -eq 0 ; Na linha 36 a vari\u00e1vel gpio_recovery=88 \u00e9 atribu\u00edda. Por padr\u00e3o, esse GPIO \u00e9 setado para 1 gpio: pin 88 (gpio 88) value is 1 , logo o valor retornado \u00e9 falso. Dessa forma, a compara\u00e7\u00e3o if run check_button; then n\u00e3o \u00e9 acionada. Mais adiante, a parti\u00e7\u00e3o misc \u00e9 carregada novamente e \u00e9 checado se a vari\u00e1vel command est\u00e1 setada para boot-recovery . Em seguinda, a v\u00e1ri\u00e1vel skip_recovery n\u00e3o est\u00e1 setada, logo n\u00e3o entra no pr\u00f3ximo if . Se a vari\u00e1vel force_recovery foi setada na etapa do bootcmd_fastboot , ent\u00e3o a linha if test \"${force_recovery}\" -eq 1; then \u00e9 acionada \u00e9 a vari\u00e1vel a flag run_recovery \u00e9 setada para 1. Isso faz com que o pr\u00f3ximo if seja acionado ( if test \"${run_recovery}\" -eq 1; then ) e come\u00e7ar o processo de entrar no modo Recovery . Vimos na se\u00e7\u00e3o anterior que mmcdev=2 . Com isso, o comando mmc dev ${mmcdev}; ativa o eMMC. A pr\u00f3xima linha adiciona a vari\u00e1vel bootargs a propriedade androidboot.serialno=${serial#} . A vari\u00e1vel serial# \u00e9 atribu\u00edda na linha 54: serial# = C86314712D35 Seguindo, \u00e9 checado a v\u00e1ri\u00e1vel force_avb=0 , atribu\u00edda na linha 35. Como o Android Verified Boot (AVB) n\u00e3o est\u00e1 setado, \u00e9 adicionado mais uma propriedade ao bootargs : setenv bootargs \" $bootargs androidboot.verifiedbootstate=orange\" ; Mais a frente, temos a linha: part start mmc ${ mmcdev } recovery ${ slot_suffix } boot_start ; a vari\u00e1vel slot_suffix n\u00e3o est\u00e1 setada. Dessa forma, essa linha procura o inicio da parti\u00e7\u00e3o recovery dentro do eMMC e adiciona o valor na vari\u00e1vel boot_start . A linha: part size mmc ${ mmcdev } recovery ${ slot_suffix } boot_size ; \u00e9 semelhante, mas nesse caso armazena o tamanho da parti\u00e7\u00e3o recovery na vari\u00e1vel boot_size . Na linha seguinte: if mmc read ${ loadaddr } ${ boot_start } ${ boot_size } ; then a vari\u00e1vel loadaddr=0x01080000 \u00e9 atribu\u00edda na linha 40. A parti\u00e7\u00e3o recovery \u00e9 carregada e se tudo ocorrer corretamente, segue dentro do if . A vari\u00e1vel board_name=vim3 \u00e9 atribu\u00edda na linha 5, consequentemente, setando a flag setenv dtb_index 3; . A pr\u00f3xima linha: abootimg get dtb --index = $dtb_index dtb_start dtb_size ; Armazena o endere\u00e7o e o tamanho do Device Tree Blob (DTB) nas vari\u00e1veis dtb_start e dtb_size , respectivamente. Seguindo, temos: cp.b $dtb_start $fdt_addr_r $dtb_size ; a vari\u00e1vel fdt_addr_r=0x01000000 \u00e9 atribu\u00edda na linha 32. A linha acima copia o conte\u00fado do DTB para o endere\u00e7o da vari\u00e1vel fdt_addr_r . Ap\u00f3s isso, a localiza\u00e7\u00e3o do ftd \u00e9 setada para o endere\u00e7o 0x80000 , pelo comando: fdt addr $fdt_addr_r 0x80000 ; Agora \u00e9 necess\u00e1rio carregar o Device Tree Blob Overlay (DTBO). Para isso, \u00e9 checando novamente a var\u00edavel board_name , consequentemente, a flag setenv dtb_index 3 \u00e9 setada. As seguintes linhas tem fun\u00e7\u00e3o similar as anteriores: part start mmc ${ mmcdev } dtbo ${ slot_suffix } p_dtbo_start ; part size mmc ${ mmcdev } dtbo ${ slot_suffix } p_dtbo_size ; mmc read ${ dtboaddr } ${ p_dtbo_start } ${ p_dtbo_size } ; a vari\u00e1vel dtboaddr=0x08200000 \u00e9 atribu\u00edda na linha 27. As linhas: adtimg addr $dtboaddr ; adtimg get dt --index = $dtbo_index dtbo0_addr ; fdt apply $dtbo0_addr ; Seta a localiza\u00e7\u00e3o da imagem do DTBO para o endere\u00e7o da vari\u00e1vel dtboaddr , armazena o endere\u00e7o do DTBO na vari\u00e1vel dtbo0_addr . Por fim, aplica o DTBO no DTB. Na linha seguinte, \u00e9 adicionado a propriedade setenv bootargs \"$bootargs androidboot.dtbo_idx=$dtbo_index \" na vari\u00e1vel bootargs . Finalmente, na linha: bootm ${ loadaddr } ${ loadaddr } ${ fdt_addr_r } ; faz o boot da imagem de recovery . O bootcmd_system Atribu\u00eddo na linha 22, ele possui a seguinte implementa\u00e7\u00e3o: bootcmd_system = echo Loading Android boot partition... ; mmc dev ${ mmcdev } ; setenv bootargs ${ bootargs } androidboot.serialno = ${ serial # } ; if test \" ${ force_avb } \" -eq 1 ; then if run avb_verify ; then echo AVB verification OK. ; setenv bootargs \" $bootargs $avb_bootargs \" ; else echo AVB verification failed. ; exit ; fi ; else setenv bootargs \" $bootargs androidboot.verifiedbootstate=orange\" ; echo Running without AVB... ; fi ; part start mmc ${ mmcdev } boot ${ slot_suffix } boot_start ; part size mmc ${ mmcdev } boot ${ slot_suffix } boot_size ; if mmc read ${ loadaddr } ${ boot_start } ${ boot_size } ; then echo Preparing FDT... ; if test $board_name = sei510 ; then echo \" Reading DTB for sei510...\" ; setenv dtb_index 0 ; elif test $board_name = sei610 ; then echo \" Reading DTB for sei610...\" ; setenv dtb_index 1 ; elif test $board_name = vim3l ; then echo \" Reading DTB for vim3l...\" ; setenv dtb_index 2 ; elif test $board_name = vim3 ; then echo \" Reading DTB for vim3...\" ; setenv dtb_index 3 ; else echo Error: Android boot is not supported for $board_name ; exit ; fi ; abootimg get dtb --index = $dtb_index dtb_start dtb_size ; cp.b $dtb_start $fdt_addr_r $dtb_size ; fdt addr $fdt_addr_r 0x80000 ; if test $board_name = sei510 ; then echo \" Reading DTBO for sei510...\" ; setenv dtbo_index 0 ; elif test $board_name = sei610 ; then echo \" Reading DTBO for sei610...\" ; setenv dtbo_index 1 ; elif test $board_name = vim3l ; then echo \" Reading DTBO for vim3l...\" ; setenv dtbo_index 2 ; elif test $board_name = vim3 ; then echo \" Reading DTBO for vim3...\" ; setenv dtbo_index 3 ; else echo Error: Android boot is not supported for $board_name ; exit ; fi ; part start mmc ${ mmcdev } dtbo ${ slot_suffix } p_dtbo_start ; part size mmc ${ mmcdev } dtbo ${ slot_suffix } p_dtbo_size ; mmc read ${ dtboaddr } ${ p_dtbo_start } ${ p_dtbo_size } ; echo \" Applying DTBOs...\" ; adtimg addr $dtboaddr ; adtimg get dt --index = $dtbo_index dtbo0_addr ; fdt apply $dtbo0_addr ; setenv bootargs \" $bootargs androidboot.dtbo_idx= $dtbo_index \" ; setenv bootargs \" ${ bootargs } \" ; echo Running Android... ; bootm ${ loadaddr } ${ loadaddr } ${ fdt_addr_r } ; fi ; echo Failed to boot Android... ; Todo o processo \u00e9 o mesmo do modo recovery a diferen\u00e7a fica nas seguintes linhas: part start mmc ${ mmcdev } boot ${ slot_suffix } boot_start ; part size mmc ${ mmcdev } boot ${ slot_suffix } boot_size ; Observe que agora o script busca pela parti\u00e7\u00e3o boot . O resto segue inalterado. O bootcmd_panic Atribu\u00eddo na linha 20, ele possui a seguinte implementa\u00e7\u00e3o: bootcmd_panic = fastboot 0 ; reset Como \u00faltimo recurso, caso n\u00e3o tenha sido poss\u00edvel fazer o boot do Android. O script entra no modo fastboot e ao sair ele reinicia a VIM3. Conclus\u00e3o Sem d\u00favida entender esse processo n\u00e3o \u00e9 algo trivial, n\u00e3o existe uma padroniza\u00e7\u00e3o e tudo fica na m\u00e3o do desenvolvedor na hora de criar o script respons\u00e1vel por carregar o kernel do Android. Com certeza, esse passo foi fundamental para um melhor entendimento de como o Android funciona.","title":"Decifrando o BOOTCMD"},{"location":"Boards/VIM3/Android/Bootloader/Carregando/#decifrando-o-bootcmd","text":"Image by Gerd Altmann from Pixabay","title":"Decifrando o BOOTCMD"},{"location":"Boards/VIM3/Android/Bootloader/Carregando/#introducao","text":"Na minha saga para desvendar o mundo dos sistemas embarcados, nesse post eu pretendo entender explicar como o u-boot mainline carrega o kernel Android na VIM3 .","title":"Introdu\u00e7\u00e3o"},{"location":"Boards/VIM3/Android/Bootloader/Carregando/#o-bootcmd","text":"Depois que que o u-boot \u00e9 carregado, ele executa comandos para encontrar o kernel. Para isso, \u00e9 gerado um script para checar as poss\u00edveis formas de carrega-lo. O primeiro passo foi dar o comando printenv no console do u-boot, resultando nas seguintes informa\u00e7\u00f5es: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 arch = arm avb_verify = avb init ${ mmcdev } ; avb verify $slot_suffix ; baudrate = 115200 board = vim3 board_name = vim3 boot_a_script = load ${ devtype } ${ devnum } : ${ distro_bootpart } ${ scriptaddr } ${ prefix }${ script } ; source ${ scriptaddr } boot_efi_binary = load ${ devtype } ${ devnum } : ${ distro_bootpart } ${ kernel_addr_r } efi/boot/bootaa64.efi ; if fdt addr -q ${ fdt_addr_r } ; then bootefi ${ kernel_addr_r } ${ fdt_addr_r } ; else bootefi ${ kernel_addr_r } ${ fdtcontroladdr } ; fi boot_efi_bootmgr = if fdt addr -q ${ fdt_addr_r } ; then bootefi bootmgr ${ fdt_addr_r } ; else bootefi bootmgr ; fi boot_extlinux = sysboot ${ devtype } ${ devnum } : ${ distro_bootpart } any ${ scriptaddr } ${ prefix }${ boot_syslinux_conf } boot_net_usb_start = usb start boot_pci_enum = pci enum boot_prefixes = / /boot/ boot_script_dhcp = boot.scr.uimg boot_scripts = boot.scr.uimg boot.scr boot_source = sd boot_syslinux_conf = extlinux/extlinux.conf boot_targets = fastboot recovery system panic bootcmd = run distro_bootcmd bootcmd_fastboot = setenv run_fastboot 0 ; if test \" ${ boot_source } \" = \"usb\" ; then echo Fastboot forced by usb rom boot ; setenv run_fastboot 1 ; fi ; if test \" ${ run_fastboot } \" -eq 0 ; then if gpt verify mmc ${ mmcdev } ${ partitions } ; then ; else echo Broken MMC partition scheme ; setenv run_fastboot 1 ; fi ; fi ; if test \" ${ run_fastboot } \" -eq 0 ; then if bcb load 2 misc ; then if bcb test command = bootonce-bootloader ; then echo BCB: Bootloader boot... ; bcb clear command ; bcb store ; setenv run_fastboot 1 ; elif bcb test command = boot-fastboot ; then echo BCB: fastboot userspace boot... ; setenv force_recovery 1 ; fi ; else echo Warning: BCB is corrupted or does not exist ; fi ; fi ; if test \" ${ run_fastboot } \" -eq 1 ; then echo Running Fastboot... ; fastboot 0 ; fi bootcmd_panic = fastboot 0 ; reset bootcmd_recovery = pinmux dev pinctrl@14 ; pinmux dev pinctrl@40 ; setenv run_recovery 0 ; if run check_button ; then echo Recovery button is pressed ; setenv run_recovery 1 ; fi ; if bcb load 2 misc ; then if bcb test command = boot-recovery ; then echo BCB: Recovery boot... ; setenv run_recovery 1 ; fi ; else echo Warning: BCB is corrupted or does not exist ; fi ; if test \" ${ skip_recovery } \" -eq 1 ; then echo Recovery skipped by environment ; setenv run_recovery 0 ; fi ; if test \" ${ force_recovery } \" -eq 1 ; then echo Recovery forced by environment ; setenv run_recovery 1 ; fi ; if test \" ${ run_recovery } \" -eq 1 ; then echo Running Recovery... ; mmc dev ${ mmcdev } ; setenv bootargs \" ${ bootargs } androidboot.serialno= ${ serial # } \" ; if test \" ${ force_avb } \" -eq 1 ; then if run avb_verify ; then echo AVB verification OK. ; setenv bootargs \" $bootargs $avb_bootargs \" ; else echo AVB verification failed. ; exit ; fi ; else setenv bootargs \" $bootargs androidboot.verifiedbootstate=orange\" ; echo Running without AVB... ; fi ; part start mmc ${ mmcdev } recovery ${ slot_suffix } boot_start ; part size mmc ${ mmcdev } recovery ${ slot_suffix } boot_size ; if mmc read ${ loadaddr } ${ boot_start } ${ boot_size } ; then echo Preparing FDT... ; if test $board_name = sei510 ; then echo \" Reading DTB for sei510...\" ; setenv dtb_index 0 ; elif test $board_name = sei610 ; then echo \" Reading DTB for sei610...\" ; setenv dtb_index 1 ; elif test $board_name = vim3l ; then echo \" Reading DTB for vim3l...\" ; setenv dtb_index 2 ; elif test $board_name = vim3 ; then echo \" Reading DTB for vim3...\" ; setenv dtb_index 3 ; else echo Error: Android boot is not supported for $board_name ; exit ; fi ; abootimg get dtb --index = $dtb_index dtb_start dtb_size ; cp.b $dtb_start $fdt_addr_r $dtb_size ; fdt addr $fdt_addr_r 0x80000 ; if test $board_name = sei510 ; then echo \" Reading DTBO for sei510...\" ; setenv dtbo_index 0 ; elif test $board_name = sei610 ; then echo \" Reading DTBO for sei610...\" ; setenv dtbo_index 1 ; elif test $board_name = vim3l ; then echo \" Reading DTBO for vim3l...\" ; setenv dtbo_index 2 ; elif test $board_name = vim3 ; then echo \" Reading DTBO for vim3...\" ; setenv dtbo_index 3 ; else echo Error: Android boot is not supported for $board_name ; exit ; fi ; part start mmc ${ mmcdev } dtbo ${ slot_suffix } p_dtbo_start ; part size mmc ${ mmcdev } dtbo ${ slot_suffix } p_dtbo_size ; mmc read ${ dtboaddr } ${ p_dtbo_start } ${ p_dtbo_size } ; echo \" Applying DTBOs...\" ; adtimg addr $dtboaddr ; adtimg get dt --index = $dtbo_index dtbo0_addr ; fdt apply $dtbo0_addr ; setenv bootargs \" $bootargs androidboot.dtbo_idx= $dtbo_index \" ; echo Running Android Recovery... ; bootm ${ loadaddr } ${ loadaddr } ${ fdt_addr_r } ; fi ; echo Failed to boot Android... ; reset ; fi bootcmd_system = echo Loading Android boot partition... ; mmc dev ${ mmcdev } ; setenv bootargs ${ bootargs } androidboot.serialno = ${ serial # } ; if test \" ${ force_avb } \" -eq 1 ; then if run avb_verify ; then echo AVB verification OK. ; setenv bootargs \" $bootargs $avb_bootargs \" ; else echo AVB verification failed. ; exit ; fi ; else setenv bootargs \" $bootargs androidboot.verifiedbootstate=orange\" ; echo Running without AVB... ; fi ; part start mmc ${ mmcdev } boot ${ slot_suffix } boot_start ; part size mmc ${ mmcdev } boot ${ slot_suffix } boot_size ; if mmc read ${ loadaddr } ${ boot_start } ${ boot_size } ; then echo Preparing FDT... ; if test $board_name = sei510 ; then echo \" Reading DTB for sei510...\" ; setenv dtb_index 0 ; elif test $board_name = sei610 ; then echo \" Reading DTB for sei610...\" ; setenv dtb_index 1 ; elif test $board_name = vim3l ; then echo \" Reading DTB for vim3l...\" ; setenv dtb_index 2 ; elif test $board_name = vim3 ; then echo \" Reading DTB for vim3...\" ; setenv dtb_index 3 ; else echo Error: Android boot is not supported for $board_name ; exit ; fi ; abootimg get dtb --index = $dtb_index dtb_start dtb_size ; cp.b $dtb_start $fdt_addr_r $dtb_size ; fdt addr $fdt_addr_r 0x80000 ; if test $board_name = sei510 ; then echo \" Reading DTBO for sei510...\" ; setenv dtbo_index 0 ; elif test $board_name = sei610 ; then echo \" Reading DTBO for sei610...\" ; setenv dtbo_index 1 ; elif test $board_name = vim3l ; then echo \" Reading DTBO for vim3l...\" ; setenv dtbo_index 2 ; elif test $board_name = vim3 ; then echo \" Reading DTBO for vim3...\" ; setenv dtbo_index 3 ; else echo Error: Android boot is not supported for $board_name ; exit ; fi ; part start mmc ${ mmcdev } dtbo ${ slot_suffix } p_dtbo_start ; part size mmc ${ mmcdev } dtbo ${ slot_suffix } p_dtbo_size ; mmc read ${ dtboaddr } ${ p_dtbo_start } ${ p_dtbo_size } ; echo \" Applying DTBOs...\" ; adtimg addr $dtboaddr ; adtimg get dt --index = $dtbo_index dtbo0_addr ; fdt apply $dtbo0_addr ; setenv bootargs \" $bootargs androidboot.dtbo_idx= $dtbo_index \" ; setenv bootargs \" ${ bootargs } \" ; echo Running Android... ; bootm ${ loadaddr } ${ loadaddr } ${ fdt_addr_r } ; fi ; echo Failed to boot Android... ; bootdelay = 2 check_button = gpio input ${ gpio_recovery } ; test $? -eq 0 ; cpu = armv8 distro_bootcmd = setenv nvme_need_init ; for target in ${ boot_targets } ; do run bootcmd_ ${ target } ; done dtboaddr = 0x08200000 efi_dtb_prefixes = / /dtb/ /dtb/current/ ethaddr = c8:63:14:71:2d:35 fastboot_raw_partition_bootenv = 0x0 0xfff mmcpart 2 fastboot_raw_partition_bootloader = 0x1 0xfff mmcpart 1 fdt_addr_r = 0x01000000 fdtcontroladdr = f0efa100 fdtfile = amlogic/meson-g12b-a311d-khadas-vim3.dtb force_avb = 0 gpio_recovery = 88 kernel_addr_r = 0x01080000 load_efi_dtb = load ${ devtype } ${ devnum } : ${ distro_bootpart } ${ fdt_addr_r } ${ prefix }${ efi_fdtfile } load_logo = if test \" ${ boot_source } \" ! = \"usb\" && gpt verify mmc ${ mmcdev } ${ partitions } ; then ; mmc dev ${ mmcdev } ; part start mmc ${ mmcdev } logo boot_start ; part size mmc ${ mmcdev } logo boot_size ; if mmc read ${ loadaddr } ${ boot_start } ${ boot_size } ; then bmp display ${ loadaddr } m m ; fi ; fi ; loadaddr = 0x01080000 mmc_boot = if mmc dev ${ devnum } ; then devtype = mmc ; run scan_dev_for_boot_part ; fi mmcdev = 2 nvme_boot = run boot_pci_enum ; run nvme_init ; if nvme dev ${ devnum } ; then devtype = nvme ; run scan_dev_for_boot_part ; fi nvme_init = if ${ nvme_need_init } ; then setenv nvme_need_init false ; nvme scan ; fi partitions = uuid_disk = ${ uuid_gpt_disk } ; name = logo,start = 512K,size = 2M,uuid = 43a3305d-150f-4cc9-bd3b-38fca8693846 ; name = misc,size = 512K,uuid = ${ uuid_gpt_misc } ; name = dtbo,size = 8M,uuid = ${ uuid_gpt_dtbo } ; name = vbmeta,size = 512K,uuid = ${ uuid_gpt_vbmeta } ; name = boot,size = 32M,bootable,uuid = ${ uuid_gpt_boot } ; name = recovery,size = 32M,uuid = ${ uuid_gpt_recovery } ; name = cache,size = 256M,uuid = ${ uuid_gpt_cache } ; name = super,size = 1792M,uuid = ${ uuid_gpt_super } ; name = userdata,size = 12786M,uuid = ${ uuid_gpt_userdata } ; name = rootfs,size = -,uuid = ddb8c3f6-d94d-4394-b633-3134139cc2e0 ; pxefile_addr_r = 0x01080000 ramdisk_addr_r = 0x13000000 scan_dev_for_boot = echo Scanning ${ devtype } ${ devnum } : ${ distro_bootpart } ... ; for prefix in ${ boot_prefixes } ; do run scan_dev_for_extlinux ; run scan_dev_for_scripts ; done ; run scan_dev_for_efi ; scan_dev_for_boot_part = part list ${ devtype } ${ devnum } -bootable devplist ; env exists devplist || setenv devplist 1 ; for distro_bootpart in ${ devplist } ; do if fstype ${ devtype } ${ devnum } : ${ distro_bootpart } bootfstype ; then run scan_dev_for_boot ; fi ; done ; setenv devplist scan_dev_for_efi = setenv efi_fdtfile ${ fdtfile } ; for prefix in ${ efi_dtb_prefixes } ; do if test -e ${ devtype } ${ devnum } : ${ distro_bootpart } ${ prefix }${ efi_fdtfile } ; then run load_efi_dtb ; fi ; done ; run boot_efi_bootmgr ; if test -e ${ devtype } ${ devnum } : ${ distro_bootpart } efi/boot/bootaa64.efi ; then echo Found EFI removable media binary efi/boot/bootaa64.efi ; run boot_efi_binary ; echo EFI LOAD FAILED: continuing... ; fi ; setenv efi_fdtfile scan_dev_for_extlinux = if test -e ${ devtype } ${ devnum } : ${ distro_bootpart } ${ prefix }${ boot_syslinux_conf } ; then echo Found ${ prefix }${ boot_syslinux_conf } ; run boot_extlinux ; echo SCRIPT FAILED: continuing... ; fi scan_dev_for_scripts = for script in ${ boot_scripts } ; do if test -e ${ devtype } ${ devnum } : ${ distro_bootpart } ${ prefix }${ script } ; then echo Found U-Boot script ${ prefix }${ script } ; run boot_a_script ; echo SCRIPT FAILED: continuing... ; fi ; done scriptaddr = 0x08000000 serial# = C86314712D35 soc = meson stderr = vidconsole,serial stdin = usbkbd,serial stdout = vidconsole,serial usb_boot = usb start ; if usb dev ${ devnum } ; then devtype = usb ; run scan_dev_for_boot_part ; fi vendor = amlogic Environment size: 9785 /65532 bytes = > Estudaremos inicialmente essa sa\u00edda, come\u00e7ando pelo bootcmd (linha 18). Ele \u00e9 o ponta p\u00e9 inicial para o script. Podemos observar que ele executa outra fun\u00e7\u00e3o: bootcmd = run distro_bootcmd Ele executa a distro_bootcmd (linha 26).","title":"O bootcmd"},{"location":"Boards/VIM3/Android/Bootloader/Carregando/#o-distro_bootcmd","text":"Essa fun\u00e7\u00e3o \u00e9 um pouco mais elaborada, quebrei em v\u00e1rias linhas. Vamos analiz\u00e1-las distro_bootcmd = setenv nvme_need_init ; for target in ${ boot_targets } ; do run bootcmd_ ${ target } ; done A flag nvme_need_init n\u00e3o est\u00e1 setada, mas podemos encontrar alguns detalhes no arquivo: include/config_distro_bootcmd.h No diret\u00f3rio do c\u00f3digo fonte do u-boot, n\u00e3o vou focar nessa linha pois n\u00e3o \u00e9 de interesse utilizar o NVME (ainda ). Seguindo no c\u00f3digo, podemos obsevar que a vari\u00e1vel boot_targets (atribu\u00edda na linha 17) \u00e9 iterada com os seguintes valores: boot_targets=fastboot recovery system panic Cada valor \u00e9 concatenado com a string bootcmd_ , resultando em: bootcmd_fastboot bootcmd_recovery bootcmd_system bootcmd_panic","title":"O distro_bootcmd"},{"location":"Boards/VIM3/Android/Bootloader/Carregando/#as-ramificacoes-do-bootcmd_","text":"O distro_bootcmd acaba executando outras 4 fun\u00e7\u00f5es, vamos entender o que elas fazem.","title":"As ramifica\u00e7\u00f5es do bootcmd_"},{"location":"Boards/VIM3/Android/Bootloader/Carregando/#o-bootcmd_fastboot","text":"Atribu\u00edda na linha 19, ela possui a seguinte implementa\u00e7\u00e3o: bootcmd_fastboot = setenv run_fastboot 0 ; if test \" ${ boot_source } \" = \"usb\" ; then echo Fastboot forced by usb rom boot ; setenv run_fastboot 1 ; fi ; if test \" ${ run_fastboot } \" -eq 0 ; then if gpt verify mmc ${ mmcdev } ${ partitions } ; then ; else echo Broken MMC partition scheme ; setenv run_fastboot 1 ; fi ; fi ; if test \" ${ run_fastboot } \" -eq 0 ; then if bcb load 2 misc ; then if bcb test command = bootonce-bootloader ; then echo BCB: Bootloader boot... ; bcb clear command ; bcb store ; setenv run_fastboot 1 ; elif bcb test command = boot-fastboot ; then echo BCB: fastboot userspace boot... ; setenv force_recovery 1 ; fi ; else echo Warning: BCB is corrupted or does not exist ; fi ; fi ; if test \" ${ run_fastboot } \" -eq 1 ; then echo Running Fastboot... ; fastboot 0 ; fi A flag run_fastboot \u00e9 setada para 0. A vari\u00e1vel boot_source \u00e9 atribu\u00edda na linha 15: boot_source=sd Com isso, o primeiro if n\u00e3o \u00e9 acionado. No proximo if j\u00e1 sabemos que run_fastboot==0 , ao entrar no if \u00e9 checado a vari\u00e1vel mmcdev que \u00e9 atribu\u00edda na linha 42 e a vari\u00e1vel partitions , atribu\u00edda na linha 45: mmcdev = 2 partitions = uuid_disk = ${ uuid_gpt_disk } ; name = logo,start = 512K,size = 2M,uuid = 43a3305d-150f-4cc9-bd3b-38fca8693846 ; name = misc,size = 512K,uuid = ${ uuid_gpt_misc } ; name = dtbo,size = 8M,uuid = ${ uuid_gpt_dtbo } ; name = vbmeta,size = 512K,uuid = ${ uuid_gpt_vbmeta } ; name = boot,size = 32M,bootable,uuid = ${ uuid_gpt_boot } ; name = recovery,size = 32M,uuid = ${ uuid_gpt_recovery } ; name = cache,size = 256M,uuid = ${ uuid_gpt_cache } ; name = super,size = 1792M,uuid = ${ uuid_gpt_super } ; name = userdata,size = 12786M,uuid = ${ uuid_gpt_userdata } ; name = rootfs,size = -,uuid = ddb8c3f6-d94d-4394-b633-3134139cc2e0 ; Logo, na linha if gpt verify mmc ${mmcdev} ${partitions}; then; \u00e9 checado se as parti\u00e7\u00f5es existem, nesse caso no eMMC da placa ( mmcdev=2 ), caso contr\u00e1rio imprime a mensagem de erro Broken MMC partition scheme; e seta a flag run_fastboot para 1. Mais adiante, \u00e9 checado novamente a flag run_fastboot . Caso as parti\u00e7\u00f5es no eMMC estejam corretas, \u00e9 checado if bcb load 2 misc; then . Essa linha tenta carregar a parti\u00e7\u00e3o misc do eMMC (mais informa\u00e7\u00f5es nesse link ). Se tudo der certo, em seguida \u00e9 checado o conte\u00fado da v\u00e1ri\u00e1vel command que foi guardada dentro da parti\u00e7\u00e3o misc : if bcb test command = bootonce-bootloader; then elif bcb test command = boot-fastboot; then Caso algum problema ocorra ao carregar a parti\u00e7\u00e3o misc , a seguinte mensagem \u00e9 impressa na tela Warning: BCB is corrupted or does not exist; . O \u00faltimo if checa se a flag run_fastboot \u00e9 1, caso positivo \u00e9 impresso na tela a mensagem Running Fastboot... e entra no modo Fastboot com o comando fastboot 0 .","title":"O bootcmd_fastboot"},{"location":"Boards/VIM3/Android/Bootloader/Carregando/#o-bootcmd_recovery","text":"Atribu\u00eddo na linha 21 e possui a seguinte implementa\u00e7\u00e3o: bootcmd_recovery = pinmux dev pinctrl@14 ; pinmux dev pinctrl@40 ; setenv run_recovery 0 ; if run check_button ; then echo Recovery button is pressed ; setenv run_recovery 1 ; fi ; if bcb load 2 misc ; then if bcb test command = boot-recovery ; then echo BCB: Recovery boot... ; setenv run_recovery 1 ; fi ; else echo Warning: BCB is corrupted or does not exist ; fi ; if test \" ${ skip_recovery } \" -eq 1 ; then echo Recovery skipped by environment ; setenv run_recovery 0 ; fi ; if test \" ${ force_recovery } \" -eq 1 ; then echo Recovery forced by environment ; setenv run_recovery 1 ; fi ; if test \" ${ run_recovery } \" -eq 1 ; then echo Running Recovery... ; mmc dev ${ mmcdev } ; setenv bootargs \" ${ bootargs } androidboot.serialno= ${ serial # } \" ; if test \" ${ force_avb } \" -eq 1 ; then if run avb_verify ; then echo AVB verification OK. ; setenv bootargs \" $bootargs $avb_bootargs \" ; else echo AVB verification failed. ; exit ; fi ; else setenv bootargs \" $bootargs androidboot.verifiedbootstate=orange\" ; echo Running without AVB... ; fi ; part start mmc ${ mmcdev } recovery ${ slot_suffix } boot_start ; part size mmc ${ mmcdev } recovery ${ slot_suffix } boot_size ; if mmc read ${ loadaddr } ${ boot_start } ${ boot_size } ; then echo Preparing FDT... ; if test $board_name = sei510 ; then echo \" Reading DTB for sei510...\" ; setenv dtb_index 0 ; elif test $board_name = sei610 ; then echo \" Reading DTB for sei610...\" ; setenv dtb_index 1 ; elif test $board_name = vim3l ; then echo \" Reading DTB for vim3l...\" ; setenv dtb_index 2 ; elif test $board_name = vim3 ; then echo \" Reading DTB for vim3...\" ; setenv dtb_index 3 ; else echo Error: Android boot is not supported for $board_name ; exit ; fi ; abootimg get dtb --index = $dtb_index dtb_start dtb_size ; cp.b $dtb_start $fdt_addr_r $dtb_size ; fdt addr $fdt_addr_r 0x80000 ; if test $board_name = sei510 ; then echo \" Reading DTBO for sei510...\" ; setenv dtbo_index 0 ; elif test $board_name = sei610 ; then echo \" Reading DTBO for sei610...\" ; setenv dtbo_index 1 ; elif test $board_name = vim3l ; then echo \" Reading DTBO for vim3l...\" ; setenv dtbo_index 2 ; elif test $board_name = vim3 ; then echo \" Reading DTBO for vim3...\" ; setenv dtbo_index 3 ; else echo Error: Android boot is not supported for $board_name ; exit ; fi ; part start mmc ${ mmcdev } dtbo ${ slot_suffix } p_dtbo_start ; part size mmc ${ mmcdev } dtbo ${ slot_suffix } p_dtbo_size ; mmc read ${ dtboaddr } ${ p_dtbo_start } ${ p_dtbo_size } ; echo \" Applying DTBOs...\" ; adtimg addr $dtboaddr ; adtimg get dt --index = $dtbo_index dtbo0_addr ; fdt apply $dtbo0_addr ; setenv bootargs \" $bootargs androidboot.dtbo_idx= $dtbo_index \" ; echo Running Android Recovery... ; bootm ${ loadaddr } ${ loadaddr } ${ fdt_addr_r } ; fi ; echo Failed to boot Android... ; reset ; fi As duas primeiras linhas: pinmux dev pinctrl@14; pinmux dev pinctrl@40; A pr\u00edncipio n\u00e3o funcionam, tentei ver o status desses pinos e retornaram pinctrl@14 not found e pinctrl@40 not found . Talvez esteja faltando alguma implementa\u00e7\u00e3o. Seguindo no c\u00f3digo, a flag run_recovery \u00e9 setada para 0 e ent\u00e3o a fun\u00e7\u00e3o check_button \u00e9 checada. Ela foi atribu\u00edda na linha 24: check_button = gpio input ${ gpio_recovery } ; test $? -eq 0 ; Na linha 36 a vari\u00e1vel gpio_recovery=88 \u00e9 atribu\u00edda. Por padr\u00e3o, esse GPIO \u00e9 setado para 1 gpio: pin 88 (gpio 88) value is 1 , logo o valor retornado \u00e9 falso. Dessa forma, a compara\u00e7\u00e3o if run check_button; then n\u00e3o \u00e9 acionada. Mais adiante, a parti\u00e7\u00e3o misc \u00e9 carregada novamente e \u00e9 checado se a vari\u00e1vel command est\u00e1 setada para boot-recovery . Em seguinda, a v\u00e1ri\u00e1vel skip_recovery n\u00e3o est\u00e1 setada, logo n\u00e3o entra no pr\u00f3ximo if . Se a vari\u00e1vel force_recovery foi setada na etapa do bootcmd_fastboot , ent\u00e3o a linha if test \"${force_recovery}\" -eq 1; then \u00e9 acionada \u00e9 a vari\u00e1vel a flag run_recovery \u00e9 setada para 1. Isso faz com que o pr\u00f3ximo if seja acionado ( if test \"${run_recovery}\" -eq 1; then ) e come\u00e7ar o processo de entrar no modo Recovery . Vimos na se\u00e7\u00e3o anterior que mmcdev=2 . Com isso, o comando mmc dev ${mmcdev}; ativa o eMMC. A pr\u00f3xima linha adiciona a vari\u00e1vel bootargs a propriedade androidboot.serialno=${serial#} . A vari\u00e1vel serial# \u00e9 atribu\u00edda na linha 54: serial# = C86314712D35 Seguindo, \u00e9 checado a v\u00e1ri\u00e1vel force_avb=0 , atribu\u00edda na linha 35. Como o Android Verified Boot (AVB) n\u00e3o est\u00e1 setado, \u00e9 adicionado mais uma propriedade ao bootargs : setenv bootargs \" $bootargs androidboot.verifiedbootstate=orange\" ; Mais a frente, temos a linha: part start mmc ${ mmcdev } recovery ${ slot_suffix } boot_start ; a vari\u00e1vel slot_suffix n\u00e3o est\u00e1 setada. Dessa forma, essa linha procura o inicio da parti\u00e7\u00e3o recovery dentro do eMMC e adiciona o valor na vari\u00e1vel boot_start . A linha: part size mmc ${ mmcdev } recovery ${ slot_suffix } boot_size ; \u00e9 semelhante, mas nesse caso armazena o tamanho da parti\u00e7\u00e3o recovery na vari\u00e1vel boot_size . Na linha seguinte: if mmc read ${ loadaddr } ${ boot_start } ${ boot_size } ; then a vari\u00e1vel loadaddr=0x01080000 \u00e9 atribu\u00edda na linha 40. A parti\u00e7\u00e3o recovery \u00e9 carregada e se tudo ocorrer corretamente, segue dentro do if . A vari\u00e1vel board_name=vim3 \u00e9 atribu\u00edda na linha 5, consequentemente, setando a flag setenv dtb_index 3; . A pr\u00f3xima linha: abootimg get dtb --index = $dtb_index dtb_start dtb_size ; Armazena o endere\u00e7o e o tamanho do Device Tree Blob (DTB) nas vari\u00e1veis dtb_start e dtb_size , respectivamente. Seguindo, temos: cp.b $dtb_start $fdt_addr_r $dtb_size ; a vari\u00e1vel fdt_addr_r=0x01000000 \u00e9 atribu\u00edda na linha 32. A linha acima copia o conte\u00fado do DTB para o endere\u00e7o da vari\u00e1vel fdt_addr_r . Ap\u00f3s isso, a localiza\u00e7\u00e3o do ftd \u00e9 setada para o endere\u00e7o 0x80000 , pelo comando: fdt addr $fdt_addr_r 0x80000 ; Agora \u00e9 necess\u00e1rio carregar o Device Tree Blob Overlay (DTBO). Para isso, \u00e9 checando novamente a var\u00edavel board_name , consequentemente, a flag setenv dtb_index 3 \u00e9 setada. As seguintes linhas tem fun\u00e7\u00e3o similar as anteriores: part start mmc ${ mmcdev } dtbo ${ slot_suffix } p_dtbo_start ; part size mmc ${ mmcdev } dtbo ${ slot_suffix } p_dtbo_size ; mmc read ${ dtboaddr } ${ p_dtbo_start } ${ p_dtbo_size } ; a vari\u00e1vel dtboaddr=0x08200000 \u00e9 atribu\u00edda na linha 27. As linhas: adtimg addr $dtboaddr ; adtimg get dt --index = $dtbo_index dtbo0_addr ; fdt apply $dtbo0_addr ; Seta a localiza\u00e7\u00e3o da imagem do DTBO para o endere\u00e7o da vari\u00e1vel dtboaddr , armazena o endere\u00e7o do DTBO na vari\u00e1vel dtbo0_addr . Por fim, aplica o DTBO no DTB. Na linha seguinte, \u00e9 adicionado a propriedade setenv bootargs \"$bootargs androidboot.dtbo_idx=$dtbo_index \" na vari\u00e1vel bootargs . Finalmente, na linha: bootm ${ loadaddr } ${ loadaddr } ${ fdt_addr_r } ; faz o boot da imagem de recovery .","title":"O bootcmd_recovery"},{"location":"Boards/VIM3/Android/Bootloader/Carregando/#o-bootcmd_system","text":"Atribu\u00eddo na linha 22, ele possui a seguinte implementa\u00e7\u00e3o: bootcmd_system = echo Loading Android boot partition... ; mmc dev ${ mmcdev } ; setenv bootargs ${ bootargs } androidboot.serialno = ${ serial # } ; if test \" ${ force_avb } \" -eq 1 ; then if run avb_verify ; then echo AVB verification OK. ; setenv bootargs \" $bootargs $avb_bootargs \" ; else echo AVB verification failed. ; exit ; fi ; else setenv bootargs \" $bootargs androidboot.verifiedbootstate=orange\" ; echo Running without AVB... ; fi ; part start mmc ${ mmcdev } boot ${ slot_suffix } boot_start ; part size mmc ${ mmcdev } boot ${ slot_suffix } boot_size ; if mmc read ${ loadaddr } ${ boot_start } ${ boot_size } ; then echo Preparing FDT... ; if test $board_name = sei510 ; then echo \" Reading DTB for sei510...\" ; setenv dtb_index 0 ; elif test $board_name = sei610 ; then echo \" Reading DTB for sei610...\" ; setenv dtb_index 1 ; elif test $board_name = vim3l ; then echo \" Reading DTB for vim3l...\" ; setenv dtb_index 2 ; elif test $board_name = vim3 ; then echo \" Reading DTB for vim3...\" ; setenv dtb_index 3 ; else echo Error: Android boot is not supported for $board_name ; exit ; fi ; abootimg get dtb --index = $dtb_index dtb_start dtb_size ; cp.b $dtb_start $fdt_addr_r $dtb_size ; fdt addr $fdt_addr_r 0x80000 ; if test $board_name = sei510 ; then echo \" Reading DTBO for sei510...\" ; setenv dtbo_index 0 ; elif test $board_name = sei610 ; then echo \" Reading DTBO for sei610...\" ; setenv dtbo_index 1 ; elif test $board_name = vim3l ; then echo \" Reading DTBO for vim3l...\" ; setenv dtbo_index 2 ; elif test $board_name = vim3 ; then echo \" Reading DTBO for vim3...\" ; setenv dtbo_index 3 ; else echo Error: Android boot is not supported for $board_name ; exit ; fi ; part start mmc ${ mmcdev } dtbo ${ slot_suffix } p_dtbo_start ; part size mmc ${ mmcdev } dtbo ${ slot_suffix } p_dtbo_size ; mmc read ${ dtboaddr } ${ p_dtbo_start } ${ p_dtbo_size } ; echo \" Applying DTBOs...\" ; adtimg addr $dtboaddr ; adtimg get dt --index = $dtbo_index dtbo0_addr ; fdt apply $dtbo0_addr ; setenv bootargs \" $bootargs androidboot.dtbo_idx= $dtbo_index \" ; setenv bootargs \" ${ bootargs } \" ; echo Running Android... ; bootm ${ loadaddr } ${ loadaddr } ${ fdt_addr_r } ; fi ; echo Failed to boot Android... ; Todo o processo \u00e9 o mesmo do modo recovery a diferen\u00e7a fica nas seguintes linhas: part start mmc ${ mmcdev } boot ${ slot_suffix } boot_start ; part size mmc ${ mmcdev } boot ${ slot_suffix } boot_size ; Observe que agora o script busca pela parti\u00e7\u00e3o boot . O resto segue inalterado.","title":"O bootcmd_system"},{"location":"Boards/VIM3/Android/Bootloader/Carregando/#o-bootcmd_panic","text":"Atribu\u00eddo na linha 20, ele possui a seguinte implementa\u00e7\u00e3o: bootcmd_panic = fastboot 0 ; reset Como \u00faltimo recurso, caso n\u00e3o tenha sido poss\u00edvel fazer o boot do Android. O script entra no modo fastboot e ao sair ele reinicia a VIM3.","title":"O bootcmd_panic"},{"location":"Boards/VIM3/Android/Bootloader/Carregando/#conclusao","text":"Sem d\u00favida entender esse processo n\u00e3o \u00e9 algo trivial, n\u00e3o existe uma padroniza\u00e7\u00e3o e tudo fica na m\u00e3o do desenvolvedor na hora de criar o script respons\u00e1vel por carregar o kernel do Android. Com certeza, esse passo foi fundamental para um melhor entendimento de como o Android funciona.","title":"Conclus\u00e3o"},{"location":"Boards/VIM3/Android/Hal/","text":"Blink Led AIDL Image by Wilson Nantes from Pixabay Vale ressaltar que para esse post \u00e9 necess\u00e1rio j\u00e1 ter um produto buildado e para o ultimo t\u00f3pico \u00e9 preciso do display j\u00e1 em funcionamento. Introdu\u00e7\u00e3o Depois de fazer o curso Android 12 Internals material, labs and discussion , resolvi implementar um blink led utilizando a AIDL, e c\u00e1 estou registrando os meus passos aqui . Informa\u00e7\u00f5es \u00fateis Vers\u00e3o do AOSP: android-12.0.0_r4 Vers\u00e3o do kernel Android: android-amlogic-bmeson-5.4 Distro para compila\u00e7ao: Linux Mint 20.3 Vers\u00e3o do kernel da distro: 5.15.0-52-generic Implementa\u00e7\u00e3o Tentarei seguir os mesmos t\u00f3picos do post: Implementando a AIDL . HAL Na raiz da pasta do AOSP criei o seguinte caminho: mkdir -p device/casa/placamae/interfaces/userled/aidl/ Dentro da pasta, criei o seguinte arquivo: Android.bp aidl_interface { name : \"placamae.hal.userled\" , vendor : true , srcs : [ \"placamae/hal/userled/*.aidl\" ], stability : \"vintf\" , owner : \"Jao\" , backend : { cpp : { enabled : false , //enabled by default }, java : { sdk_version : \"module_current\" , }, ndk : { //ndk_platform is generated too, but it will deprecated on Android 13. //just ndk will be available. enabled : true , //enabled by default, just exposing } }, } ainda dentro da pasta, criei o seguinte caminho: mkdir -p placamae/hal/userled com o seguinte arquivo: IUserLed.aidl package placamae.hal.userled ; @VintfStability interface IUserLed { boolean setMode ( in String mode ); } O resultado foi esse: device/casa/placamae/interfaces/userled/aidl \u251c\u2500\u2500 Android.bp \u2514\u2500\u2500 placamae \u2514\u2500\u2500 hal \u2514\u2500\u2500 userled \u2514\u2500\u2500 IUserLed.aidl Agora \u00e9 s\u00f3 adicionar ao produto, no meu caso: meuproduto.mk ... PRODUCT_PACKAGES += \\ placamae.hal.userled Agora vamos gerar os arquivos fonte para a AIDL. Para isso, na pasta raiz do AOSP, digite: m placamae.hal.userled-update-api Esse comando vai gerar a pasta aidl_api : device/casa/placamae/interfaces/userled/aidl \u251c\u2500\u2500 aidl_api \u2502 \u2514\u2500\u2500 placamae.hal.userled \u2502 \u2514\u2500\u2500 current \u2502 \u2514\u2500\u2500 placamae \u2502 \u2514\u2500\u2500 hal \u2502 \u2514\u2500\u2500 userled \u2502 \u2514\u2500\u2500 IUserLed.aidl \u251c\u2500\u2500 Android.bp \u2514\u2500\u2500 placamae \u2514\u2500\u2500 hal \u2514\u2500\u2500 userled \u2514\u2500\u2500 IUserLed.aidl Agora dentro da pasta device/casa/placamae/interfaces/userled/aidl , digite o comando: mm Ela ir\u00e1 gerar as classes necess\u00e1rias dentro da pasta : out_placamae/soong/.intermediates/device/casa/placamae/interfaces/userled/aidl \u251c\u2500\u2500 placamae.hal.userled-api \u251c\u2500\u2500 placamae.hal.userled-V1-java \u251c\u2500\u2500 placamae.hal.userled-V1-java-source \u251c\u2500\u2500 placamae.hal.userled-V1-ndk \u251c\u2500\u2500 placamae.hal.userled-V1-ndk_platform \u251c\u2500\u2500 placamae.hal.userled-V1-ndk_platform-source \u2514\u2500\u2500 placamae.hal.userled-V1-ndk-source Servi\u00e7o Criei a pasta device/casa/placamae/interfaces/userled/aidl/default/ , e dentro dela os arquivos: UserLed.h // This library is available on: // out/soong/.intermediates/device/casa/placamae/interfaces/userled/aidl/ // inside: // placamae.hal.userled-V1-ndk_platform-source/gen/include/aidl/placamae/hal/userled #include <aidl/placamae/hal/userled/BnUserLed.h> namespace aidl :: placamae :: hal :: userled { class UserLed : public BnUserLed { public : static inline const char RED_LED [] = \"/sys/devices/platform/leds/leds/vim3:red/trigger\" ; public : ndk :: ScopedAStatus setMode ( const std :: string & in_mode , bool * _aidl_return ) override ; static int writeValue ( const char * file , const char * value ); }; } UserLed.cpp #include \"UserLed.h\" #include <utils/Log.h> #include <android-base/logging.h> #include <sys/stat.h> namespace aidl :: placamae :: hal :: userled { int UserLed::writeValue ( const char * file , const char * value ) { int fd ; int str_len = strlen ( value ) + 1 ; fd = open ( file , O_WRONLY ); if ( fd < 0 ) { return -1 ; } if ( ! write ( fd , value , str_len )){ close ( fd ); return -1 ; } close ( fd ); return 0 ; } ndk :: ScopedAStatus UserLed::setMode ( const std :: string & in_mode , bool * _aidl_return ) { LOG ( INFO ) << \"UserLed -> setMode data=(\" << in_mode . c_str () << \")\" ; * _aidl_return = this -> writeValue ( RED_LED , in_mode . c_str ()) == 0 ; return ndk :: ScopedAStatus :: ok (); } } service.cpp #define LOG_TAG \"placamae.hal.userled\" #include <android-base/logging.h> #include <android/binder_process.h> #include <binder/ProcessState.h> #include <android/binder_manager.h> #include <binder/IServiceManager.h> #include \"UserLed.h\" using aidl :: placamae :: hal :: userled :: UserLed ; using std :: string_literals :: operator \"\" s ; int main (){ LOG ( INFO ) << \"UserLed -> TESSSSSSTE\" ; const std :: string name = UserLed :: descriptor + \"/default\" s ; android :: ProcessState :: initWithDriver ( \"/dev/vndbinder\" ); ABinderProcess_startThreadPool (); LOG ( INFO ) << \"UserLed -> Service is starting...\" ; std :: shared_ptr < UserLed > userLed = ndk :: SharedRefBase :: make < UserLed > (); CHECK_EQ ( STATUS_OK , AServiceManager_addService ( userLed -> asBinder (). get (), name . c_str ())); LOG ( INFO ) << \"UserLed -> started...\" ; ABinderProcess_joinThreadPool (); return EXIT_FAILURE ; // should not reach } Android.bp cc_binary { name : \"placamae.hal.userled-service\" , vendor : true , relative_install_path : \"hw\" , init_rc : [ \"placamae.hal.userled-service.rc\" ], vintf_fragments : [ \"placamae.hal.userled-service.xml\" ], srcs : [ \"service.cpp\" , \"UserLed.cpp\" ], cflags : [ \"-Wall\" , \"-Werror\" , ], shared_libs : [ \"libbase\" , \"liblog\" , \"libhardware\" , \"libbinder_ndk\" , \"libbinder\" , \"libutils\" , //ndk_platform will be deprecated on Android 13. \"placamae.hal.userled-V1-ndk_platform\" , ], } placamae.hal.userled-service.rc service placamae.hal.userled-service /vendor/bin/hw/placamae.hal.userled-service interface aidl placamae.hal.userled-service.IUserLed/default class hal user system group system on boot chown system system /sys/devices/platform/leds/leds/vim3:red/trigger chmod 0660 /sys/devices/platform/leds/leds/vim3:red/trigger placamae.hal.userled-service.xml <manifest version= \"1.0\" type= \"device\" > <hal format= \"aidl\" > <name> placamae.hal.userled </name> <version> 1 </version> <fqname> IUserLed/default </fqname> </hal> </manifest> Agora s\u00f3 resta adicionar o servi\u00e7o ao produto: meuproduto.mk ... PRODUCT_PACKAGES += \\ placamae.hal.userled \\ placamae.hal.userled-service Permiss\u00f5es Para facilitar a implementa\u00e7\u00e3o, foi definido a permiss\u00e3o permissiva , mas ainda \u00e9 necess\u00e1rio subir o servi\u00e7o. Essa etapa \u00e9 feita via sepolicy. Para isso, criei a pasta: mkdir -p device/casa/placamae/sepolicy Dentro dela criei os arquivos: file_contexts / vendor / bin / hw / placamae \\ . hal \\ . userled - service u : object_r : hal_userled_default_exec : s0 hal_userled_default.te type hal_userled_default , domain ; type hal_userled_default_exec , exec_type , vendor_file_type , file_type ; init_daemon_domain ( hal_userled_default ); Por fim, adicionei a pasta sepolicy no: BoardConfig.mk ... BOARD_SEPOLICY_DIRS += device / casa / placamae / sepolicy Testando Para testar a HAL, criei a pasta: mkdir -p device/casa/placamae/interfaces/userled/aidl/default/LedTest e dentro dela os seguintes arquivos: LedTest.cpp #include <aidl/placamae/hal/userled/IUserLed.h> #include <android/binder_manager.h> #include <iostream> #include <string> using :: aidl :: placamae :: hal :: userled :: IUserLed ; int main ( int argc , char * argv []) { std :: shared_ptr < IUserLed > mHal ; std :: string a ; bool c ; if ( argc != 2 ) { std :: cout << \"USAGE ./LedTest <none|heartbeat|default-on> \\n \" ; exit ( 0 ); } AIBinder * binder = AServiceManager_waitForService ( \"placamae.hal.userled.IUserLed/default\" ); if ( binder == nullptr ){ std :: cout << \"Failed to get cpu service \\n \" ; exit ( -1 ); } mHal = IUserLed :: fromBinder ( ndk :: SpAIBinder ( binder )); mHal -> setMode ( argv [ 1 ], & c ); std :: cout << \"setScalingGovernor:\" << c << std :: endl ; return 0 ; } Android.bp cc_binary { name : \"LedTest\" , vendor : true , relative_install_path : \"hw\" , srcs : [ \"LedTest.cpp\" ], shared_libs : [ \"libbase\" , \"liblog\" , \"libhardware\" , \"libbinder_ndk\" , \"libbinder\" , \"libutils\" , //ndk_platform will be deprecated on Android 13. \"placamae.hal.userled-V1-ndk_platform\" , ], } Na pasta raiz do AOSP: m -j16 Depois de terminar a build, flashei os bin\u00e1rios e esperei o Android subir para ter acesso ao ADB. Para testar o servi\u00e7o, utilizei os comandos: adb root adb shell cd /vendor/bin/hw ./LedTest heartbeat Ap\u00f3s esses comandos o LED vermelho da placa come\u00e7ar\u00e1 a piscar. Criando uma aplica\u00e7\u00e3o Para ter uma intera\u00e7\u00e3o melhor com o servi\u00e7o, criei um app simples em java. Dessa forma, \u00e9 poss\u00edvel alterar o estado do LED apenas apertando os bot\u00f5es da aplica\u00e7\u00e3o. Primeiro, dentro da pasta raiz do AOSP, criei a pasta: mkdir -p device/casa/placamae/app/UserLedApp Dentro dela crie os arquivos: AndroidManifest.xml <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android= \"http://schemas.android.com/apk/res/android\" xmlns:tools= \"http://schemas.android.com/tools\" package= \"com.example.userledapp\" > <application android:name= \".UserLedServiceApp\" android:label= \"UserLedApp\" > <activity android:name= \".MainActivity\" android:exported= \"true\" > <intent-filter> <action android:name= \"android.intent.action.MAIN\" /> <category android:name= \"android.intent.category.LAUNCHER\" /> </intent-filter> </activity> </application> </manifest> Android.bp android_app { name : \"UserLedApp\" , certificate : \"platform\" , // to be a persistent app system_ext_specific : true , platform_apis : true , static_libs : [ \"placamae.hal.userled-V1-java\" , \"androidx-constraintlayout_constraintlayout\" , \"androidx-constraintlayout_constraintlayout-solver\" , ], // package native libs in the APK use_embedded_native_libs : true , resource_dirs : [ \"res\" ], srcs : [ \"java/**/*.java\" , ], } Depois criei a seguinte pasta: mkdir -p device/casa/placamae/app/UserLedApp/java/com/example/userledapp/ e dentro delas as seguintes classes: MainActivity.java package com.example.userledapp ; import android.app.Activity ; import android.os.Bundle ; import android.util.Log ; import android.view.View ; import android.widget.Button ; import android.widget.TextView ; public class MainActivity extends Activity { @Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ); setContentView ( R . layout . activity_main ); } @Override protected void onResume () { super . onResume (); } public void onClick ( View view ) { String setValue = (( Button ) view ). getText (). toString (); try { UserLedServiceApp . getLed (). setMode ( setValue ); } catch ( android . os . RemoteException e ) { Log . e ( \"userled\" , \"AIDL Java proxy returned error\" , e ); } } } UserLedBroadcastReceiver.java package com.example.userledapp ; import android.content.BroadcastReceiver ; import android.content.Context ; import android.content.Intent ; import android.util.Log ; public class UserLedBroadcastReceiver extends BroadcastReceiver { private static final String TAG = \"userledAppBroadcast\" ; @Override public void onReceive ( Context context , Intent intent ) { String mode = intent . getStringExtra ( \"setMode\" ); if ( mode != null ) { try { if ( UserLedServiceApp . getLed (). setMode ( mode )) { Log . d ( TAG , \"Succesfuly setMode to (\" + mode + \")\" ); } else { Log . e ( TAG , \"Failed calling setMode to (\" + mode + \")\" ); } } catch ( android . os . RemoteException e ) { Log . e ( TAG , \"IUserLed error\" , e ); } } } } UserLedServiceApp.java package com.example.userledapp ; import android.app.Application ; import android.content.IntentFilter ; import android.os.IBinder ; import android.os.ServiceManager ; import android.util.Log ; public class UserLedServiceApp extends Application { private static final String TAG = \"userledServiceApp\" ; private static final String INTERFACE = \"placamae.hal.userled.IUserLed/default\" ; UserLedBroadcastReceiver broadcast = new UserLedBroadcastReceiver (); private static placamae . hal . userled . IUserLed Led ; // AIDL Java Proxy @Override public void onCreate () { super . onCreate (); IBinder binder = ServiceManager . getService ( INTERFACE ); if ( binder == null ) { Log . e ( TAG , \"Getting \" + INTERFACE + \" service daemon binder failed\" ); } else { Led = placamae . hal . userled . IUserLed . Stub . asInterface ( binder ); if ( Led == null ) { Log . e ( TAG , \"Getting ICpu Aidl daemon interface failed\" ); } } IntentFilter filter = new IntentFilter ( \"com.fooHIDL.fooHIDL\" ); registerReceiver ( broadcast , filter ); } public void onTerminate () { super . onTerminate (); Log . d ( TAG , \"Terminated\" ); } // AIDL Java Proxy public static placamae . hal . userled . IUserLed getLed () { return Led ; } } Agora criei a pasta: mkdir -p device/casa/placamae/app/UserLedApp/res/layout com o seguinte arquivo: activity_main.xml <?xml version=\"1.0\" encoding=\"utf-8\"?> <androidx.constraintlayout.widget.ConstraintLayout xmlns:android= \"http://schemas.android.com/apk/res/android\" xmlns:app= \"http://schemas.android.com/apk/res-auto\" android:layout_width= \"match_parent\" android:layout_height= \"match_parent\" > <androidx.constraintlayout.widget.Guideline android:id= \"@+id/middleGuideLine\" android:layout_width= \"wrap_content\" android:layout_height= \"wrap_content\" android:orientation= \"horizontal\" app:layout_constraintEnd_toEndOf= \"parent\" app:layout_constraintGuide_percent= \"1\" app:layout_constraintStart_toStartOf= \"parent\" /> <Button android:id= \"@+id/onButton\" android:layout_width= \"0dp\" android:layout_height= \"wrap_content\" android:layout_marginStart= \"200dp\" android:layout_marginTop= \"72dp\" android:onClick= \"onClick\" android:text= \"default-on\" app:layout_constraintStart_toStartOf= \"parent\" app:layout_constraintTop_toTopOf= \"parent\" /> <Button android:id= \"@+id/offButton\" android:layout_width= \"0dp\" android:layout_height= \"wrap_content\" android:layout_marginStart= \"440dp\" android:layout_marginTop= \"76dp\" android:onClick= \"onClick\" android:text= \"none\" app:layout_constraintStart_toStartOf= \"parent\" app:layout_constraintTop_toTopOf= \"parent\" /> <Button android:id= \"@+id/blinkButton\" android:layout_width= \"329dp\" android:layout_height= \"46dp\" android:layout_marginTop= \"212dp\" android:onClick= \"onClick\" android:text= \"heartbeat\" app:layout_constraintEnd_toEndOf= \"parent\" app:layout_constraintStart_toStartOf= \"parent\" app:layout_constraintTop_toTopOf= \"parent\" /> </androidx.constraintlayout.widget.ConstraintLayout> A estrutura final ficou assim: device/casa/placamae/app/UserLedApp \u251c\u2500\u2500 Android.bp \u251c\u2500\u2500 AndroidManifest.xml \u251c\u2500\u2500 java \u2502 \u2514\u2500\u2500 com \u2502 \u2514\u2500\u2500 example \u2502 \u2514\u2500\u2500 userledapp \u2502 \u251c\u2500\u2500 MainActivity.java \u2502 \u251c\u2500\u2500 UserLedBroadcastReceiver.java \u2502 \u2514\u2500\u2500 UserLedServiceApp.java \u2514\u2500\u2500 res \u2514\u2500\u2500 layout \u2514\u2500\u2500 activity_main.xml Por fim, \u00e9 s\u00f3 rebuildar o AOSP, flashar as imagens e procurar pelo app UserLedApp . Esse \u00e9 o resultado do funcionamento do aplicativo ativando e desativando o LED vermelho da placa. Conclus\u00e3o Apesar de posuir muitos passos, implementar uma HAL utilizando AIDL \u00e9 mais simples que uma HILD. N\u00e3o foi preciso implementar uma JNI, pois o AIDL j\u00e1 gera o backend em java. Isso e outras coisas acabam facilidando a implementa\u00e7\u00e3o. O Led vermleho j\u00e1 vem habilitado por padr\u00e3o pelo kernel que foi utilizado. Um pr\u00f3ximo passo seria utilizar outra porta GPIO, por padr\u00e3o, elas n\u00e3o vem ativadas e esse seria mais um desafio na parte de kernel, do que de uma HAL. Por fim, vale relembar que que o ndk_platform ira ser depreciado a partir do Android 13, sendo substitu\u00eddo pelo ndk , apenas. Para tirar algumas d\u00favidas de implementa\u00e7\u00e3o, costumo consultar a HAL de Power . Foi nela que encontrei essa informa\u00e7\u00e3o ( ndk_platform depreciado ).","title":"Blink Led AIDL"},{"location":"Boards/VIM3/Android/Hal/#blink-led-aidl","text":"Image by Wilson Nantes from Pixabay Vale ressaltar que para esse post \u00e9 necess\u00e1rio j\u00e1 ter um produto buildado e para o ultimo t\u00f3pico \u00e9 preciso do display j\u00e1 em funcionamento.","title":"Blink Led AIDL"},{"location":"Boards/VIM3/Android/Hal/#introducao","text":"Depois de fazer o curso Android 12 Internals material, labs and discussion , resolvi implementar um blink led utilizando a AIDL, e c\u00e1 estou registrando os meus passos aqui .","title":"Introdu\u00e7\u00e3o"},{"location":"Boards/VIM3/Android/Hal/#informacoes-uteis","text":"Vers\u00e3o do AOSP: android-12.0.0_r4 Vers\u00e3o do kernel Android: android-amlogic-bmeson-5.4 Distro para compila\u00e7ao: Linux Mint 20.3 Vers\u00e3o do kernel da distro: 5.15.0-52-generic","title":"Informa\u00e7\u00f5es \u00fateis"},{"location":"Boards/VIM3/Android/Hal/#implementacao","text":"Tentarei seguir os mesmos t\u00f3picos do post: Implementando a AIDL .","title":"Implementa\u00e7\u00e3o"},{"location":"Boards/VIM3/Android/Hal/#hal","text":"Na raiz da pasta do AOSP criei o seguinte caminho: mkdir -p device/casa/placamae/interfaces/userled/aidl/ Dentro da pasta, criei o seguinte arquivo: Android.bp aidl_interface { name : \"placamae.hal.userled\" , vendor : true , srcs : [ \"placamae/hal/userled/*.aidl\" ], stability : \"vintf\" , owner : \"Jao\" , backend : { cpp : { enabled : false , //enabled by default }, java : { sdk_version : \"module_current\" , }, ndk : { //ndk_platform is generated too, but it will deprecated on Android 13. //just ndk will be available. enabled : true , //enabled by default, just exposing } }, } ainda dentro da pasta, criei o seguinte caminho: mkdir -p placamae/hal/userled com o seguinte arquivo: IUserLed.aidl package placamae.hal.userled ; @VintfStability interface IUserLed { boolean setMode ( in String mode ); } O resultado foi esse: device/casa/placamae/interfaces/userled/aidl \u251c\u2500\u2500 Android.bp \u2514\u2500\u2500 placamae \u2514\u2500\u2500 hal \u2514\u2500\u2500 userled \u2514\u2500\u2500 IUserLed.aidl Agora \u00e9 s\u00f3 adicionar ao produto, no meu caso: meuproduto.mk ... PRODUCT_PACKAGES += \\ placamae.hal.userled Agora vamos gerar os arquivos fonte para a AIDL. Para isso, na pasta raiz do AOSP, digite: m placamae.hal.userled-update-api Esse comando vai gerar a pasta aidl_api : device/casa/placamae/interfaces/userled/aidl \u251c\u2500\u2500 aidl_api \u2502 \u2514\u2500\u2500 placamae.hal.userled \u2502 \u2514\u2500\u2500 current \u2502 \u2514\u2500\u2500 placamae \u2502 \u2514\u2500\u2500 hal \u2502 \u2514\u2500\u2500 userled \u2502 \u2514\u2500\u2500 IUserLed.aidl \u251c\u2500\u2500 Android.bp \u2514\u2500\u2500 placamae \u2514\u2500\u2500 hal \u2514\u2500\u2500 userled \u2514\u2500\u2500 IUserLed.aidl Agora dentro da pasta device/casa/placamae/interfaces/userled/aidl , digite o comando: mm Ela ir\u00e1 gerar as classes necess\u00e1rias dentro da pasta : out_placamae/soong/.intermediates/device/casa/placamae/interfaces/userled/aidl \u251c\u2500\u2500 placamae.hal.userled-api \u251c\u2500\u2500 placamae.hal.userled-V1-java \u251c\u2500\u2500 placamae.hal.userled-V1-java-source \u251c\u2500\u2500 placamae.hal.userled-V1-ndk \u251c\u2500\u2500 placamae.hal.userled-V1-ndk_platform \u251c\u2500\u2500 placamae.hal.userled-V1-ndk_platform-source \u2514\u2500\u2500 placamae.hal.userled-V1-ndk-source","title":"HAL"},{"location":"Boards/VIM3/Android/Hal/#servico","text":"Criei a pasta device/casa/placamae/interfaces/userled/aidl/default/ , e dentro dela os arquivos: UserLed.h // This library is available on: // out/soong/.intermediates/device/casa/placamae/interfaces/userled/aidl/ // inside: // placamae.hal.userled-V1-ndk_platform-source/gen/include/aidl/placamae/hal/userled #include <aidl/placamae/hal/userled/BnUserLed.h> namespace aidl :: placamae :: hal :: userled { class UserLed : public BnUserLed { public : static inline const char RED_LED [] = \"/sys/devices/platform/leds/leds/vim3:red/trigger\" ; public : ndk :: ScopedAStatus setMode ( const std :: string & in_mode , bool * _aidl_return ) override ; static int writeValue ( const char * file , const char * value ); }; } UserLed.cpp #include \"UserLed.h\" #include <utils/Log.h> #include <android-base/logging.h> #include <sys/stat.h> namespace aidl :: placamae :: hal :: userled { int UserLed::writeValue ( const char * file , const char * value ) { int fd ; int str_len = strlen ( value ) + 1 ; fd = open ( file , O_WRONLY ); if ( fd < 0 ) { return -1 ; } if ( ! write ( fd , value , str_len )){ close ( fd ); return -1 ; } close ( fd ); return 0 ; } ndk :: ScopedAStatus UserLed::setMode ( const std :: string & in_mode , bool * _aidl_return ) { LOG ( INFO ) << \"UserLed -> setMode data=(\" << in_mode . c_str () << \")\" ; * _aidl_return = this -> writeValue ( RED_LED , in_mode . c_str ()) == 0 ; return ndk :: ScopedAStatus :: ok (); } } service.cpp #define LOG_TAG \"placamae.hal.userled\" #include <android-base/logging.h> #include <android/binder_process.h> #include <binder/ProcessState.h> #include <android/binder_manager.h> #include <binder/IServiceManager.h> #include \"UserLed.h\" using aidl :: placamae :: hal :: userled :: UserLed ; using std :: string_literals :: operator \"\" s ; int main (){ LOG ( INFO ) << \"UserLed -> TESSSSSSTE\" ; const std :: string name = UserLed :: descriptor + \"/default\" s ; android :: ProcessState :: initWithDriver ( \"/dev/vndbinder\" ); ABinderProcess_startThreadPool (); LOG ( INFO ) << \"UserLed -> Service is starting...\" ; std :: shared_ptr < UserLed > userLed = ndk :: SharedRefBase :: make < UserLed > (); CHECK_EQ ( STATUS_OK , AServiceManager_addService ( userLed -> asBinder (). get (), name . c_str ())); LOG ( INFO ) << \"UserLed -> started...\" ; ABinderProcess_joinThreadPool (); return EXIT_FAILURE ; // should not reach } Android.bp cc_binary { name : \"placamae.hal.userled-service\" , vendor : true , relative_install_path : \"hw\" , init_rc : [ \"placamae.hal.userled-service.rc\" ], vintf_fragments : [ \"placamae.hal.userled-service.xml\" ], srcs : [ \"service.cpp\" , \"UserLed.cpp\" ], cflags : [ \"-Wall\" , \"-Werror\" , ], shared_libs : [ \"libbase\" , \"liblog\" , \"libhardware\" , \"libbinder_ndk\" , \"libbinder\" , \"libutils\" , //ndk_platform will be deprecated on Android 13. \"placamae.hal.userled-V1-ndk_platform\" , ], } placamae.hal.userled-service.rc service placamae.hal.userled-service /vendor/bin/hw/placamae.hal.userled-service interface aidl placamae.hal.userled-service.IUserLed/default class hal user system group system on boot chown system system /sys/devices/platform/leds/leds/vim3:red/trigger chmod 0660 /sys/devices/platform/leds/leds/vim3:red/trigger placamae.hal.userled-service.xml <manifest version= \"1.0\" type= \"device\" > <hal format= \"aidl\" > <name> placamae.hal.userled </name> <version> 1 </version> <fqname> IUserLed/default </fqname> </hal> </manifest> Agora s\u00f3 resta adicionar o servi\u00e7o ao produto: meuproduto.mk ... PRODUCT_PACKAGES += \\ placamae.hal.userled \\ placamae.hal.userled-service","title":"Servi\u00e7o"},{"location":"Boards/VIM3/Android/Hal/#permissoes","text":"Para facilitar a implementa\u00e7\u00e3o, foi definido a permiss\u00e3o permissiva , mas ainda \u00e9 necess\u00e1rio subir o servi\u00e7o. Essa etapa \u00e9 feita via sepolicy. Para isso, criei a pasta: mkdir -p device/casa/placamae/sepolicy Dentro dela criei os arquivos: file_contexts / vendor / bin / hw / placamae \\ . hal \\ . userled - service u : object_r : hal_userled_default_exec : s0 hal_userled_default.te type hal_userled_default , domain ; type hal_userled_default_exec , exec_type , vendor_file_type , file_type ; init_daemon_domain ( hal_userled_default ); Por fim, adicionei a pasta sepolicy no: BoardConfig.mk ... BOARD_SEPOLICY_DIRS += device / casa / placamae / sepolicy","title":"Permiss\u00f5es"},{"location":"Boards/VIM3/Android/Hal/#testando","text":"Para testar a HAL, criei a pasta: mkdir -p device/casa/placamae/interfaces/userled/aidl/default/LedTest e dentro dela os seguintes arquivos: LedTest.cpp #include <aidl/placamae/hal/userled/IUserLed.h> #include <android/binder_manager.h> #include <iostream> #include <string> using :: aidl :: placamae :: hal :: userled :: IUserLed ; int main ( int argc , char * argv []) { std :: shared_ptr < IUserLed > mHal ; std :: string a ; bool c ; if ( argc != 2 ) { std :: cout << \"USAGE ./LedTest <none|heartbeat|default-on> \\n \" ; exit ( 0 ); } AIBinder * binder = AServiceManager_waitForService ( \"placamae.hal.userled.IUserLed/default\" ); if ( binder == nullptr ){ std :: cout << \"Failed to get cpu service \\n \" ; exit ( -1 ); } mHal = IUserLed :: fromBinder ( ndk :: SpAIBinder ( binder )); mHal -> setMode ( argv [ 1 ], & c ); std :: cout << \"setScalingGovernor:\" << c << std :: endl ; return 0 ; } Android.bp cc_binary { name : \"LedTest\" , vendor : true , relative_install_path : \"hw\" , srcs : [ \"LedTest.cpp\" ], shared_libs : [ \"libbase\" , \"liblog\" , \"libhardware\" , \"libbinder_ndk\" , \"libbinder\" , \"libutils\" , //ndk_platform will be deprecated on Android 13. \"placamae.hal.userled-V1-ndk_platform\" , ], } Na pasta raiz do AOSP: m -j16 Depois de terminar a build, flashei os bin\u00e1rios e esperei o Android subir para ter acesso ao ADB. Para testar o servi\u00e7o, utilizei os comandos: adb root adb shell cd /vendor/bin/hw ./LedTest heartbeat Ap\u00f3s esses comandos o LED vermelho da placa come\u00e7ar\u00e1 a piscar.","title":"Testando"},{"location":"Boards/VIM3/Android/Hal/#criando-uma-aplicacao","text":"Para ter uma intera\u00e7\u00e3o melhor com o servi\u00e7o, criei um app simples em java. Dessa forma, \u00e9 poss\u00edvel alterar o estado do LED apenas apertando os bot\u00f5es da aplica\u00e7\u00e3o. Primeiro, dentro da pasta raiz do AOSP, criei a pasta: mkdir -p device/casa/placamae/app/UserLedApp Dentro dela crie os arquivos: AndroidManifest.xml <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android= \"http://schemas.android.com/apk/res/android\" xmlns:tools= \"http://schemas.android.com/tools\" package= \"com.example.userledapp\" > <application android:name= \".UserLedServiceApp\" android:label= \"UserLedApp\" > <activity android:name= \".MainActivity\" android:exported= \"true\" > <intent-filter> <action android:name= \"android.intent.action.MAIN\" /> <category android:name= \"android.intent.category.LAUNCHER\" /> </intent-filter> </activity> </application> </manifest> Android.bp android_app { name : \"UserLedApp\" , certificate : \"platform\" , // to be a persistent app system_ext_specific : true , platform_apis : true , static_libs : [ \"placamae.hal.userled-V1-java\" , \"androidx-constraintlayout_constraintlayout\" , \"androidx-constraintlayout_constraintlayout-solver\" , ], // package native libs in the APK use_embedded_native_libs : true , resource_dirs : [ \"res\" ], srcs : [ \"java/**/*.java\" , ], } Depois criei a seguinte pasta: mkdir -p device/casa/placamae/app/UserLedApp/java/com/example/userledapp/ e dentro delas as seguintes classes: MainActivity.java package com.example.userledapp ; import android.app.Activity ; import android.os.Bundle ; import android.util.Log ; import android.view.View ; import android.widget.Button ; import android.widget.TextView ; public class MainActivity extends Activity { @Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ); setContentView ( R . layout . activity_main ); } @Override protected void onResume () { super . onResume (); } public void onClick ( View view ) { String setValue = (( Button ) view ). getText (). toString (); try { UserLedServiceApp . getLed (). setMode ( setValue ); } catch ( android . os . RemoteException e ) { Log . e ( \"userled\" , \"AIDL Java proxy returned error\" , e ); } } } UserLedBroadcastReceiver.java package com.example.userledapp ; import android.content.BroadcastReceiver ; import android.content.Context ; import android.content.Intent ; import android.util.Log ; public class UserLedBroadcastReceiver extends BroadcastReceiver { private static final String TAG = \"userledAppBroadcast\" ; @Override public void onReceive ( Context context , Intent intent ) { String mode = intent . getStringExtra ( \"setMode\" ); if ( mode != null ) { try { if ( UserLedServiceApp . getLed (). setMode ( mode )) { Log . d ( TAG , \"Succesfuly setMode to (\" + mode + \")\" ); } else { Log . e ( TAG , \"Failed calling setMode to (\" + mode + \")\" ); } } catch ( android . os . RemoteException e ) { Log . e ( TAG , \"IUserLed error\" , e ); } } } } UserLedServiceApp.java package com.example.userledapp ; import android.app.Application ; import android.content.IntentFilter ; import android.os.IBinder ; import android.os.ServiceManager ; import android.util.Log ; public class UserLedServiceApp extends Application { private static final String TAG = \"userledServiceApp\" ; private static final String INTERFACE = \"placamae.hal.userled.IUserLed/default\" ; UserLedBroadcastReceiver broadcast = new UserLedBroadcastReceiver (); private static placamae . hal . userled . IUserLed Led ; // AIDL Java Proxy @Override public void onCreate () { super . onCreate (); IBinder binder = ServiceManager . getService ( INTERFACE ); if ( binder == null ) { Log . e ( TAG , \"Getting \" + INTERFACE + \" service daemon binder failed\" ); } else { Led = placamae . hal . userled . IUserLed . Stub . asInterface ( binder ); if ( Led == null ) { Log . e ( TAG , \"Getting ICpu Aidl daemon interface failed\" ); } } IntentFilter filter = new IntentFilter ( \"com.fooHIDL.fooHIDL\" ); registerReceiver ( broadcast , filter ); } public void onTerminate () { super . onTerminate (); Log . d ( TAG , \"Terminated\" ); } // AIDL Java Proxy public static placamae . hal . userled . IUserLed getLed () { return Led ; } } Agora criei a pasta: mkdir -p device/casa/placamae/app/UserLedApp/res/layout com o seguinte arquivo: activity_main.xml <?xml version=\"1.0\" encoding=\"utf-8\"?> <androidx.constraintlayout.widget.ConstraintLayout xmlns:android= \"http://schemas.android.com/apk/res/android\" xmlns:app= \"http://schemas.android.com/apk/res-auto\" android:layout_width= \"match_parent\" android:layout_height= \"match_parent\" > <androidx.constraintlayout.widget.Guideline android:id= \"@+id/middleGuideLine\" android:layout_width= \"wrap_content\" android:layout_height= \"wrap_content\" android:orientation= \"horizontal\" app:layout_constraintEnd_toEndOf= \"parent\" app:layout_constraintGuide_percent= \"1\" app:layout_constraintStart_toStartOf= \"parent\" /> <Button android:id= \"@+id/onButton\" android:layout_width= \"0dp\" android:layout_height= \"wrap_content\" android:layout_marginStart= \"200dp\" android:layout_marginTop= \"72dp\" android:onClick= \"onClick\" android:text= \"default-on\" app:layout_constraintStart_toStartOf= \"parent\" app:layout_constraintTop_toTopOf= \"parent\" /> <Button android:id= \"@+id/offButton\" android:layout_width= \"0dp\" android:layout_height= \"wrap_content\" android:layout_marginStart= \"440dp\" android:layout_marginTop= \"76dp\" android:onClick= \"onClick\" android:text= \"none\" app:layout_constraintStart_toStartOf= \"parent\" app:layout_constraintTop_toTopOf= \"parent\" /> <Button android:id= \"@+id/blinkButton\" android:layout_width= \"329dp\" android:layout_height= \"46dp\" android:layout_marginTop= \"212dp\" android:onClick= \"onClick\" android:text= \"heartbeat\" app:layout_constraintEnd_toEndOf= \"parent\" app:layout_constraintStart_toStartOf= \"parent\" app:layout_constraintTop_toTopOf= \"parent\" /> </androidx.constraintlayout.widget.ConstraintLayout> A estrutura final ficou assim: device/casa/placamae/app/UserLedApp \u251c\u2500\u2500 Android.bp \u251c\u2500\u2500 AndroidManifest.xml \u251c\u2500\u2500 java \u2502 \u2514\u2500\u2500 com \u2502 \u2514\u2500\u2500 example \u2502 \u2514\u2500\u2500 userledapp \u2502 \u251c\u2500\u2500 MainActivity.java \u2502 \u251c\u2500\u2500 UserLedBroadcastReceiver.java \u2502 \u2514\u2500\u2500 UserLedServiceApp.java \u2514\u2500\u2500 res \u2514\u2500\u2500 layout \u2514\u2500\u2500 activity_main.xml Por fim, \u00e9 s\u00f3 rebuildar o AOSP, flashar as imagens e procurar pelo app UserLedApp . Esse \u00e9 o resultado do funcionamento do aplicativo ativando e desativando o LED vermelho da placa.","title":"Criando uma aplica\u00e7\u00e3o"},{"location":"Boards/VIM3/Android/Hal/#conclusao","text":"Apesar de posuir muitos passos, implementar uma HAL utilizando AIDL \u00e9 mais simples que uma HILD. N\u00e3o foi preciso implementar uma JNI, pois o AIDL j\u00e1 gera o backend em java. Isso e outras coisas acabam facilidando a implementa\u00e7\u00e3o. O Led vermleho j\u00e1 vem habilitado por padr\u00e3o pelo kernel que foi utilizado. Um pr\u00f3ximo passo seria utilizar outra porta GPIO, por padr\u00e3o, elas n\u00e3o vem ativadas e esse seria mais um desafio na parte de kernel, do que de uma HAL. Por fim, vale relembar que que o ndk_platform ira ser depreciado a partir do Android 13, sendo substitu\u00eddo pelo ndk , apenas. Para tirar algumas d\u00favidas de implementa\u00e7\u00e3o, costumo consultar a HAL de Power . Foi nela que encontrei essa informa\u00e7\u00e3o ( ndk_platform depreciado ).","title":"Conclus\u00e3o"},{"location":"Boards/VIM3/Android/Hal/HIDL/","text":"Blink Led HIDL Image by Gerd Altmann from Pixabay Vale ressaltar que para esse post \u00e9 necess\u00e1rio j\u00e1 ter um produto buildado e para o ultimo t\u00f3pico \u00e9 preciso do display j\u00e1 em funcionamento. Introdu\u00e7\u00e3o Apesar de j\u00e1 estar depreciado, o HIDL ainda pode ser largamente encontrado no c\u00f3digo fonte do AOSP. Caso algum c\u00f3digo legado apare\u00e7a, n\u00e3o custa nada ter esse tutorial pra relembrar com \u00e9 feito um processo completo de implementa\u00e7\u00e3o da HIDL. Informa\u00e7\u00f5es \u00fateis Vers\u00e3o do AOSP: android-12.0.0_r4 Vers\u00e3o do kernel Android: android-amlogic-bmeson-5.4 Distro para compila\u00e7ao: Ubuntu 22.04.1 LTS Vers\u00e3o do kernel da distro: 5.15.0-53-generic Implementa\u00e7\u00e3o Tentarei seguir os mesmos t\u00f3picos do post: Implementando a HIDL . HAL Na raiz da pasta do AOSP criei o seguinte caminho: mkdir -p device/casa/placamae/interfaces/userled Dentro da pasta, criei o seguinte arquivo: Android.bp hidl_package_root { name : \"placamae.hal.userled\" , path : \"device/casa/emulator/interfaces/userled\" , } Agora, criei a pasta: mkdir 1 .0 e dentro dela os seguintes arquivos: Android.bp hidl_interface { name : \"placamae.hal.userled@1.0\" , root : \"placamae.hal.userled\" , //must be a prefix of placamae.hal.userled@1.0 gen_java : true , product_specific : true , srcs : [ \"IUserLed.hal\" , ] , interfaces : [ \"android.hidl.base@1.0\" , ] , } IUserLed.hal package placamae . hal . userled @ 1.0 ; interface IUserLed { setMode ( string mode ) generates ( bool result ); }; O resultado foi esse: device/casa/placamae/interfaces/userled/ \u251c\u2500\u2500 1.0 \u2502 \u251c\u2500\u2500 Android.bp \u2502 \u2514\u2500\u2500 IUserLed.hal \u2514\u2500\u2500 Android.bp Agora \u00e9 s\u00f3 adicionar ao produto, no meu caso: meuproduto.mk ... PRODUCT_PACKAGES += \\ placamae.hal.userled@1.0 Agora vamos gerar os arquivos fonte para a HIDL. Para isso, ainda dentro da pasta 1.0 , digite: mm Ele ir\u00e1 gerar as classes necess\u00e1rias dentro da pasta : out/soong/.intermediates/device/casa/placamae/interfaces/userled/1.0/ \u251c\u2500\u2500 placamae.hal.userled@1.0 \u251c\u2500\u2500 placamae.hal.userled@1.0-adapter \u251c\u2500\u2500 placamae.hal.userled@1.0-adapter_genc++ \u251c\u2500\u2500 placamae.hal.userled@1.0-adapter-helper \u251c\u2500\u2500 placamae.hal.userled@1.0-adapter-helper_genc++ \u251c\u2500\u2500 placamae.hal.userled@1.0-adapter-helper_genc++_headers \u251c\u2500\u2500 placamae.hal.userled@1.0_genc++ \u251c\u2500\u2500 placamae.hal.userled@1.0_genc++_headers \u251c\u2500\u2500 placamae.hal.userled-V1.0-java \u251c\u2500\u2500 placamae.hal.userled-V1.0-java_gen_java \u2514\u2500\u2500 placamae.hal.userled-V1.0-java-shallow Servi\u00e7o Criei a pasta device/casa/placamae/interfaces/userled/1.0/default/ , e dentro dela os arquivos: UserLed.h // Mesmo caminho ap\u00f3s: // placamae.hal.userled@1.0_genc++_headers/gen/placamae/hal/userled/1.0/ // dentro da pasta out/soong/.intermediates/device/casa/placamae/interfaces/userled/1.0/ #include <placamae/hal/userled/1.0/IUserled.h> namespace placamae { namespace hal { namespace userled { namespace V1_0 { namespace implementation { using :: android :: hardware :: hidl_string ; // const hidl_string using :: android :: hardware :: Return ; // Return<void> using :: android :: hardware :: Void ; // return Void(); using :: placamae :: hal :: userled :: V1_0 :: IUserled ; // public IUserled class UserLed : public IUserled { public : static inline const char RED_LED [] = \"/sys/devices/platform/leds/leds/vim3:red/trigger\" ; public : Return < bool > setMode ( const hidl_string & mode ) override ; static int writeValue ( const char * file , const char * value ); }; extern \"C\" IUserled * HIDL_FETCH_IUserled ( const char * name ); } // namespace implementation } // namespace V1_0 } // namespace userled } // namespace hal } // namespace placamae UserLed.cpp #include \"UserLed.h\" #include <log/log.h> #include <sys/stat.h> // struct stat info namespace placamae { namespace hal { namespace userled { namespace V1_0 { namespace implementation { int UserLed::writeValue ( const char * file , const char * value ) { int fd ; int str_len = strlen ( value ) + 1 ; fd = open ( file , O_WRONLY ); if ( fd < 0 ) { return -1 ; } if ( ! write ( fd , value , str_len )){ close ( fd ); return -1 ; } close ( fd ); return 0 ; } Return < bool > UserLed :: setMode ( const hidl_string & mode ) { ALOGI ( \"UserLed -> setMode data=(%s)\" , mode . c_str ()); return this -> write_value ( RED_LED , mode . c_str ()) == 0 ; } // Methods from ::android::hidl::base::V1_0::IBase follow. IUserled * HIDL_FETCH_IUserled ( const char * /* name */ ) { return new UserLed (); // Return new instance of this class } } // namespace implementation } // namespace V1_0 } // namespace userled } // namespace hal } // namespace placamae service.cpp #define LOG_TAG \"placamae.hal.userled@1.0-service\" #include <placamae/hal/userled/1.0/IUserled.h> #include <log/log.h> #include <hidl/HidlTransportSupport.h> #include \"UserLed.h\" using android :: sp ; using android :: status_t ; using android :: OK ; // libhwbinder: using android :: hardware :: configureRpcThreadpool ; using android :: hardware :: joinRpcThreadpool ; // Generated HIDL files using placamae :: hal :: userled :: V1_0 :: IUserled ; using placamae :: hal :: userled :: V1_0 :: implementation :: UserLed ; using namespace placamae ; int main ( int /* argc */ , char ** /* argv */ ) { ALOGI ( \"UserLed -> TESSSSSSTE\" ); // Android Strong Pointer (don't GC until exit) sp < IUserled > service = new UserLed (); if ( service == nullptr ) { ALOGE ( \"Can not create an instance of UserLed HAL, exiting.\" ); return 1 ; } // system/libhidl/transport/include/hidl/HidlTransportSupport.h // Configures the threadpool used for handling incoming RPC calls in this process: // @param maxThreads maximum number of threads in this process // @param callerWillJoin whether the caller will join the threadpool later. configureRpcThreadpool ( 1 , true /*callerWillJoin*/ ); // registerAsService calls registerAsServiceInternal in // system/libhidl/transport/ServiceManagement.cpp // registerAsServiceInternal registers with hwservicemanager status_t status = service -> registerAsService (); if ( status != OK ) { ALOGE ( \"Could not register service for UserLed HAL (%d), exiting.\" , status ); return 1 ; } ALOGI ( \"UserLed Service is ready\" ); // system/libhidl/transport/include/hidl/HidlTransportSupport.h // Joins a threadpool that you configured earlier joinRpcThreadpool (); // In normal operation, we don't expect the thread pool to exit ALOGE ( \"UserLed Service is shutting down\" ); return 1 ; } Android.bp cc_binary { name : \"placamae.hal.userled@1.0-service\" , init_rc : [ \"placamae.hal.userled@1.0-service.rc\" ] , srcs : [ \"service.cpp\" , \"UserLed.cpp\" ] , vintf_fragments : [ \"placamae.hal.userled@1.0-service.xml\" ] , vendor : true , relative_install_path : \"hw\" , shared_libs : [ \"libhidlbase\" , \"liblog\" , \"libutils\" , \"libhardware\" , \"placamae.hal.userled@1.0\" , ] , } placamae.hal.userled@1.0-service.rc service placamae.hal.userled-service /vendor/bin/hw/placamae.hal.userled@1.0-service interface placamae.hal.userled@1.0::IUserled default class hal user system group system on boot chown system system /sys/devices/platform/leds/leds/vim3:red/trigger chmod 0660 /sys/devices/platform/leds/leds/vim3:red/trigger placamae.hal.userled@1.0-service.xml <manifest version= \"1.0\" type= \"device\" > <hal format= \"hidl\" > <name> placamae.hal.userled </name> <transport> hwbinder </transport> <version> 1.0 </version> <interface> <name> IUserled </name> <instance> default </instance> </interface> <fqname> @1.0::IUserled/default </fqname> </hal> </manifest> O resultado foi esse: device/casa/placamae/interfaces/userled/ \u251c\u2500\u2500 1.0 \u2502 \u251c\u2500\u2500 Android.bp \u2502 \u251c\u2500\u2500 default \u2502 \u2502 \u251c\u2500\u2500 service.cpp \u2502 \u2502 \u251c\u2500\u2500 UserLed.cpp \u2502 \u2502 \u2514\u2500\u2500 UserLed.h \u2502 \u2514\u2500\u2500 IUserLed.hal \u2514\u2500\u2500 Android.bp Agora s\u00f3 resta adicionar o servi\u00e7o ao produto: meuproduto.mk ... PRODUCT_PACKAGES += \\ placamae.hal.userled@1.0 \\ placamae.hal.userled@1.0-service Permiss\u00f5es Para facilitar a implementa\u00e7\u00e3o, foi definido a permiss\u00e3o permissiva , mas ainda \u00e9 necess\u00e1rio subir o servi\u00e7o. Essa etapa \u00e9 feita via sepolicy. Para isso, criei a pasta: mkdir -p device/casa/placamae/sepolicy Dentro dela criei os arquivos: file_contexts /vendor/bin/hw/placamae\\.hal\\.userled@1\\.0-service u:object_r:hal_userled_default_exec:s0 hal_userled_default.te type hal_userled_default, domain; type hal_userled_default_exec, exec_type, vendor_file_type, file_type; init_daemon_domain(hal_userled_default); Por fim, adicionei a pasta sepolicy no: BoardConfig.mk ... BOARD_SEPOLICY_DIRS += device/casa/placamae/sepolicy Testando Para testar a HAL, criei a pasta: mkdir -p device/casa/placamae/interfaces/userled/1.0/default/LedTest e dentro dela os seguintes arquivos: LedTest.cpp #include <placamae/hal/userled/1.0/IUserled.h> #include <hidl/Status.h> #include <hidl/LegacySupport.h> #include <utils/misc.h> #include <hidl/HidlSupport.h> #include <iostream> #include <cstdlib> #include <string> using :: android :: sp ; using :: placamae :: hal :: userled :: V1_0 :: IUserled ; using android :: hardware :: hidl_string ; int main ( int argc , char * argv []) { iif ( argc != 2 ) { std :: cout << \"USAGE ./LedTest <none|heartbeat|default-on> \\n \" ; exit ( 0 ); } android :: sp < IUserled > mHal = IUserled :: getService (); if ( mHal == nullptr ) { std :: cout << \"Failed to get cpu service \\n \" ; exit ( -1 ); } bool result = mHal -> setMode ( argv [ 1 ]); std :: cout << \"setScalingGovernor: (\" << result << \") \" << argv [ 1 ] << std :: endl ; return 0 ; } Android.bp cc_binary { name : \"LedTest\" , srcs : [ \"LedTest.cpp\" ] , defaults : [ \"hidl_defaults\" ] , vendor : true , relative_install_path : \"hw\" , shared_libs : [ \"liblog\" , \"libhardware\" , \"libhidlbase\" , \"libutils\" , \"placamae.hal.userled@1.0\" , ] , } Agora s\u00f3 resta adicionar o servi\u00e7o ao produto: meuproduto.mk ... PRODUCT_PACKAGES += \\ placamae.hal.userled \\ placamae.hal.userled-service \\ LedTest Na pasta raiz do AOSP: m Depois de terminar a build, flashei os bin\u00e1rios e esperei o Android subir para ter acesso ao ADB. Para testar o servi\u00e7o, utilizei os comandos: adb root adb shell cd /vendor/bin/hw ./LedTest heartbeat JNI Aplica\u00e7\u00e3o","title":"Blink Led HIDL"},{"location":"Boards/VIM3/Android/Hal/HIDL/#blink-led-hidl","text":"Image by Gerd Altmann from Pixabay Vale ressaltar que para esse post \u00e9 necess\u00e1rio j\u00e1 ter um produto buildado e para o ultimo t\u00f3pico \u00e9 preciso do display j\u00e1 em funcionamento.","title":"Blink Led HIDL"},{"location":"Boards/VIM3/Android/Hal/HIDL/#introducao","text":"Apesar de j\u00e1 estar depreciado, o HIDL ainda pode ser largamente encontrado no c\u00f3digo fonte do AOSP. Caso algum c\u00f3digo legado apare\u00e7a, n\u00e3o custa nada ter esse tutorial pra relembrar com \u00e9 feito um processo completo de implementa\u00e7\u00e3o da HIDL.","title":"Introdu\u00e7\u00e3o"},{"location":"Boards/VIM3/Android/Hal/HIDL/#informacoes-uteis","text":"Vers\u00e3o do AOSP: android-12.0.0_r4 Vers\u00e3o do kernel Android: android-amlogic-bmeson-5.4 Distro para compila\u00e7ao: Ubuntu 22.04.1 LTS Vers\u00e3o do kernel da distro: 5.15.0-53-generic","title":"Informa\u00e7\u00f5es \u00fateis"},{"location":"Boards/VIM3/Android/Hal/HIDL/#implementacao","text":"Tentarei seguir os mesmos t\u00f3picos do post: Implementando a HIDL .","title":"Implementa\u00e7\u00e3o"},{"location":"Boards/VIM3/Android/Hal/HIDL/#hal","text":"Na raiz da pasta do AOSP criei o seguinte caminho: mkdir -p device/casa/placamae/interfaces/userled Dentro da pasta, criei o seguinte arquivo: Android.bp hidl_package_root { name : \"placamae.hal.userled\" , path : \"device/casa/emulator/interfaces/userled\" , } Agora, criei a pasta: mkdir 1 .0 e dentro dela os seguintes arquivos: Android.bp hidl_interface { name : \"placamae.hal.userled@1.0\" , root : \"placamae.hal.userled\" , //must be a prefix of placamae.hal.userled@1.0 gen_java : true , product_specific : true , srcs : [ \"IUserLed.hal\" , ] , interfaces : [ \"android.hidl.base@1.0\" , ] , } IUserLed.hal package placamae . hal . userled @ 1.0 ; interface IUserLed { setMode ( string mode ) generates ( bool result ); }; O resultado foi esse: device/casa/placamae/interfaces/userled/ \u251c\u2500\u2500 1.0 \u2502 \u251c\u2500\u2500 Android.bp \u2502 \u2514\u2500\u2500 IUserLed.hal \u2514\u2500\u2500 Android.bp Agora \u00e9 s\u00f3 adicionar ao produto, no meu caso: meuproduto.mk ... PRODUCT_PACKAGES += \\ placamae.hal.userled@1.0 Agora vamos gerar os arquivos fonte para a HIDL. Para isso, ainda dentro da pasta 1.0 , digite: mm Ele ir\u00e1 gerar as classes necess\u00e1rias dentro da pasta : out/soong/.intermediates/device/casa/placamae/interfaces/userled/1.0/ \u251c\u2500\u2500 placamae.hal.userled@1.0 \u251c\u2500\u2500 placamae.hal.userled@1.0-adapter \u251c\u2500\u2500 placamae.hal.userled@1.0-adapter_genc++ \u251c\u2500\u2500 placamae.hal.userled@1.0-adapter-helper \u251c\u2500\u2500 placamae.hal.userled@1.0-adapter-helper_genc++ \u251c\u2500\u2500 placamae.hal.userled@1.0-adapter-helper_genc++_headers \u251c\u2500\u2500 placamae.hal.userled@1.0_genc++ \u251c\u2500\u2500 placamae.hal.userled@1.0_genc++_headers \u251c\u2500\u2500 placamae.hal.userled-V1.0-java \u251c\u2500\u2500 placamae.hal.userled-V1.0-java_gen_java \u2514\u2500\u2500 placamae.hal.userled-V1.0-java-shallow","title":"HAL"},{"location":"Boards/VIM3/Android/Hal/HIDL/#servico","text":"Criei a pasta device/casa/placamae/interfaces/userled/1.0/default/ , e dentro dela os arquivos: UserLed.h // Mesmo caminho ap\u00f3s: // placamae.hal.userled@1.0_genc++_headers/gen/placamae/hal/userled/1.0/ // dentro da pasta out/soong/.intermediates/device/casa/placamae/interfaces/userled/1.0/ #include <placamae/hal/userled/1.0/IUserled.h> namespace placamae { namespace hal { namespace userled { namespace V1_0 { namespace implementation { using :: android :: hardware :: hidl_string ; // const hidl_string using :: android :: hardware :: Return ; // Return<void> using :: android :: hardware :: Void ; // return Void(); using :: placamae :: hal :: userled :: V1_0 :: IUserled ; // public IUserled class UserLed : public IUserled { public : static inline const char RED_LED [] = \"/sys/devices/platform/leds/leds/vim3:red/trigger\" ; public : Return < bool > setMode ( const hidl_string & mode ) override ; static int writeValue ( const char * file , const char * value ); }; extern \"C\" IUserled * HIDL_FETCH_IUserled ( const char * name ); } // namespace implementation } // namespace V1_0 } // namespace userled } // namespace hal } // namespace placamae UserLed.cpp #include \"UserLed.h\" #include <log/log.h> #include <sys/stat.h> // struct stat info namespace placamae { namespace hal { namespace userled { namespace V1_0 { namespace implementation { int UserLed::writeValue ( const char * file , const char * value ) { int fd ; int str_len = strlen ( value ) + 1 ; fd = open ( file , O_WRONLY ); if ( fd < 0 ) { return -1 ; } if ( ! write ( fd , value , str_len )){ close ( fd ); return -1 ; } close ( fd ); return 0 ; } Return < bool > UserLed :: setMode ( const hidl_string & mode ) { ALOGI ( \"UserLed -> setMode data=(%s)\" , mode . c_str ()); return this -> write_value ( RED_LED , mode . c_str ()) == 0 ; } // Methods from ::android::hidl::base::V1_0::IBase follow. IUserled * HIDL_FETCH_IUserled ( const char * /* name */ ) { return new UserLed (); // Return new instance of this class } } // namespace implementation } // namespace V1_0 } // namespace userled } // namespace hal } // namespace placamae service.cpp #define LOG_TAG \"placamae.hal.userled@1.0-service\" #include <placamae/hal/userled/1.0/IUserled.h> #include <log/log.h> #include <hidl/HidlTransportSupport.h> #include \"UserLed.h\" using android :: sp ; using android :: status_t ; using android :: OK ; // libhwbinder: using android :: hardware :: configureRpcThreadpool ; using android :: hardware :: joinRpcThreadpool ; // Generated HIDL files using placamae :: hal :: userled :: V1_0 :: IUserled ; using placamae :: hal :: userled :: V1_0 :: implementation :: UserLed ; using namespace placamae ; int main ( int /* argc */ , char ** /* argv */ ) { ALOGI ( \"UserLed -> TESSSSSSTE\" ); // Android Strong Pointer (don't GC until exit) sp < IUserled > service = new UserLed (); if ( service == nullptr ) { ALOGE ( \"Can not create an instance of UserLed HAL, exiting.\" ); return 1 ; } // system/libhidl/transport/include/hidl/HidlTransportSupport.h // Configures the threadpool used for handling incoming RPC calls in this process: // @param maxThreads maximum number of threads in this process // @param callerWillJoin whether the caller will join the threadpool later. configureRpcThreadpool ( 1 , true /*callerWillJoin*/ ); // registerAsService calls registerAsServiceInternal in // system/libhidl/transport/ServiceManagement.cpp // registerAsServiceInternal registers with hwservicemanager status_t status = service -> registerAsService (); if ( status != OK ) { ALOGE ( \"Could not register service for UserLed HAL (%d), exiting.\" , status ); return 1 ; } ALOGI ( \"UserLed Service is ready\" ); // system/libhidl/transport/include/hidl/HidlTransportSupport.h // Joins a threadpool that you configured earlier joinRpcThreadpool (); // In normal operation, we don't expect the thread pool to exit ALOGE ( \"UserLed Service is shutting down\" ); return 1 ; } Android.bp cc_binary { name : \"placamae.hal.userled@1.0-service\" , init_rc : [ \"placamae.hal.userled@1.0-service.rc\" ] , srcs : [ \"service.cpp\" , \"UserLed.cpp\" ] , vintf_fragments : [ \"placamae.hal.userled@1.0-service.xml\" ] , vendor : true , relative_install_path : \"hw\" , shared_libs : [ \"libhidlbase\" , \"liblog\" , \"libutils\" , \"libhardware\" , \"placamae.hal.userled@1.0\" , ] , } placamae.hal.userled@1.0-service.rc service placamae.hal.userled-service /vendor/bin/hw/placamae.hal.userled@1.0-service interface placamae.hal.userled@1.0::IUserled default class hal user system group system on boot chown system system /sys/devices/platform/leds/leds/vim3:red/trigger chmod 0660 /sys/devices/platform/leds/leds/vim3:red/trigger placamae.hal.userled@1.0-service.xml <manifest version= \"1.0\" type= \"device\" > <hal format= \"hidl\" > <name> placamae.hal.userled </name> <transport> hwbinder </transport> <version> 1.0 </version> <interface> <name> IUserled </name> <instance> default </instance> </interface> <fqname> @1.0::IUserled/default </fqname> </hal> </manifest> O resultado foi esse: device/casa/placamae/interfaces/userled/ \u251c\u2500\u2500 1.0 \u2502 \u251c\u2500\u2500 Android.bp \u2502 \u251c\u2500\u2500 default \u2502 \u2502 \u251c\u2500\u2500 service.cpp \u2502 \u2502 \u251c\u2500\u2500 UserLed.cpp \u2502 \u2502 \u2514\u2500\u2500 UserLed.h \u2502 \u2514\u2500\u2500 IUserLed.hal \u2514\u2500\u2500 Android.bp Agora s\u00f3 resta adicionar o servi\u00e7o ao produto: meuproduto.mk ... PRODUCT_PACKAGES += \\ placamae.hal.userled@1.0 \\ placamae.hal.userled@1.0-service","title":"Servi\u00e7o"},{"location":"Boards/VIM3/Android/Hal/HIDL/#permissoes","text":"Para facilitar a implementa\u00e7\u00e3o, foi definido a permiss\u00e3o permissiva , mas ainda \u00e9 necess\u00e1rio subir o servi\u00e7o. Essa etapa \u00e9 feita via sepolicy. Para isso, criei a pasta: mkdir -p device/casa/placamae/sepolicy Dentro dela criei os arquivos: file_contexts /vendor/bin/hw/placamae\\.hal\\.userled@1\\.0-service u:object_r:hal_userled_default_exec:s0 hal_userled_default.te type hal_userled_default, domain; type hal_userled_default_exec, exec_type, vendor_file_type, file_type; init_daemon_domain(hal_userled_default); Por fim, adicionei a pasta sepolicy no: BoardConfig.mk ... BOARD_SEPOLICY_DIRS += device/casa/placamae/sepolicy","title":"Permiss\u00f5es"},{"location":"Boards/VIM3/Android/Hal/HIDL/#testando","text":"Para testar a HAL, criei a pasta: mkdir -p device/casa/placamae/interfaces/userled/1.0/default/LedTest e dentro dela os seguintes arquivos: LedTest.cpp #include <placamae/hal/userled/1.0/IUserled.h> #include <hidl/Status.h> #include <hidl/LegacySupport.h> #include <utils/misc.h> #include <hidl/HidlSupport.h> #include <iostream> #include <cstdlib> #include <string> using :: android :: sp ; using :: placamae :: hal :: userled :: V1_0 :: IUserled ; using android :: hardware :: hidl_string ; int main ( int argc , char * argv []) { iif ( argc != 2 ) { std :: cout << \"USAGE ./LedTest <none|heartbeat|default-on> \\n \" ; exit ( 0 ); } android :: sp < IUserled > mHal = IUserled :: getService (); if ( mHal == nullptr ) { std :: cout << \"Failed to get cpu service \\n \" ; exit ( -1 ); } bool result = mHal -> setMode ( argv [ 1 ]); std :: cout << \"setScalingGovernor: (\" << result << \") \" << argv [ 1 ] << std :: endl ; return 0 ; } Android.bp cc_binary { name : \"LedTest\" , srcs : [ \"LedTest.cpp\" ] , defaults : [ \"hidl_defaults\" ] , vendor : true , relative_install_path : \"hw\" , shared_libs : [ \"liblog\" , \"libhardware\" , \"libhidlbase\" , \"libutils\" , \"placamae.hal.userled@1.0\" , ] , } Agora s\u00f3 resta adicionar o servi\u00e7o ao produto: meuproduto.mk ... PRODUCT_PACKAGES += \\ placamae.hal.userled \\ placamae.hal.userled-service \\ LedTest Na pasta raiz do AOSP: m Depois de terminar a build, flashei os bin\u00e1rios e esperei o Android subir para ter acesso ao ADB. Para testar o servi\u00e7o, utilizei os comandos: adb root adb shell cd /vendor/bin/hw ./LedTest heartbeat","title":"Testando"},{"location":"Boards/VIM3/Android/Hal/HIDL/#jni","text":"","title":"JNI"},{"location":"Boards/VIM3/Android/Hal/HIDL/#aplicacao","text":"","title":"Aplica\u00e7\u00e3o"},{"location":"Boards/VIM3/Android/Kernel/blueled/","text":"Habilitando o Led Azul Image by Jacek Abramowicz from Pixabay Introdu\u00e7\u00e3o A Khadas VIM3 possui um conjunto de 3 LEDs soldados na placa, os LEDs Branco , Vermelho , Azul . Na vers\u00e3o do kernel Linux Android amlogic-bmeson-5.4 , o LED Azul n\u00e3o vem habilitado por padr\u00e3o. Nesse post vou descrever os passos que utilizei para deixar esse LED acess\u00edvel ao Android. Informa\u00e7\u00f5es \u00dateis Vers\u00e3o do AOSP: android-12.0.0_r4 Vers\u00e3o do Kernel Android: android-amlogic-bmeson-5.4 Distro de Compila\u00e7\u00e3o: Linux Mint 21 Vers\u00e3o do Kernel da distro: 5.15.0-56-generic O GPIO do LED Azul Os LEDs da placa est\u00e3o na letra I da imagem abaixo ( Fonte ): Vista de cima da VIM3 \u00c9 preciso saber qual desses LEDs \u00e9 o azul e a qual GPIO ele est\u00e1 conectado. Para isso, \u00e9 necess\u00e1rio buscar no esquem\u00e1tico da placa, que pode ser encontrado nesse link . Procurando por BLUE , podemos encontrar a porta que ativa o LED. Esquem\u00e1tico do LED azul Ele mostra que o sinal que ativa o LED azul \u00e9 o PWR_LED . Buscando no esquem\u00e1tico pelo componente que envia esse sinal, temos: Fonte do sinal PWR_LED O STM8S \u00e9 um microcontrolador de 8 bits, ele \u00e9 respons\u00e1vel por fazer o controle de outros componentes da placa. Ele \u00e9 controlado via i2c pelo endere\u00e7o 0x18 e possui alguns comando pr\u00e9-determinados para que possamos controlar os componentes que est\u00e3o associados a ele. Para mais detalhes sobre o STM8S veja Habilitando a FAN ) Habilitando o LED Para ter acesso ao STM8S eu adicionei o seguinte c\u00f3digo ao kernel Linux Android amlogic-bmeson-5.4 : arch/arm64/boot/dts/amlogic/meson-g12b-a311d-khadas-vim3.dts ... & i2c_AO { khadas - mcu { compatible = \"khadas-mcu\" ; reg = < 0x18 > ; fan , trig_temp_level0 = < 50 > ; fan , trig_temp_level1 = < 60 > ; fan , trig_temp_level2 = < 65 > ; fan , trig_temp_level3 = < 70 > ; hwver = \"VIM3.V11\" ; }; }; Com isso, \u00e9 poss\u00edvel acessar o STM8S via adb shell . Agora resta saber como ativar o LED azul. Para isso, \u00e9 necess\u00e1rio saber qual comando deve ser enviado para o STM8S . Checando a escassa documenta\u00e7\u00e3o da placa, encontrei o seguinte pdf vim3_mcu_reg_en que possui as seguintes linhas: Address Register name Byte R/W Note 0x28 LED_MODE_ON 1 R/W 0:LED Off after Power On 1:LED On after Power On 2:LED Breath after Power On 3:LED Heartbeat after Power On 0x29 LED_MODE_OFF 1 R/W 0:LED Off after Power Off 1:LED On after Power Off 2:LED Breath after Power Off 3:LED Heartbeat after Power Off Com base nessas linhas, o LED azul pode ter um comportamento quando a placa est\u00e1 ligada e outro comportamento quando a placa est\u00e1 desligada. Testando Depois de buildar o Kernel e o AOSP e flashar as imagens, utilizei o adb shell para fazer os testes. Primeiro chequei para ver se o endere\u00e7o 0x18 estava dispon\u00edvel no barramento 0 (\u00e9 necess\u00e1rio ter permiss\u00e3o de super usu\u00e1rio ): jaoboard:/ # i2cdetect -y 0 # barramento 0 do i2c 0 1 2 3 4 5 6 7 8 9 a b c d e f 00 : -- -- -- -- -- -- -- -- -- -- -- 0e -- 10 : -- -- -- -- -- -- -- -- 18 -- -- -- -- -- -- -- 20 : UU -- 22 -- -- -- -- -- -- -- -- -- -- -- -- -- 30 : -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 40 : -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 50 : -- 51 -- -- -- -- -- -- -- -- -- -- -- -- -- -- 60 : -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 70 : -- -- -- -- -- -- -- -- com o endere\u00e7o 0x18 dispon\u00edvel, usei o seguinte comando para deixar o LED azul piscando enquanto a placa estiver ligada: i2cset 0 0x18 0x28 3 w -y # Heartbeat LED Azul piscando Para mudar o comportamento do LED azul para a placa desligada, basta mudar o registrador de 0x28 para 0x29 . Por exemplo: i2cset 0 0x18 0x29 3 w -y # Heartbeat Conclus\u00e3o Agora os 3 LEDs dispon\u00edveis na Khadas VIM3 podem ser utilizados, no futuro a ideia \u00e9 criar um Device Driver para controlar o LED azul. Os outros (Branco e Vermelho) j\u00e1 pertencem a categoria de UserLed e podem ser encontrados em /sys/class/leds/ com os nomes vim3:white:sys e vim3:red . Devido isso, podem ter seu comportamento alterado de acordo com o arquivo trigger , por exemplo: jaoboard:/sys/class/leds/vim3:red $ cat trigger [ none ] rc-feedback bluetooth-power rfkill-any rfkill-none mmc0 timer oneshot disk-activity disk-read disk-write ide-disk heartbeat backlight gpio cpu cpu0 cpu1 cpu2 cpu3 cpu4 cpu5 default-on transient panic mmc2 mmc1 hci0-power rfkill0 rfkill1 rfkill2","title":"Habilitando o Led Azul"},{"location":"Boards/VIM3/Android/Kernel/blueled/#habilitando-o-led-azul","text":"Image by Jacek Abramowicz from Pixabay","title":"Habilitando o Led Azul"},{"location":"Boards/VIM3/Android/Kernel/blueled/#introducao","text":"A Khadas VIM3 possui um conjunto de 3 LEDs soldados na placa, os LEDs Branco , Vermelho , Azul . Na vers\u00e3o do kernel Linux Android amlogic-bmeson-5.4 , o LED Azul n\u00e3o vem habilitado por padr\u00e3o. Nesse post vou descrever os passos que utilizei para deixar esse LED acess\u00edvel ao Android.","title":"Introdu\u00e7\u00e3o"},{"location":"Boards/VIM3/Android/Kernel/blueled/#informacoes-uteis","text":"Vers\u00e3o do AOSP: android-12.0.0_r4 Vers\u00e3o do Kernel Android: android-amlogic-bmeson-5.4 Distro de Compila\u00e7\u00e3o: Linux Mint 21 Vers\u00e3o do Kernel da distro: 5.15.0-56-generic","title":"Informa\u00e7\u00f5es \u00dateis"},{"location":"Boards/VIM3/Android/Kernel/blueled/#o-gpio-do-led-azul","text":"Os LEDs da placa est\u00e3o na letra I da imagem abaixo ( Fonte ): Vista de cima da VIM3 \u00c9 preciso saber qual desses LEDs \u00e9 o azul e a qual GPIO ele est\u00e1 conectado. Para isso, \u00e9 necess\u00e1rio buscar no esquem\u00e1tico da placa, que pode ser encontrado nesse link . Procurando por BLUE , podemos encontrar a porta que ativa o LED. Esquem\u00e1tico do LED azul Ele mostra que o sinal que ativa o LED azul \u00e9 o PWR_LED . Buscando no esquem\u00e1tico pelo componente que envia esse sinal, temos: Fonte do sinal PWR_LED O STM8S \u00e9 um microcontrolador de 8 bits, ele \u00e9 respons\u00e1vel por fazer o controle de outros componentes da placa. Ele \u00e9 controlado via i2c pelo endere\u00e7o 0x18 e possui alguns comando pr\u00e9-determinados para que possamos controlar os componentes que est\u00e3o associados a ele. Para mais detalhes sobre o STM8S veja Habilitando a FAN )","title":"O GPIO do LED Azul"},{"location":"Boards/VIM3/Android/Kernel/blueled/#habilitando-o-led","text":"Para ter acesso ao STM8S eu adicionei o seguinte c\u00f3digo ao kernel Linux Android amlogic-bmeson-5.4 : arch/arm64/boot/dts/amlogic/meson-g12b-a311d-khadas-vim3.dts ... & i2c_AO { khadas - mcu { compatible = \"khadas-mcu\" ; reg = < 0x18 > ; fan , trig_temp_level0 = < 50 > ; fan , trig_temp_level1 = < 60 > ; fan , trig_temp_level2 = < 65 > ; fan , trig_temp_level3 = < 70 > ; hwver = \"VIM3.V11\" ; }; }; Com isso, \u00e9 poss\u00edvel acessar o STM8S via adb shell . Agora resta saber como ativar o LED azul. Para isso, \u00e9 necess\u00e1rio saber qual comando deve ser enviado para o STM8S . Checando a escassa documenta\u00e7\u00e3o da placa, encontrei o seguinte pdf vim3_mcu_reg_en que possui as seguintes linhas: Address Register name Byte R/W Note 0x28 LED_MODE_ON 1 R/W 0:LED Off after Power On 1:LED On after Power On 2:LED Breath after Power On 3:LED Heartbeat after Power On 0x29 LED_MODE_OFF 1 R/W 0:LED Off after Power Off 1:LED On after Power Off 2:LED Breath after Power Off 3:LED Heartbeat after Power Off Com base nessas linhas, o LED azul pode ter um comportamento quando a placa est\u00e1 ligada e outro comportamento quando a placa est\u00e1 desligada.","title":"Habilitando o LED"},{"location":"Boards/VIM3/Android/Kernel/blueled/#testando","text":"Depois de buildar o Kernel e o AOSP e flashar as imagens, utilizei o adb shell para fazer os testes. Primeiro chequei para ver se o endere\u00e7o 0x18 estava dispon\u00edvel no barramento 0 (\u00e9 necess\u00e1rio ter permiss\u00e3o de super usu\u00e1rio ): jaoboard:/ # i2cdetect -y 0 # barramento 0 do i2c 0 1 2 3 4 5 6 7 8 9 a b c d e f 00 : -- -- -- -- -- -- -- -- -- -- -- 0e -- 10 : -- -- -- -- -- -- -- -- 18 -- -- -- -- -- -- -- 20 : UU -- 22 -- -- -- -- -- -- -- -- -- -- -- -- -- 30 : -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 40 : -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 50 : -- 51 -- -- -- -- -- -- -- -- -- -- -- -- -- -- 60 : -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 70 : -- -- -- -- -- -- -- -- com o endere\u00e7o 0x18 dispon\u00edvel, usei o seguinte comando para deixar o LED azul piscando enquanto a placa estiver ligada: i2cset 0 0x18 0x28 3 w -y # Heartbeat LED Azul piscando Para mudar o comportamento do LED azul para a placa desligada, basta mudar o registrador de 0x28 para 0x29 . Por exemplo: i2cset 0 0x18 0x29 3 w -y # Heartbeat","title":"Testando"},{"location":"Boards/VIM3/Android/Kernel/blueled/#conclusao","text":"Agora os 3 LEDs dispon\u00edveis na Khadas VIM3 podem ser utilizados, no futuro a ideia \u00e9 criar um Device Driver para controlar o LED azul. Os outros (Branco e Vermelho) j\u00e1 pertencem a categoria de UserLed e podem ser encontrados em /sys/class/leds/ com os nomes vim3:white:sys e vim3:red . Devido isso, podem ter seu comportamento alterado de acordo com o arquivo trigger , por exemplo: jaoboard:/sys/class/leds/vim3:red $ cat trigger [ none ] rc-feedback bluetooth-power rfkill-any rfkill-none mmc0 timer oneshot disk-activity disk-read disk-write ide-disk heartbeat backlight gpio cpu cpu0 cpu1 cpu2 cpu3 cpu4 cpu5 default-on transient panic mmc2 mmc1 hci0-power rfkill0 rfkill1 rfkill2","title":"Conclus\u00e3o"},{"location":"Boards/VIM3/Android/Kernel/fan/","text":"Habilitando a FAN Image by Clker-Free-Vector-Images from Pixabay Introdu\u00e7\u00e3o A Khadas VIM3 possui alguns acess\u00f3rios, dentre eles a ventoinha . N\u00e3o tenho certeza se ela j\u00e1 vem habilitada com o sistema que vem por padr\u00e3o na placa ( Android Pie (9) ), mas na vers\u00e3o do kernel Linux que eles mant\u00e9m, a ventoinha j\u00e1 est\u00e1 adicionada. Infelizmente na vers\u00e3o do kernel Linux Android que estou utilizando nesse momento, a ventoinha ainda n\u00e3o foi adicionada. Dessa forma, nesse post vou descrever os passos que segui para conseguir utilizar a mesma. Informa\u00e7\u00f5es \u00dateis Vers\u00e3o do AOSP: android-12.0.0_r4 Vers\u00e3o do Kernel Android: android-amlogic-bmeson-5.4 Distro de Compila\u00e7\u00e3o: Linux Mint 21 Vers\u00e3o do Kernel da distro: 5.15.0-56-generic A porta da FAN O conector da FAN est\u00e1 no n\u00famero 6 da imagem abaixo ( Fonte ): Vista de cima da VIM3 Agora \u00e9 preciso saber onde estas portas est\u00e3o conectadas internamente. Para isso, \u00e9 necess\u00e1rio buscar no esquem\u00e1tico da placa, que pode ser encontrado nesse link . Procurando por FAN , podemos encontrar a porta mencionada anteriormente no esquem\u00e1tico. Esquem\u00e1tico do conector da FAN Com isso, \u00e9 poss\u00edvel observar que existem os seguintes sinais: VCC , GND e FAN_PWM . Dessa forma, o pino de controle da ventoinha \u00e9 o FAN_PWM , \u00e9 preciso saber de onde este sinal est\u00e1 vindo. Para isso, basta buscar no esquem\u00e1tico por FAN_PWM e o componente abaixo ser\u00e1 encontrado. Fonte do sinal FAN_PWM O STM8S \u00e9 um microcontrolador de 8 bits, ele \u00e9 respons\u00e1vel por fazer o controle da ventoinha (pino 17). Ainda no esquem\u00e1tico, \u00e9 poss\u00edvel observar que esse microcontrolador \u00e9 controlado por i2c (pinos 8 e 9) sendo estes do pr\u00f3prio SOC . O esquem\u00e1tico n\u00e3o fornece o endere\u00e7o, para controlar esse microcontrolador, ou seja, n\u00e3o temos como ter acesso a esse componente. O Endere\u00e7o do STM8S Como a FAN est\u00e1 adicionado ao Kernel Linux mantido pela Khadas, ent\u00e3o a informa\u00e7\u00e3o do endere\u00e7o do microcontrolador est\u00e1 em algum lugar do c\u00f3digo ( mas onde ? ). Ainda observando as portas do STM8S no esquem\u00e1tico, \u00e9 poss\u00edvel perceber algumas men\u00e7\u00f5es de MCU (sigla para MicroController Unit ). A partir disso, \u00e9 muito prov\u00e1vel que qualquer endere\u00e7o de i2c esteja em algum Device Tree Source (DTS) dentro do Kernel Linux da Khadas . Os DTS da VIM3 est\u00e3o em arch/arm64/boot/dts/amlogic/ e nesse caminho busquei por MCU e retornaram os seguintes arquivos: \u256d\u2500 ~/Doc/b/V/2/linux-vim3/a/arm6/b/d/amlogic on khadas-vim3-p-64bit \u2570\u2500\u276f grep -r mcu \u2500\u256f tm2_t962x3_t312.dts: /*mcu irq pin*/ tm2_t962x3_t312.dts: mcu_irq_pin = < & gpio GPIOH_9 GPIO_ACTIVE_HIGH> ; kvim3.dts: khadas-mcu { kvim3.dts: compatible = \"khadas-mcu\" ; axg_s400_v03sbr.dts: mcu6350: mcu6350@40 { axg_s400_v03gva_sbr.dts: mcu6350: mcu6350@40 { kvim3.dts11: khadas-mcu { kvim3.dts11: compatible = \"khadas-mcu\" ; kvim3.dtsbak: khadas-mcu { kvim3.dtsbak: compatible = \"khadas-mcu\" ; kvim3.dtspdm: khadas-mcu { kvim3.dtspdm: compatible = \"khadas-mcu\" ; kvim3.dts_dai: khadas-mcu { kvim3.dts_dai: compatible = \"khadas-mcu\" ; kvim3l.dts: khadas-mcu { kvim3l.dts: compatible = \"khadas-mcu\" ; A branch que eu utilizei foi a khadas-vim3-p-64bit O arquivo kvim3.dts pareceu promissor, checando a linha retornada anteriormente: kvim3.dts & i2c_AO { status = \"okay\" ; pinctrl-names = \"default\" ; pinctrl-0 =<& ao_i2c_master_pins1 > ; clock-frequency = < 100000 > ; /* default 100k */ khadas-mcu { compatible = \"khadas-mcu\" ; reg = < 0x18 > ; fan , trig_temp_level0 = < 50 > ; fan , trig_temp_level1 = < 60 > ; fan , trig_temp_level2 = < 65 > ; fan , trig_temp_level3 = < 70 > ; hwver = \"VIM3.V11\" ; }; ... }; Um node chamado khadas-mcu dentro do node i2c_AO (o mesmo que controla o STM8S). Ainda \u00e9 poss\u00edvel observar que o endere\u00e7o utilizado \u00e9 o 0x18 ( reg = <0x18>; ). Agora resta testar. Testando no Kernel Android Para testar, adicionei o seguinte conte\u00fado no final do arquivo: arch/arm64/boot/dts/amlogic/meson-g12b-a311d-khadas-vim3.dts ... & i2c_AO { khadas - mcu { compatible = \"khadas-mcu\" ; reg = < 0x18 > ; fan , trig_temp_level0 = < 50 > ; fan , trig_temp_level1 = < 60 > ; fan , trig_temp_level2 = < 65 > ; fan , trig_temp_level3 = < 70 > ; hwver = \"VIM3.V11\" ; }; }; Dessa forma, \u00e9 poss\u00edvel ter acesso ao componente que tenha o endere\u00e7o 0x18 (ainda n\u00e3o \u00e9 certeza que seja o STM8S ). Buildando o Kernel com essas altera\u00e7\u00f5es e adicionando ao AOSP, so resta flashar o boot.img e checar se o endere\u00e7o 0x18 est\u00e1 dispon\u00edvel. Para isso, \u00e9 poss\u00edvel utilizar o comando i2cdetect , por meio do adb shell . O retorno do comando foi o seguinte: \u2570\u2500\u276f adb shell jaoboard:/ # i2cdetect -y 0 0 1 2 3 4 5 6 7 8 9 a b c d e f 00 : -- -- -- -- -- -- -- -- -- -- -- 0e -- 10 : -- -- -- -- -- -- -- -- 18 -- -- -- -- -- -- -- 20 : UU -- 22 -- -- -- -- -- -- -- -- -- -- -- -- -- 30 : -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 40 : -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 50 : -- 51 -- -- -- -- -- -- -- -- -- -- -- -- -- -- 60 : -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 70 : -- -- -- -- -- -- -- -- Tudo caminhando bem, endere\u00e7o 0x18 habilitado. Entretanto, existe um problema, mesmo que o endere\u00e7o seja o do STM8S , ele \u00e9 apenas uma interface para controlar a FAN. Dessa forma, existe um firmware gravado nele (na qual n\u00e3o temos acesso) que dado uma entrada ele executa uma sa\u00edda. Checando a escassa documenta\u00e7\u00e3o da placa, encontrei o seguinte pdf vim3_mcu_reg_en que n\u00e3o faz nenhuma men\u00e7\u00e3o ao STM8S , mas possui a seguinte linha: Address Register Name Byte R/W Note 0x88 CMD_FAN_STATUS_CTRL 0 W 0\uff1aDisable Fan 1\uff1aFan Speed Level 1 2\uff1aFan Speed Level 2 3\uff1aFan Speed Level 3 Fiz o seguinte teste no shell do Android: jaoboard:/ # i2cset 0 0x18 0x88 1 w Write register 0x88 from chip 0x18 on bus 0 ? ( Y/n ) : e Voil\u00e0 a ventoinha come\u00e7ou a girar. Ventoinha funcionando Conclus\u00e3o Sem d\u00favidas, a falta de documenta\u00e7\u00e3o para as placas em geral \u00e9 um grande problema e isso dificulta o Bring up das mesmas. Se n\u00e3o tiver uma equipe interna para fazer as implementa\u00e7\u00f5es, \u00e9 praticamente imposs\u00edvel fazer alguma coisa funcionar. Como foi poss\u00edvel perceber nesse post , se n\u00e3o fosse algu\u00e9m da pr\u00f3pria khadas para gerar o DTS com o endere\u00e7o, a ventoinha seria inacess\u00edvel, uma vez que existe uma interface para controla-la. Mas no fim, deu tudo certo e seguimos na luta para aprender sobre embarcados :).","title":"Habilitando a FAN"},{"location":"Boards/VIM3/Android/Kernel/fan/#habilitando-a-fan","text":"Image by Clker-Free-Vector-Images from Pixabay","title":"Habilitando a FAN"},{"location":"Boards/VIM3/Android/Kernel/fan/#introducao","text":"A Khadas VIM3 possui alguns acess\u00f3rios, dentre eles a ventoinha . N\u00e3o tenho certeza se ela j\u00e1 vem habilitada com o sistema que vem por padr\u00e3o na placa ( Android Pie (9) ), mas na vers\u00e3o do kernel Linux que eles mant\u00e9m, a ventoinha j\u00e1 est\u00e1 adicionada. Infelizmente na vers\u00e3o do kernel Linux Android que estou utilizando nesse momento, a ventoinha ainda n\u00e3o foi adicionada. Dessa forma, nesse post vou descrever os passos que segui para conseguir utilizar a mesma.","title":"Introdu\u00e7\u00e3o"},{"location":"Boards/VIM3/Android/Kernel/fan/#informacoes-uteis","text":"Vers\u00e3o do AOSP: android-12.0.0_r4 Vers\u00e3o do Kernel Android: android-amlogic-bmeson-5.4 Distro de Compila\u00e7\u00e3o: Linux Mint 21 Vers\u00e3o do Kernel da distro: 5.15.0-56-generic","title":"Informa\u00e7\u00f5es \u00dateis"},{"location":"Boards/VIM3/Android/Kernel/fan/#a-porta-da-fan","text":"O conector da FAN est\u00e1 no n\u00famero 6 da imagem abaixo ( Fonte ): Vista de cima da VIM3 Agora \u00e9 preciso saber onde estas portas est\u00e3o conectadas internamente. Para isso, \u00e9 necess\u00e1rio buscar no esquem\u00e1tico da placa, que pode ser encontrado nesse link . Procurando por FAN , podemos encontrar a porta mencionada anteriormente no esquem\u00e1tico. Esquem\u00e1tico do conector da FAN Com isso, \u00e9 poss\u00edvel observar que existem os seguintes sinais: VCC , GND e FAN_PWM . Dessa forma, o pino de controle da ventoinha \u00e9 o FAN_PWM , \u00e9 preciso saber de onde este sinal est\u00e1 vindo. Para isso, basta buscar no esquem\u00e1tico por FAN_PWM e o componente abaixo ser\u00e1 encontrado. Fonte do sinal FAN_PWM O STM8S \u00e9 um microcontrolador de 8 bits, ele \u00e9 respons\u00e1vel por fazer o controle da ventoinha (pino 17). Ainda no esquem\u00e1tico, \u00e9 poss\u00edvel observar que esse microcontrolador \u00e9 controlado por i2c (pinos 8 e 9) sendo estes do pr\u00f3prio SOC . O esquem\u00e1tico n\u00e3o fornece o endere\u00e7o, para controlar esse microcontrolador, ou seja, n\u00e3o temos como ter acesso a esse componente.","title":"A porta da FAN"},{"location":"Boards/VIM3/Android/Kernel/fan/#o-endereco-do-stm8s","text":"Como a FAN est\u00e1 adicionado ao Kernel Linux mantido pela Khadas, ent\u00e3o a informa\u00e7\u00e3o do endere\u00e7o do microcontrolador est\u00e1 em algum lugar do c\u00f3digo ( mas onde ? ). Ainda observando as portas do STM8S no esquem\u00e1tico, \u00e9 poss\u00edvel perceber algumas men\u00e7\u00f5es de MCU (sigla para MicroController Unit ). A partir disso, \u00e9 muito prov\u00e1vel que qualquer endere\u00e7o de i2c esteja em algum Device Tree Source (DTS) dentro do Kernel Linux da Khadas . Os DTS da VIM3 est\u00e3o em arch/arm64/boot/dts/amlogic/ e nesse caminho busquei por MCU e retornaram os seguintes arquivos: \u256d\u2500 ~/Doc/b/V/2/linux-vim3/a/arm6/b/d/amlogic on khadas-vim3-p-64bit \u2570\u2500\u276f grep -r mcu \u2500\u256f tm2_t962x3_t312.dts: /*mcu irq pin*/ tm2_t962x3_t312.dts: mcu_irq_pin = < & gpio GPIOH_9 GPIO_ACTIVE_HIGH> ; kvim3.dts: khadas-mcu { kvim3.dts: compatible = \"khadas-mcu\" ; axg_s400_v03sbr.dts: mcu6350: mcu6350@40 { axg_s400_v03gva_sbr.dts: mcu6350: mcu6350@40 { kvim3.dts11: khadas-mcu { kvim3.dts11: compatible = \"khadas-mcu\" ; kvim3.dtsbak: khadas-mcu { kvim3.dtsbak: compatible = \"khadas-mcu\" ; kvim3.dtspdm: khadas-mcu { kvim3.dtspdm: compatible = \"khadas-mcu\" ; kvim3.dts_dai: khadas-mcu { kvim3.dts_dai: compatible = \"khadas-mcu\" ; kvim3l.dts: khadas-mcu { kvim3l.dts: compatible = \"khadas-mcu\" ; A branch que eu utilizei foi a khadas-vim3-p-64bit O arquivo kvim3.dts pareceu promissor, checando a linha retornada anteriormente: kvim3.dts & i2c_AO { status = \"okay\" ; pinctrl-names = \"default\" ; pinctrl-0 =<& ao_i2c_master_pins1 > ; clock-frequency = < 100000 > ; /* default 100k */ khadas-mcu { compatible = \"khadas-mcu\" ; reg = < 0x18 > ; fan , trig_temp_level0 = < 50 > ; fan , trig_temp_level1 = < 60 > ; fan , trig_temp_level2 = < 65 > ; fan , trig_temp_level3 = < 70 > ; hwver = \"VIM3.V11\" ; }; ... }; Um node chamado khadas-mcu dentro do node i2c_AO (o mesmo que controla o STM8S). Ainda \u00e9 poss\u00edvel observar que o endere\u00e7o utilizado \u00e9 o 0x18 ( reg = <0x18>; ). Agora resta testar.","title":"O Endere\u00e7o do STM8S"},{"location":"Boards/VIM3/Android/Kernel/fan/#testando-no-kernel-android","text":"Para testar, adicionei o seguinte conte\u00fado no final do arquivo: arch/arm64/boot/dts/amlogic/meson-g12b-a311d-khadas-vim3.dts ... & i2c_AO { khadas - mcu { compatible = \"khadas-mcu\" ; reg = < 0x18 > ; fan , trig_temp_level0 = < 50 > ; fan , trig_temp_level1 = < 60 > ; fan , trig_temp_level2 = < 65 > ; fan , trig_temp_level3 = < 70 > ; hwver = \"VIM3.V11\" ; }; }; Dessa forma, \u00e9 poss\u00edvel ter acesso ao componente que tenha o endere\u00e7o 0x18 (ainda n\u00e3o \u00e9 certeza que seja o STM8S ). Buildando o Kernel com essas altera\u00e7\u00f5es e adicionando ao AOSP, so resta flashar o boot.img e checar se o endere\u00e7o 0x18 est\u00e1 dispon\u00edvel. Para isso, \u00e9 poss\u00edvel utilizar o comando i2cdetect , por meio do adb shell . O retorno do comando foi o seguinte: \u2570\u2500\u276f adb shell jaoboard:/ # i2cdetect -y 0 0 1 2 3 4 5 6 7 8 9 a b c d e f 00 : -- -- -- -- -- -- -- -- -- -- -- 0e -- 10 : -- -- -- -- -- -- -- -- 18 -- -- -- -- -- -- -- 20 : UU -- 22 -- -- -- -- -- -- -- -- -- -- -- -- -- 30 : -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 40 : -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 50 : -- 51 -- -- -- -- -- -- -- -- -- -- -- -- -- -- 60 : -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 70 : -- -- -- -- -- -- -- -- Tudo caminhando bem, endere\u00e7o 0x18 habilitado. Entretanto, existe um problema, mesmo que o endere\u00e7o seja o do STM8S , ele \u00e9 apenas uma interface para controlar a FAN. Dessa forma, existe um firmware gravado nele (na qual n\u00e3o temos acesso) que dado uma entrada ele executa uma sa\u00edda. Checando a escassa documenta\u00e7\u00e3o da placa, encontrei o seguinte pdf vim3_mcu_reg_en que n\u00e3o faz nenhuma men\u00e7\u00e3o ao STM8S , mas possui a seguinte linha: Address Register Name Byte R/W Note 0x88 CMD_FAN_STATUS_CTRL 0 W 0\uff1aDisable Fan 1\uff1aFan Speed Level 1 2\uff1aFan Speed Level 2 3\uff1aFan Speed Level 3 Fiz o seguinte teste no shell do Android: jaoboard:/ # i2cset 0 0x18 0x88 1 w Write register 0x88 from chip 0x18 on bus 0 ? ( Y/n ) : e Voil\u00e0 a ventoinha come\u00e7ou a girar. Ventoinha funcionando","title":"Testando no Kernel Android"},{"location":"Boards/VIM3/Android/Kernel/fan/#conclusao","text":"Sem d\u00favidas, a falta de documenta\u00e7\u00e3o para as placas em geral \u00e9 um grande problema e isso dificulta o Bring up das mesmas. Se n\u00e3o tiver uma equipe interna para fazer as implementa\u00e7\u00f5es, \u00e9 praticamente imposs\u00edvel fazer alguma coisa funcionar. Como foi poss\u00edvel perceber nesse post , se n\u00e3o fosse algu\u00e9m da pr\u00f3pria khadas para gerar o DTS com o endere\u00e7o, a ventoinha seria inacess\u00edvel, uma vez que existe uma interface para controla-la. Mas no fim, deu tudo certo e seguimos na luta para aprender sobre embarcados :).","title":"Conclus\u00e3o"},{"location":"Boards/VIM3/Bootloader/u-boot/","text":"U-boot na VIM3 (SD Card) U-boot logo baseado no tutorial do pr\u00f3prio u-boot no readthedocs Organizando a estrutura de pastas Ser\u00e3o necess\u00e1rios v\u00e1rios arquivos e pastas durante esse post. Devido isso, iremos usar a seguinte estrutura de pastas . \u251c\u2500\u2500 fip \u251c\u2500\u2500 toolchain \u251c\u2500\u2500 u-boot-mainline \u2514\u2500\u2500 u-boot-vim3 Elas ser\u00e3o criadas ao longo deste post. Baixando o u-boot Mainline O u-boot possui um reposit\u00f3rio no github. Vamos baixa-lo dentro da pasta u-boot-mainline : git clone https://github.com/u-boot/u-boot.git u-boot-mainline Para fazer o cross compile \u00e9 necess\u00e1rio baixar as toolchain . As vers\u00f5es novas do u-boot precisam de vers\u00f5es novas de toolchain , que podem ser encontradas no site da ARM . Nesse post estou usando a vers\u00e3o gcc-arm-10.3-2021.07 (meu link de backup). Compilando o u-boot mainline Uma vez baixado a toolchain ( gcc-arm-10.3-2021.07 ), vamos criar a pasta toolchain e mover a toolchain baixada para dentro dela. Agora, precisamos descompactar a toochain e adicionar os bin\u00e1rios ao path do sistema. Para isso export PATH=CAMINHO_ABSOLUTO/toolchain/gcc-arm-10.3-2021.07-x86_64-aarch64-none-elf/bin:$PATH Observe que a pasta /bin est\u00e1 sendo adicionada ao path . Nela est\u00e3o os execut\u00e1veis que ser\u00e3o utilizados durante o processo de build. Volte para a pasta do u-boot-mainline e execute os seguintes comandos: make khadas-vim3_defconfig O = out/ make CROSS_COMPILE = aarch64-none-elf- O = out/ O par\u00e2metro O define a pasta onde os arquivos compilados ser\u00e3o salvos. O argumento CROSS_COMPILE=aarch64-none-elf- informa qual toolchain ser\u00e1 utilizada no momento da compila\u00e7\u00e3o, essa toolchain precisa estar no path do sistema (como fizemos anteriormente). Dentro os v\u00e1rios compiladores dispon\u00edveis, podemos ver que existem alguns bem conhecidos: c++ , cpp , g++ e muitos outros. toolchain/gcc-arm-10.3-2021.07-x86_64-aarch64-none-elf/bin \u251c\u2500\u2500 aarch64-none-elf-addr2line \u251c\u2500\u2500 aarch64-none-elf-ar \u251c\u2500\u2500 aarch64-none-elf-as \u251c\u2500\u2500 aarch64-none-elf-c++ \u251c\u2500\u2500 aarch64-none-elf-c++filt \u251c\u2500\u2500 aarch64-none-elf-cpp \u251c\u2500\u2500 aarch64-none-elf-elfedit \u251c\u2500\u2500 aarch64-none-elf-g++ ... Se tudo ocorrer como o esperado, uma mensagem similar a essa: aarch64-none-elf-ld.bfd: warning: -z norelro ignored OBJCOPY lib/efi_loader/initrddump.efi LD u-boot OBJCOPY u-boot.srec OBJCOPY u-boot-nodtb.bin RELOC u-boot-nodtb.bin CAT u-boot-dtb.bin COPY u-boot.bin SYM u-boot.sym LD u-boot.elf make[1]: Leaving directory 'CAMINHO_ABSOLUTO/u-boot-mainline/out' O arquivo u-boot.bin deve ter sido gerado dentro da pasta out . Baixando u-boot VIM3 A Khadas tamb\u00e9m possui um reposit\u00f3rio com as vers\u00f5es do u-boot para as diversas placas que eles produzem. Vamos baixar o brach khadas-vims-v2015.01 dentro da pasta u-boot-vim3 git clone https://github.com/khadas/u-boot.git -b khadas-vims-v2015.01 u-boot-vim3 Para fazer o cross compile \u00e9 necess\u00e1rio baixar as toolchain . Seguindo o tutorial base , precisaremos de 2 toolchain ( none-elf e none-eabi ): gcc-linaro-aarch64-none-elf-4.8-2013.11 - Linaro gcc-linaro-aarch64-none-elf-4.8-2013.11 (backup). gcc-linaro-arm-none-eabi-4.8-2013.11 - Linaro gcc-linaro-arm-none-eabi-4.8-2013.11 (backup). Compilando o u-boot VIM3 Antes de adicionar as novas toolchain ao path , limpe o terminal (abra um novo terminal). A vers\u00e3o utilizada no u-boot-mainline n\u00e3o \u00e9 compat\u00edvel com a vers\u00e3o da VIM3 Com as 2 toolchain baixadas, mova-as para a pastas toolchain e descompacte cada uma em sua respectiva pasta. Por fim, adicionar os bin\u00e1rios dos 2 toolchain ao path do sistema export PATH=CAMINHO_ABSOLUTO/toolchain/gcc-linaro-aarch64-none-elf-4.8-2013.11_linux/bin:$PATH export PATH=CAMINHO_ABSOLUTO/toolchain/gcc-linaro-arm-none-eabi-4.8-2013.11_linux/bin:$PATH Com os caminhos adicionados, podemos compilar o u-boot-vim3: make kvim3_defconfig O = out/ make CROSS_COMPILE = aarch64-none-elf- O = out/ O par\u00e2metro O define a pasta onde os arquivos compilados ser\u00e3o salvos. Se tudo ocorrer bem, uma mensagem similar deve aparecer: LD CAMINHO_ABSOLUTO/u-boot-vim3/out/board/khadas/kvim3/firmware/acs.elf OD CAMINHO_ABSOLUTO/u-boot-vim3/out/board/khadas/kvim3/firmware/acs.dump BIN CAMINHO_ABSOLUTO/u-boot-vim3/out/board/khadas/kvim3/firmware/acs.bin Built CAMINHO_ABSOLUTO/u-boot-vim3/out/board/khadas/kvim3/firmware/acs.bin successfully CPP task_entry.s CPP user_task.lds CC task_entry.o CC user_task.o CPP misc.s CC misc.o CC uart.o CC suspend.o CC lib/string.o CC lib/delay.o LD CAMINHO_ABSOLUTO/u-boot-vim3/out/scp_task/bl301.out OBJDUMP CAMINHO_ABSOLUTO/u-boot-vim3/out/scp_task/bl301.dis OBJCOPY CAMINHO_ABSOLUTO/u-boot-vim3/out/scp_task/bl301.bin Juntando tudo O primeiro passo \u00e9 criar a pasta fip . Segundo, \u00e9 preciso baixar esse script da BayLibre ou no meu backup e mover para dentro da pasta fip Para mais informa\u00e7\u00f5es sobre o que \u00e9, acesse: FIP + compilados Terceiro, \u00e9 preciso copiar v\u00e1rios arquivos para dentro da pasta fip : # Arquivos compilados no u-boot-VIM3 cp u-boot-vim3/out/scp_task/bl301.bin fip cp u-boot-vim3/out/board/khadas/kvim3/firmware/acs.bin fip # Copia o u-boot.bin (mainline) e renomeia para bl33.bin cp u-boot-mainline/out/u-boot.bin fip/bl33.bin # Arquivos pr\u00e9-compilados (s\u00e3o fornecidos pela khadas) cp u-boot-vim3/fip/g12b/bl2.bin fip cp u-boot-vim3/fip/g12b/bl30.bin fip cp u-boot-vim3/fip/g12b/bl31.bin fip cp u-boot-vim3/fip/g12b/ddr3_1d.fw fip cp u-boot-vim3/fip/g12b/ddr4_1d.fw fip cp u-boot-vim3/fip/g12b/ddr4_2d.fw fip cp u-boot-vim3/fip/g12b/diag_lpddr4.fw fip cp u-boot-vim3/fip/g12b/lpddr3_1d.fw fip cp u-boot-vim3/fip/g12b/lpddr4_1d.fw fip cp u-boot-vim3/fip/g12b/lpddr4_2d.fw fip cp u-boot-vim3/fip/g12b/piei.fw fip cp u-boot-vim3/fip/g12b/aml_ddr.fw fip cp u-boot-vim3/fip/g12b/aml_encrypt_g12b fip Concatenando os arquivos Pra concatenar as informa\u00e7\u00f5es, vamos utilizar o script da baylibre (dentro da pasta fip ) # Adiciona um padding no bl30.bin e bl301.bin # depois concatena os dois, gerando bl30_new.bin bash blx_fix_g12a.sh bl30.bin zero_tmp bl30_zero.bin bl301.bin bl301_zero.bin bl30_new.bin bl30 # Adiciona um padding no bl2.bin e acs.bin # depois concatena os dois, gerando bl2_new.bin bash blx_fix_g12a.sh bl2.bin zero_tmp bl2_zero.bin acs.bin bl21_zero.bin bl2_new.bin bl2 Encriptando os arquivos Para mais informa\u00e7\u00f5es, acesse: link # Adiciona assinatura no cabe\u00e7alho do bin\u00e1rio ./aml_encrypt_g12b --bl2sig --input bl2_new.bin --output bl2.n.bin.sig # Adiciona assinatura no cabe\u00e7alho do bin\u00e1rio ./aml_encrypt_g12b --bl3sig --input bl31.bin --output bl31.img.enc --level v3 --type bl3 # Adiciona e encripta a assinatura no cabe\u00e7alho do bin\u00e1rio ./aml_encrypt_g12b --bl30sig --input bl30_new.bin --output bl30_new.bin.g12a.enc --level v3 ./aml_encrypt_g12b --bl3sig --input bl30_new.bin.g12a.enc --output bl30_new.bin.enc --level v3 --type bl301 # Adiciona a assinatura no cabe\u00e7alho, um padding no final do bin\u00e1rio e comprime o bin\u00e1rio ./aml_encrypt_g12b --bl3sig --input bl33.bin --compress lz4 --output bl33.bin.enc --level v3 --type bl33 --compress lz4 # Gera o bin\u00e1rio do u-boot com as assinaturas concatenadas ./aml_encrypt_g12b --bootmk --output u-boot-bin --bl2 bl2.n.bin.sig --bl30 bl30_new.bin.enc --bl31 bl31.img.enc \\ --bl33 bl33.bin.enc --ddrfw1 ddr4_1d.fw --ddrfw2 ddr4_2d.fw \\ --ddrfw3 ddr3_1d.fw --ddrfw4 piei.fw --ddrfw5 lpddr4_1d.fw \\ --ddrfw6 lpddr4_2d.fw --ddrfw7 diag_lpddr4.fw --ddrfw8 aml_ddr.fw \\ --ddrfw9 lpddr3_1d.fw --level v3 Passando o u-boot para o SD Card $ DEV=/dev/your_sd_device $ dd if=fip/u-boot.bin.sd.bin of=$DEV conv=fsync,notrunc bs=512 skip=1 seek=1 $ dd if=fip/u-boot.bin.sd.bin of=$DEV conv=fsync,notrunc bs=1 count=444","title":"U-boot na VIM3 (SD Card)"},{"location":"Boards/VIM3/Bootloader/u-boot/#u-boot-na-vim3-sd-card","text":"U-boot logo baseado no tutorial do pr\u00f3prio u-boot no readthedocs","title":"U-boot na VIM3 (SD Card)"},{"location":"Boards/VIM3/Bootloader/u-boot/#organizando-a-estrutura-de-pastas","text":"Ser\u00e3o necess\u00e1rios v\u00e1rios arquivos e pastas durante esse post. Devido isso, iremos usar a seguinte estrutura de pastas . \u251c\u2500\u2500 fip \u251c\u2500\u2500 toolchain \u251c\u2500\u2500 u-boot-mainline \u2514\u2500\u2500 u-boot-vim3 Elas ser\u00e3o criadas ao longo deste post.","title":"Organizando a estrutura de pastas"},{"location":"Boards/VIM3/Bootloader/u-boot/#baixando-o-u-boot-mainline","text":"O u-boot possui um reposit\u00f3rio no github. Vamos baixa-lo dentro da pasta u-boot-mainline : git clone https://github.com/u-boot/u-boot.git u-boot-mainline Para fazer o cross compile \u00e9 necess\u00e1rio baixar as toolchain . As vers\u00f5es novas do u-boot precisam de vers\u00f5es novas de toolchain , que podem ser encontradas no site da ARM . Nesse post estou usando a vers\u00e3o gcc-arm-10.3-2021.07 (meu link de backup).","title":"Baixando o u-boot Mainline"},{"location":"Boards/VIM3/Bootloader/u-boot/#compilando-o-u-boot-mainline","text":"Uma vez baixado a toolchain ( gcc-arm-10.3-2021.07 ), vamos criar a pasta toolchain e mover a toolchain baixada para dentro dela. Agora, precisamos descompactar a toochain e adicionar os bin\u00e1rios ao path do sistema. Para isso export PATH=CAMINHO_ABSOLUTO/toolchain/gcc-arm-10.3-2021.07-x86_64-aarch64-none-elf/bin:$PATH Observe que a pasta /bin est\u00e1 sendo adicionada ao path . Nela est\u00e3o os execut\u00e1veis que ser\u00e3o utilizados durante o processo de build. Volte para a pasta do u-boot-mainline e execute os seguintes comandos: make khadas-vim3_defconfig O = out/ make CROSS_COMPILE = aarch64-none-elf- O = out/ O par\u00e2metro O define a pasta onde os arquivos compilados ser\u00e3o salvos. O argumento CROSS_COMPILE=aarch64-none-elf- informa qual toolchain ser\u00e1 utilizada no momento da compila\u00e7\u00e3o, essa toolchain precisa estar no path do sistema (como fizemos anteriormente). Dentro os v\u00e1rios compiladores dispon\u00edveis, podemos ver que existem alguns bem conhecidos: c++ , cpp , g++ e muitos outros. toolchain/gcc-arm-10.3-2021.07-x86_64-aarch64-none-elf/bin \u251c\u2500\u2500 aarch64-none-elf-addr2line \u251c\u2500\u2500 aarch64-none-elf-ar \u251c\u2500\u2500 aarch64-none-elf-as \u251c\u2500\u2500 aarch64-none-elf-c++ \u251c\u2500\u2500 aarch64-none-elf-c++filt \u251c\u2500\u2500 aarch64-none-elf-cpp \u251c\u2500\u2500 aarch64-none-elf-elfedit \u251c\u2500\u2500 aarch64-none-elf-g++ ... Se tudo ocorrer como o esperado, uma mensagem similar a essa: aarch64-none-elf-ld.bfd: warning: -z norelro ignored OBJCOPY lib/efi_loader/initrddump.efi LD u-boot OBJCOPY u-boot.srec OBJCOPY u-boot-nodtb.bin RELOC u-boot-nodtb.bin CAT u-boot-dtb.bin COPY u-boot.bin SYM u-boot.sym LD u-boot.elf make[1]: Leaving directory 'CAMINHO_ABSOLUTO/u-boot-mainline/out' O arquivo u-boot.bin deve ter sido gerado dentro da pasta out .","title":"Compilando o u-boot mainline"},{"location":"Boards/VIM3/Bootloader/u-boot/#baixando-u-boot-vim3","text":"A Khadas tamb\u00e9m possui um reposit\u00f3rio com as vers\u00f5es do u-boot para as diversas placas que eles produzem. Vamos baixar o brach khadas-vims-v2015.01 dentro da pasta u-boot-vim3 git clone https://github.com/khadas/u-boot.git -b khadas-vims-v2015.01 u-boot-vim3 Para fazer o cross compile \u00e9 necess\u00e1rio baixar as toolchain . Seguindo o tutorial base , precisaremos de 2 toolchain ( none-elf e none-eabi ): gcc-linaro-aarch64-none-elf-4.8-2013.11 - Linaro gcc-linaro-aarch64-none-elf-4.8-2013.11 (backup). gcc-linaro-arm-none-eabi-4.8-2013.11 - Linaro gcc-linaro-arm-none-eabi-4.8-2013.11 (backup).","title":"Baixando u-boot VIM3"},{"location":"Boards/VIM3/Bootloader/u-boot/#compilando-o-u-boot-vim3","text":"Antes de adicionar as novas toolchain ao path , limpe o terminal (abra um novo terminal). A vers\u00e3o utilizada no u-boot-mainline n\u00e3o \u00e9 compat\u00edvel com a vers\u00e3o da VIM3 Com as 2 toolchain baixadas, mova-as para a pastas toolchain e descompacte cada uma em sua respectiva pasta. Por fim, adicionar os bin\u00e1rios dos 2 toolchain ao path do sistema export PATH=CAMINHO_ABSOLUTO/toolchain/gcc-linaro-aarch64-none-elf-4.8-2013.11_linux/bin:$PATH export PATH=CAMINHO_ABSOLUTO/toolchain/gcc-linaro-arm-none-eabi-4.8-2013.11_linux/bin:$PATH Com os caminhos adicionados, podemos compilar o u-boot-vim3: make kvim3_defconfig O = out/ make CROSS_COMPILE = aarch64-none-elf- O = out/ O par\u00e2metro O define a pasta onde os arquivos compilados ser\u00e3o salvos. Se tudo ocorrer bem, uma mensagem similar deve aparecer: LD CAMINHO_ABSOLUTO/u-boot-vim3/out/board/khadas/kvim3/firmware/acs.elf OD CAMINHO_ABSOLUTO/u-boot-vim3/out/board/khadas/kvim3/firmware/acs.dump BIN CAMINHO_ABSOLUTO/u-boot-vim3/out/board/khadas/kvim3/firmware/acs.bin Built CAMINHO_ABSOLUTO/u-boot-vim3/out/board/khadas/kvim3/firmware/acs.bin successfully CPP task_entry.s CPP user_task.lds CC task_entry.o CC user_task.o CPP misc.s CC misc.o CC uart.o CC suspend.o CC lib/string.o CC lib/delay.o LD CAMINHO_ABSOLUTO/u-boot-vim3/out/scp_task/bl301.out OBJDUMP CAMINHO_ABSOLUTO/u-boot-vim3/out/scp_task/bl301.dis OBJCOPY CAMINHO_ABSOLUTO/u-boot-vim3/out/scp_task/bl301.bin","title":"Compilando o u-boot VIM3"},{"location":"Boards/VIM3/Bootloader/u-boot/#juntando-tudo","text":"O primeiro passo \u00e9 criar a pasta fip . Segundo, \u00e9 preciso baixar esse script da BayLibre ou no meu backup e mover para dentro da pasta fip Para mais informa\u00e7\u00f5es sobre o que \u00e9, acesse: FIP + compilados Terceiro, \u00e9 preciso copiar v\u00e1rios arquivos para dentro da pasta fip : # Arquivos compilados no u-boot-VIM3 cp u-boot-vim3/out/scp_task/bl301.bin fip cp u-boot-vim3/out/board/khadas/kvim3/firmware/acs.bin fip # Copia o u-boot.bin (mainline) e renomeia para bl33.bin cp u-boot-mainline/out/u-boot.bin fip/bl33.bin # Arquivos pr\u00e9-compilados (s\u00e3o fornecidos pela khadas) cp u-boot-vim3/fip/g12b/bl2.bin fip cp u-boot-vim3/fip/g12b/bl30.bin fip cp u-boot-vim3/fip/g12b/bl31.bin fip cp u-boot-vim3/fip/g12b/ddr3_1d.fw fip cp u-boot-vim3/fip/g12b/ddr4_1d.fw fip cp u-boot-vim3/fip/g12b/ddr4_2d.fw fip cp u-boot-vim3/fip/g12b/diag_lpddr4.fw fip cp u-boot-vim3/fip/g12b/lpddr3_1d.fw fip cp u-boot-vim3/fip/g12b/lpddr4_1d.fw fip cp u-boot-vim3/fip/g12b/lpddr4_2d.fw fip cp u-boot-vim3/fip/g12b/piei.fw fip cp u-boot-vim3/fip/g12b/aml_ddr.fw fip cp u-boot-vim3/fip/g12b/aml_encrypt_g12b fip","title":"Juntando tudo"},{"location":"Boards/VIM3/Bootloader/u-boot/#concatenando-os-arquivos","text":"Pra concatenar as informa\u00e7\u00f5es, vamos utilizar o script da baylibre (dentro da pasta fip ) # Adiciona um padding no bl30.bin e bl301.bin # depois concatena os dois, gerando bl30_new.bin bash blx_fix_g12a.sh bl30.bin zero_tmp bl30_zero.bin bl301.bin bl301_zero.bin bl30_new.bin bl30 # Adiciona um padding no bl2.bin e acs.bin # depois concatena os dois, gerando bl2_new.bin bash blx_fix_g12a.sh bl2.bin zero_tmp bl2_zero.bin acs.bin bl21_zero.bin bl2_new.bin bl2","title":"Concatenando os arquivos"},{"location":"Boards/VIM3/Bootloader/u-boot/#encriptando-os-arquivos","text":"Para mais informa\u00e7\u00f5es, acesse: link # Adiciona assinatura no cabe\u00e7alho do bin\u00e1rio ./aml_encrypt_g12b --bl2sig --input bl2_new.bin --output bl2.n.bin.sig # Adiciona assinatura no cabe\u00e7alho do bin\u00e1rio ./aml_encrypt_g12b --bl3sig --input bl31.bin --output bl31.img.enc --level v3 --type bl3 # Adiciona e encripta a assinatura no cabe\u00e7alho do bin\u00e1rio ./aml_encrypt_g12b --bl30sig --input bl30_new.bin --output bl30_new.bin.g12a.enc --level v3 ./aml_encrypt_g12b --bl3sig --input bl30_new.bin.g12a.enc --output bl30_new.bin.enc --level v3 --type bl301 # Adiciona a assinatura no cabe\u00e7alho, um padding no final do bin\u00e1rio e comprime o bin\u00e1rio ./aml_encrypt_g12b --bl3sig --input bl33.bin --compress lz4 --output bl33.bin.enc --level v3 --type bl33 --compress lz4 # Gera o bin\u00e1rio do u-boot com as assinaturas concatenadas ./aml_encrypt_g12b --bootmk --output u-boot-bin --bl2 bl2.n.bin.sig --bl30 bl30_new.bin.enc --bl31 bl31.img.enc \\ --bl33 bl33.bin.enc --ddrfw1 ddr4_1d.fw --ddrfw2 ddr4_2d.fw \\ --ddrfw3 ddr3_1d.fw --ddrfw4 piei.fw --ddrfw5 lpddr4_1d.fw \\ --ddrfw6 lpddr4_2d.fw --ddrfw7 diag_lpddr4.fw --ddrfw8 aml_ddr.fw \\ --ddrfw9 lpddr3_1d.fw --level v3","title":"Encriptando os arquivos"},{"location":"Boards/VIM3/Bootloader/u-boot/#passando-o-u-boot-para-o-sd-card","text":"$ DEV=/dev/your_sd_device $ dd if=fip/u-boot.bin.sd.bin of=$DEV conv=fsync,notrunc bs=512 skip=1 seek=1 $ dd if=fip/u-boot.bin.sd.bin of=$DEV conv=fsync,notrunc bs=1 count=444","title":"Passando o u-boot para o SD Card"},{"location":"Documenta%C3%A7%C3%A3o/Parti%C3%A7%C3%B5es/GPT/","text":"Tabela de Parti\u00e7\u00e3o GUID baseado nos link1 , link2 e link3 Considera\u00e7\u00f5es iniciais Vamos utilizar um cart\u00e3o micro SD de 32GB. Para identificarmos o cart\u00e3o no sistema, utilizamos o comando lsblk , o resultado ser\u00e1 similar a essa \u2570\u2500 lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT sda 8 :0 0 894 ,3G 0 disk \u2514\u2500sda1 8 :1 0 894 ,3G 0 part /run/timeshift/backup sdc 8 :32 1 29 ,1G 0 disk \u2514\u2500sdc1 8 :33 1 29 ,1G 0 part nvme0n1 259 :0 0 465 ,8G 0 disk \u251c\u2500nvme0n1p1 259 :1 0 476M 0 part /boot/efi \u251c\u2500nvme0n1p2 259 :2 0 30 ,5G 0 part [ SWAP ] \u2514\u2500nvme0n1p3 259 :3 0 434 ,8G 0 part / Para ter certeza qual \u00e9 o cart\u00e3o SD, execute o lsblk com o cart\u00e3o n\u00e3o conectado e depois conecte o cart\u00e3o e execute o comando novamente (simples ). No caso acima, o cart\u00e3o SD \u00e9 o /dev/sdc . Para facilitar a visualiza\u00e7\u00e3o das altera\u00e7\u00f5es que iremos fazer, vamos zerar os primeiros 10240 bytes do cart\u00e3o. Para isso, utilizaremos o comando dd sudo dd if = /dev/zero of = /dev/sdc bs = 1024 count = 10 Podemos visualizar conte\u00fado do cart\u00e3o, com o comando hexdump sudo hexdump -C /dev/sdc -n 10240 O resultado deve ser similar a esse 00000000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | ................ | * 00002800 o n\u00famero 00002800 \u00e9 em hexadecimal e seu equivalente em decimal \u00e9 10240 (ou 10 kB). Formatando o cart\u00e3o com GPT Com os primeiros bytes do cart\u00e3o SD zerados, vamos adicionar a parti\u00e7\u00e3o GPT ao cart\u00e3o com o comando fdisk sudo fdisk /dev/sdc Um menu ir\u00e1 aparecer: Digite g Depois digite n Partition number (1-128, default 1): Enter First sector (2048-61067230, default 2048): Enter Last sector, +/-sectors or +/-size{K,M,G,T,P} (2048-61067230, default 61067230): Enter Por fim, digite w Agora o cart\u00e3o est\u00e1 com o particionamento GPT. Para checar, vamos visualizar novamente o conte\u00fado do cart\u00e3o SD 00000000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | ................ | * 000001c0 02 00 ee ff ff ff 01 00 00 00 ff cf a3 03 00 00 | ................ | 000001d0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | ................ | * 000001f0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 55 aa | ..............U. | 00000200 45 46 49 20 50 41 52 54 00 00 01 00 5c 00 00 00 | EFI PART.... \\. .. | 00000210 fc d8 3a 53 00 00 00 00 01 00 00 00 00 00 00 00 | ..:S............ | 00000220 ff cf a3 03 00 00 00 00 00 08 00 00 00 00 00 00 | ................ | 00000230 de cf a3 03 00 00 00 00 90 30 7b d4 f3 72 46 59 | .........0 { ..rFY | 00000240 89 2c 7f 77 9e b0 00 e6 02 00 00 00 00 00 00 00 | .,.w............ | 00000250 80 00 00 00 80 00 00 00 f1 ae 2f f5 00 00 00 00 | ........../..... | 00000260 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | ................ | * 00000400 af 3d c6 0f 83 84 72 47 8e 79 3d 69 d8 47 7d e4 | . = ....rG.y = i.G } . | 00000410 9c 58 84 76 3e 65 45 92 a4 ec 96 ed 84 df 22 99 | .X.v>eE....... \".| 00000420 00 08 00 00 00 00 00 00 de cf a3 03 00 00 00 00 |................| 00000430 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 00002800 Esses dados mostram que o GPT est\u00e1 sendo usando no cart\u00e3o SD. O Backup de seguran\u00e7a Como uma forma de seguran\u00e7a contra perda de dados, o GPT faz um backup da parti\u00e7\u00e3o no final disco. Para checar basta utilizar o comando: sudo tail -c 10M /dev/sdc | hexdump -C Visualizando os \u00faltimos 10 MB do cart\u00e3o SD, encontramos o seguinte conte\u00fado 747900000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | ................ | * 7479fbe00 af 3d c6 0f 83 84 72 47 8e 79 3d 69 d8 47 7d e4 | . = ....rG.y = i.G } . | 7479fbe10 9c 58 84 76 3e 65 45 92 a4 ec 96 ed 84 df 22 99 | .X.v>eE....... \".| 7479fbe20 00 08 00 00 00 00 00 00 de cf a3 03 00 00 00 00 |................| 7479fbe30 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 7479ffe00 45 46 49 20 50 41 52 54 00 00 01 00 5c 00 00 00 |EFI PART....\\...| 7479ffe10 66 9b 01 67 00 00 00 00 ff cf a3 03 00 00 00 00 |f..g............| 7479ffe20 01 00 00 00 00 00 00 00 00 08 00 00 00 00 00 00 |................| 7479ffe30 de cf a3 03 00 00 00 00 90 30 7b d4 f3 72 46 59 |.........0{..rFY| 7479ffe40 89 2c 7f 77 9e b0 00 e6 df cf a3 03 00 00 00 00 |.,.w............| 7479ffe50 80 00 00 00 80 00 00 00 f1 ae 2f f5 00 00 00 00 |........../.....| 7479ffe60 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 747a00000 Podemos perceber um espelho dos dados do inicio do disco. O Logical Block Addressing O Logical Block Addressing ou LBA, s\u00e3o blocos de informa\u00e7\u00e3o utilizado pelo GPT. Esses blocos possuem 512 bytes. LBA0 O LBA0 existe para compatibilidade com o Master Boot Record (MBR), checando os primeiros 512 bytes do cart\u00e3o SD sudo hexdump -C /dev/sdc -s 0 -n 512 Temos esse resultado: 00000000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 000001c0 02 00 ee ff ff ff 01 00 00 00 ff cf a3 03 00 00 |................| 000001d0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 000001f0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 55 aa |..............U.| 00000200 Nada relevante pode ser visto aqui (a n\u00e3o ser que voc\u00ea esteja usando MBR ) LBA1 Esse LBA possui o cabe\u00e7alho da tabela de parti\u00e7\u00e3o. Visualizando os pr\u00f3ximos 512 bytes do cart\u00e3o SD sudo hexdump -C /dev/sdc -s 512 -n 512 Temos os seguintes dados: 00000200 45 46 49 20 50 41 52 54 00 00 01 00 5c 00 00 00 |EFI PART....\\...| 00000210 d2 61 e7 36 00 00 00 00 01 00 00 00 00 00 00 00 |.a.6............| 00000220 ff cf a3 03 00 00 00 00 00 08 00 00 00 00 00 00 |................| 00000230 de cf a3 03 00 00 00 00 46 8a 0b 22 c3 8c 45 75 |........F..\"..Eu| 00000240 8c ef f5 bd 9e 32 4c 5b 02 00 00 00 00 00 00 00 |.....2L[........| 00000250 80 00 00 00 80 00 00 00 af 06 c5 b4 00 00 00 00 |................| 00000260 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 00000400 Agora vamos entender esse vetor de bytes: Esses dados s\u00e3o Little Endian . Para interpretarmos o valor em decimal, devemos converter para Big Endian A assinatura s\u00e3o os primeiros 8 bytes 00000200 45 46 49 20 50 41 52 54 |EFI PART| 00000208 A revis\u00e3o s\u00e3o os 4 pr\u00f3ximos bytes 00000208 00 00 01 00 |....| 0000020c O tamanho do cabe\u00e7alho s\u00e3o os 4 pr\u00f3ximos bytes 0000020c 5c 00 00 00 |\\...| 00000210 O CRC32 da parti\u00e7\u00e3o s\u00e3o os 4 pr\u00f3ximos bytes 00000210 d2 61 e7 36 |.a.6| 00000214 Os pr\u00f3ximos 4 bytes s\u00e3o reservados e devem ser 0's 00000214 00 00 00 00 |....| 00000218 Endere\u00e7o do LBA atual s\u00e3o os 8 pr\u00f3ximos bytes 00000218 01 00 00 00 00 00 00 00 |........| 00000220 Localiza\u00e7\u00e3o do LBA espelho (backup) s\u00e3o os 8 pr\u00f3ximos bytes 00000220 ff cf a3 03 00 00 00 00 |........| 00000228 Big Endian: 00 00 00 00 03 A3 CF FF | Decimal 61067263. Isso indica que o LBA espelho est\u00e1 no setor 61067263. Para acessa-lo podemos utilizar o comando: sudo dd if=/dev/sdc bs=512 count=1 skip=61067263 Primeiro setor dispon\u00edvel para parti\u00e7\u00e3o s\u00e3o os pr\u00f3ximos 8 bytes 00000228 00 08 00 00 00 00 00 00 |........| 00000230 00 00 08 00 00 00 00 00 -> 2048 \u00daltimo setor dispon\u00edvel para parti\u00e7\u00e3o s\u00e3o os pr\u00f3ximos 8 bytes 00000230 de cf a3 03 00 00 00 00 |........| 00000238 Big endian: 0000000003A3CFDE | Decimal: 61067230. O \u00faltimo setor dispon\u00edvel \u00e9 o 61067230. O GUID s\u00e3o os pr\u00f3ximos 16 bytes 00000238 46 8a 0b 22 c3 8c 45 75 8c ef f5 bd 9e 32 4c 5b |F..\"..Eu.....2L[| 00000248 O GUID possui segmenta\u00e7\u00f5es: 468a0b22-c38c-4575-8cef-f5bd9e324c5b. Os primeiros 8 bytes s\u00e3o convertidos para big endian e o restante n\u00e3o \u00e9 convertido, resultando em: 220B8A46-8CC3-7545-8CEF-F5BD9E324C5B O setor que inicia as tabelas de parti\u00e7\u00e3o s\u00e3o os pr\u00f3ximos 8 bytes 00000248 02 00 00 00 00 00 00 00 |........| 00000250 Quantidades poss\u00edveis de parti\u00e7\u00f5es s\u00e3o os pr\u00f3ximos 4 bytes 00000250 80 00 00 00 |....| 00000254 Tamanho de um entrada da tabela de parti\u00e7\u00e3o s\u00e3o os pr\u00f3ximos 4 bytes 00000254 80 00 00 00 |....| 00000258 CRC32 de todas as entradas de parti\u00e7\u00e3o do disco s\u00e3o os pr\u00f3ximos 4 bytes 00000258 af 06 c5 b4 |....| 0000025c Restante do espa\u00e7o s\u00e3o 420 bytes 0000025c 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 00000400 LB2 - LBN 00000400 af 3d c6 0f 83 84 72 47 8e 79 3d 69 d8 47 7d e4 |.=....rG.y=i.G}.| 00000410 a0 d5 b4 b0 cf d0 4d fe b7 09 a8 3f 44 67 bd b7 |......M....?Dg..| 00000420 00 08 00 00 00 00 00 00 de cf a3 03 00 00 00 00 |................| 00000430 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 00000480 Tipo de parti\u00e7\u00e3o GUID s\u00e3o os primeiros 16 bytes 00000400 af 3d c6 0f 83 84 72 47 8e 79 3d 69 d8 47 7d e4 |.=....rG.y=i.G}.| 00000410 GUID \u00fanico s\u00e3o os pr\u00f3ximos 16 bytes 00000410 a0 d5 b4 b0 cf d0 4d fe b7 09 a8 3f 44 67 bd b7 |......M....?Dg..| 00000420 Primeiro setor dispon\u00edvel para parti\u00e7\u00e3o s\u00e3o os pr\u00f3ximos 8 bytes 00000420 00 08 00 00 00 00 00 00 |........| 00000428 \u00daltimo setor dispon\u00edvel para parti\u00e7\u00e3o s\u00e3o os pr\u00f3ximos 8 bytes 00000428 de cf a3 03 00 00 00 00 |........| 00000430 Os atributos s\u00e3o os pr\u00f3ximos 8 bytes 00000430 00 00 00 00 00 00 00 00 |........| 00000438 O nome da parti\u00e7\u00e3o s\u00e3o os pr\u00f3ximos 72 bytes 00000438 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 00000480","title":"Tabela de Parti\u00e7\u00e3o GUID"},{"location":"Documenta%C3%A7%C3%A3o/Parti%C3%A7%C3%B5es/GPT/#tabela-de-particao-guid","text":"baseado nos link1 , link2 e link3","title":"Tabela de Parti\u00e7\u00e3o GUID"},{"location":"Documenta%C3%A7%C3%A3o/Parti%C3%A7%C3%B5es/GPT/#consideracoes-iniciais","text":"Vamos utilizar um cart\u00e3o micro SD de 32GB. Para identificarmos o cart\u00e3o no sistema, utilizamos o comando lsblk , o resultado ser\u00e1 similar a essa \u2570\u2500 lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT sda 8 :0 0 894 ,3G 0 disk \u2514\u2500sda1 8 :1 0 894 ,3G 0 part /run/timeshift/backup sdc 8 :32 1 29 ,1G 0 disk \u2514\u2500sdc1 8 :33 1 29 ,1G 0 part nvme0n1 259 :0 0 465 ,8G 0 disk \u251c\u2500nvme0n1p1 259 :1 0 476M 0 part /boot/efi \u251c\u2500nvme0n1p2 259 :2 0 30 ,5G 0 part [ SWAP ] \u2514\u2500nvme0n1p3 259 :3 0 434 ,8G 0 part / Para ter certeza qual \u00e9 o cart\u00e3o SD, execute o lsblk com o cart\u00e3o n\u00e3o conectado e depois conecte o cart\u00e3o e execute o comando novamente (simples ). No caso acima, o cart\u00e3o SD \u00e9 o /dev/sdc . Para facilitar a visualiza\u00e7\u00e3o das altera\u00e7\u00f5es que iremos fazer, vamos zerar os primeiros 10240 bytes do cart\u00e3o. Para isso, utilizaremos o comando dd sudo dd if = /dev/zero of = /dev/sdc bs = 1024 count = 10 Podemos visualizar conte\u00fado do cart\u00e3o, com o comando hexdump sudo hexdump -C /dev/sdc -n 10240 O resultado deve ser similar a esse 00000000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | ................ | * 00002800 o n\u00famero 00002800 \u00e9 em hexadecimal e seu equivalente em decimal \u00e9 10240 (ou 10 kB).","title":"Considera\u00e7\u00f5es iniciais"},{"location":"Documenta%C3%A7%C3%A3o/Parti%C3%A7%C3%B5es/GPT/#formatando-o-cartao-com-gpt","text":"Com os primeiros bytes do cart\u00e3o SD zerados, vamos adicionar a parti\u00e7\u00e3o GPT ao cart\u00e3o com o comando fdisk sudo fdisk /dev/sdc Um menu ir\u00e1 aparecer: Digite g Depois digite n Partition number (1-128, default 1): Enter First sector (2048-61067230, default 2048): Enter Last sector, +/-sectors or +/-size{K,M,G,T,P} (2048-61067230, default 61067230): Enter Por fim, digite w Agora o cart\u00e3o est\u00e1 com o particionamento GPT. Para checar, vamos visualizar novamente o conte\u00fado do cart\u00e3o SD 00000000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | ................ | * 000001c0 02 00 ee ff ff ff 01 00 00 00 ff cf a3 03 00 00 | ................ | 000001d0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | ................ | * 000001f0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 55 aa | ..............U. | 00000200 45 46 49 20 50 41 52 54 00 00 01 00 5c 00 00 00 | EFI PART.... \\. .. | 00000210 fc d8 3a 53 00 00 00 00 01 00 00 00 00 00 00 00 | ..:S............ | 00000220 ff cf a3 03 00 00 00 00 00 08 00 00 00 00 00 00 | ................ | 00000230 de cf a3 03 00 00 00 00 90 30 7b d4 f3 72 46 59 | .........0 { ..rFY | 00000240 89 2c 7f 77 9e b0 00 e6 02 00 00 00 00 00 00 00 | .,.w............ | 00000250 80 00 00 00 80 00 00 00 f1 ae 2f f5 00 00 00 00 | ........../..... | 00000260 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | ................ | * 00000400 af 3d c6 0f 83 84 72 47 8e 79 3d 69 d8 47 7d e4 | . = ....rG.y = i.G } . | 00000410 9c 58 84 76 3e 65 45 92 a4 ec 96 ed 84 df 22 99 | .X.v>eE....... \".| 00000420 00 08 00 00 00 00 00 00 de cf a3 03 00 00 00 00 |................| 00000430 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 00002800 Esses dados mostram que o GPT est\u00e1 sendo usando no cart\u00e3o SD.","title":"Formatando o cart\u00e3o com GPT"},{"location":"Documenta%C3%A7%C3%A3o/Parti%C3%A7%C3%B5es/GPT/#o-backup-de-seguranca","text":"Como uma forma de seguran\u00e7a contra perda de dados, o GPT faz um backup da parti\u00e7\u00e3o no final disco. Para checar basta utilizar o comando: sudo tail -c 10M /dev/sdc | hexdump -C Visualizando os \u00faltimos 10 MB do cart\u00e3o SD, encontramos o seguinte conte\u00fado 747900000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | ................ | * 7479fbe00 af 3d c6 0f 83 84 72 47 8e 79 3d 69 d8 47 7d e4 | . = ....rG.y = i.G } . | 7479fbe10 9c 58 84 76 3e 65 45 92 a4 ec 96 ed 84 df 22 99 | .X.v>eE....... \".| 7479fbe20 00 08 00 00 00 00 00 00 de cf a3 03 00 00 00 00 |................| 7479fbe30 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 7479ffe00 45 46 49 20 50 41 52 54 00 00 01 00 5c 00 00 00 |EFI PART....\\...| 7479ffe10 66 9b 01 67 00 00 00 00 ff cf a3 03 00 00 00 00 |f..g............| 7479ffe20 01 00 00 00 00 00 00 00 00 08 00 00 00 00 00 00 |................| 7479ffe30 de cf a3 03 00 00 00 00 90 30 7b d4 f3 72 46 59 |.........0{..rFY| 7479ffe40 89 2c 7f 77 9e b0 00 e6 df cf a3 03 00 00 00 00 |.,.w............| 7479ffe50 80 00 00 00 80 00 00 00 f1 ae 2f f5 00 00 00 00 |........../.....| 7479ffe60 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 747a00000 Podemos perceber um espelho dos dados do inicio do disco.","title":"O Backup de seguran\u00e7a"},{"location":"Documenta%C3%A7%C3%A3o/Parti%C3%A7%C3%B5es/GPT/#o-logical-block-addressing","text":"O Logical Block Addressing ou LBA, s\u00e3o blocos de informa\u00e7\u00e3o utilizado pelo GPT. Esses blocos possuem 512 bytes.","title":"O Logical Block Addressing"},{"location":"Documenta%C3%A7%C3%A3o/Parti%C3%A7%C3%B5es/GPT/#lba0","text":"O LBA0 existe para compatibilidade com o Master Boot Record (MBR), checando os primeiros 512 bytes do cart\u00e3o SD sudo hexdump -C /dev/sdc -s 0 -n 512 Temos esse resultado: 00000000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 000001c0 02 00 ee ff ff ff 01 00 00 00 ff cf a3 03 00 00 |................| 000001d0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 000001f0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 55 aa |..............U.| 00000200 Nada relevante pode ser visto aqui (a n\u00e3o ser que voc\u00ea esteja usando MBR )","title":"LBA0"},{"location":"Documenta%C3%A7%C3%A3o/Parti%C3%A7%C3%B5es/GPT/#lba1","text":"Esse LBA possui o cabe\u00e7alho da tabela de parti\u00e7\u00e3o. Visualizando os pr\u00f3ximos 512 bytes do cart\u00e3o SD sudo hexdump -C /dev/sdc -s 512 -n 512 Temos os seguintes dados: 00000200 45 46 49 20 50 41 52 54 00 00 01 00 5c 00 00 00 |EFI PART....\\...| 00000210 d2 61 e7 36 00 00 00 00 01 00 00 00 00 00 00 00 |.a.6............| 00000220 ff cf a3 03 00 00 00 00 00 08 00 00 00 00 00 00 |................| 00000230 de cf a3 03 00 00 00 00 46 8a 0b 22 c3 8c 45 75 |........F..\"..Eu| 00000240 8c ef f5 bd 9e 32 4c 5b 02 00 00 00 00 00 00 00 |.....2L[........| 00000250 80 00 00 00 80 00 00 00 af 06 c5 b4 00 00 00 00 |................| 00000260 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 00000400 Agora vamos entender esse vetor de bytes: Esses dados s\u00e3o Little Endian . Para interpretarmos o valor em decimal, devemos converter para Big Endian A assinatura s\u00e3o os primeiros 8 bytes 00000200 45 46 49 20 50 41 52 54 |EFI PART| 00000208 A revis\u00e3o s\u00e3o os 4 pr\u00f3ximos bytes 00000208 00 00 01 00 |....| 0000020c O tamanho do cabe\u00e7alho s\u00e3o os 4 pr\u00f3ximos bytes 0000020c 5c 00 00 00 |\\...| 00000210 O CRC32 da parti\u00e7\u00e3o s\u00e3o os 4 pr\u00f3ximos bytes 00000210 d2 61 e7 36 |.a.6| 00000214 Os pr\u00f3ximos 4 bytes s\u00e3o reservados e devem ser 0's 00000214 00 00 00 00 |....| 00000218 Endere\u00e7o do LBA atual s\u00e3o os 8 pr\u00f3ximos bytes 00000218 01 00 00 00 00 00 00 00 |........| 00000220 Localiza\u00e7\u00e3o do LBA espelho (backup) s\u00e3o os 8 pr\u00f3ximos bytes 00000220 ff cf a3 03 00 00 00 00 |........| 00000228 Big Endian: 00 00 00 00 03 A3 CF FF | Decimal 61067263. Isso indica que o LBA espelho est\u00e1 no setor 61067263. Para acessa-lo podemos utilizar o comando: sudo dd if=/dev/sdc bs=512 count=1 skip=61067263 Primeiro setor dispon\u00edvel para parti\u00e7\u00e3o s\u00e3o os pr\u00f3ximos 8 bytes 00000228 00 08 00 00 00 00 00 00 |........| 00000230 00 00 08 00 00 00 00 00 -> 2048 \u00daltimo setor dispon\u00edvel para parti\u00e7\u00e3o s\u00e3o os pr\u00f3ximos 8 bytes 00000230 de cf a3 03 00 00 00 00 |........| 00000238 Big endian: 0000000003A3CFDE | Decimal: 61067230. O \u00faltimo setor dispon\u00edvel \u00e9 o 61067230. O GUID s\u00e3o os pr\u00f3ximos 16 bytes 00000238 46 8a 0b 22 c3 8c 45 75 8c ef f5 bd 9e 32 4c 5b |F..\"..Eu.....2L[| 00000248 O GUID possui segmenta\u00e7\u00f5es: 468a0b22-c38c-4575-8cef-f5bd9e324c5b. Os primeiros 8 bytes s\u00e3o convertidos para big endian e o restante n\u00e3o \u00e9 convertido, resultando em: 220B8A46-8CC3-7545-8CEF-F5BD9E324C5B O setor que inicia as tabelas de parti\u00e7\u00e3o s\u00e3o os pr\u00f3ximos 8 bytes 00000248 02 00 00 00 00 00 00 00 |........| 00000250 Quantidades poss\u00edveis de parti\u00e7\u00f5es s\u00e3o os pr\u00f3ximos 4 bytes 00000250 80 00 00 00 |....| 00000254 Tamanho de um entrada da tabela de parti\u00e7\u00e3o s\u00e3o os pr\u00f3ximos 4 bytes 00000254 80 00 00 00 |....| 00000258 CRC32 de todas as entradas de parti\u00e7\u00e3o do disco s\u00e3o os pr\u00f3ximos 4 bytes 00000258 af 06 c5 b4 |....| 0000025c Restante do espa\u00e7o s\u00e3o 420 bytes 0000025c 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 00000400","title":"LBA1"},{"location":"Documenta%C3%A7%C3%A3o/Parti%C3%A7%C3%B5es/GPT/#lb2-lbn","text":"00000400 af 3d c6 0f 83 84 72 47 8e 79 3d 69 d8 47 7d e4 |.=....rG.y=i.G}.| 00000410 a0 d5 b4 b0 cf d0 4d fe b7 09 a8 3f 44 67 bd b7 |......M....?Dg..| 00000420 00 08 00 00 00 00 00 00 de cf a3 03 00 00 00 00 |................| 00000430 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 00000480 Tipo de parti\u00e7\u00e3o GUID s\u00e3o os primeiros 16 bytes 00000400 af 3d c6 0f 83 84 72 47 8e 79 3d 69 d8 47 7d e4 |.=....rG.y=i.G}.| 00000410 GUID \u00fanico s\u00e3o os pr\u00f3ximos 16 bytes 00000410 a0 d5 b4 b0 cf d0 4d fe b7 09 a8 3f 44 67 bd b7 |......M....?Dg..| 00000420 Primeiro setor dispon\u00edvel para parti\u00e7\u00e3o s\u00e3o os pr\u00f3ximos 8 bytes 00000420 00 08 00 00 00 00 00 00 |........| 00000428 \u00daltimo setor dispon\u00edvel para parti\u00e7\u00e3o s\u00e3o os pr\u00f3ximos 8 bytes 00000428 de cf a3 03 00 00 00 00 |........| 00000430 Os atributos s\u00e3o os pr\u00f3ximos 8 bytes 00000430 00 00 00 00 00 00 00 00 |........| 00000438 O nome da parti\u00e7\u00e3o s\u00e3o os pr\u00f3ximos 72 bytes 00000438 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 00000480","title":"LB2 - LBN"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/","text":"Documenta\u00e7\u00e3o com MKDOCS Image by WikiImages from Pixabay Introdu\u00e7\u00e3o Essa postagem foi inspirado na live de python #189 . Se quiser mais informa\u00e7\u00f5es sobre MKDocs da uma olhada no v\u00eddeo e deixa o like. O MKDocs \u00e9 uma biblioteca focada em documenta\u00e7\u00e3o, desenvolvida em python. Ela possui v\u00e1rias funcionalidades e algumas delas ser\u00e3o mostradas abaixo. Para instalar: pip install mkdocs Ap\u00f3s a instala\u00e7\u00e3o basta digitar: mkdocs new TESTE Os arquivos necess\u00e1rios para iniciar a documenta\u00e7\u00e3o ser\u00e3o criados. Markdown B\u00e1sico Comandos dispon\u00edveis por padr\u00e3o na biblioteca. T\u00edtulo (H1) # Exemplo Subtitulo (H2) ## Exemplo Subsubtitulo (H3) ### Exemplo Negrito **Exemplo** Exemplo It\u00e1lico *Exemplo* Exemplo Cita\u00e7\u00e3o > Exemplo Exemplo Lista Ordenada 1. Exemplo 2. Exemplo 3. Exemplo Exemplo Exemplo Exemplo Lista N\u00e3o Ordenada - Exemplo - Exemplo - Exemplo Exemplo Exemplo Exemplo Linha de C\u00f3digo `C\u00f3digo` C\u00f3digo Link [Site do google](https://www.google.com.br) Site do google Tabela | Nome | Idade | | ---- | ----- | | Jo\u00e3o | 28 | | Pedro | 34 | Nome Idade Jo\u00e3o 28 Pedro 34 Markdown Estendido Para ter ainda mais funcionalidades, \u00e9 necess\u00e1rio instalar a biblioteca PyMdown Extensions : pip install pymdown-extensions Al\u00e9m disso, \u00e9 necess\u00e1rio adicionar quais extens\u00f5es ser\u00e3o usadas dentro do arquivo mkdocs.yml , por exemplo: markdown_extensions: - pymdownx.tasklist - pymdownx.emoji - pymdownx.mark - pymdownx.tilde Cada uma dessas extens\u00f5es ser\u00e3o mostradas a seguir. Lista de Tarefas pymdownx.tasklist - [ ] Checar. - [ ] checar. - [X] checado. Checar. checar. checado. Emoji Para mais emojis: emojipedia . Escolha um emoji e procure por Shortcodes . pymdownx.emoji :snake: :heart: :rocket: Tachado pymdownx.tilde ~~Exemplo~~ Exemplo Real\u00e7ado pymdownx.mark ==Exemplo== Exemplo Super Fences Dentro do pymdown-extensions existe uma funcionalidade que merece um t\u00f3pico a parte, chamado de superfences . Com ele, o MKDocs fica ainda mais poderoso. \u00c9 necess\u00e1rio informar para o MKDocs que o super fences ser\u00e1 utilizado, adicionando as linhas dentro do mkdocs.yml : markdown_extensions: # ... - pymdownx.superfences: custom_fences: - name: mermaid class: mermaid format: !!python/name:pymdownx.superfences.fence_div_format extra_javascript: - https://unpkg.com/mermaid@8.5.1/dist/mermaid.min.js Bloco de c\u00f3digo pymdownx.superfences ```{.py3 linenums=\"44\" title=\"teste.py\" hl_lines=\"1 3\"} def xpto(): \"\"\"Docstring\"\"\" return True ``` teste.py 44 45 46 def xpto (): \"\"\"Docstring\"\"\" return True F\u00f3rmulas pymdownx.arithmatex $$ \\operatorname{ker} f=\\{g\\in G:f(g)=e_{H}\\}{\\mbox{.}} $$ \\[ \\operatorname{ker} f=\\{g\\in G:f(g)=e_{H}\\}{\\mbox{.}} \\] The homomorphism $f$ is injective if and only if its kernel is only the singleton set $e_G$, because otherwise $\\exists a,b\\in G$ with $a\\neq b$ such that $f(a)=f(b)$. The homomorphism \\(f\\) is injective if and only if its kernel is only the singleton set \\(e_G\\) , because otherwise \\(\\exists a,b\\in G\\) with \\(a\\neq b\\) such that \\(f(a)=f(b)\\) . Custom Fences \u00c9 poss\u00edvel incorporar outras bibliotecas dentro do MKDocs, por exemplo a Mermaid que \u00e9 uma biblioteca para gerar diagramas e gr\u00e1ficos. Para isso, \u00e9 necess\u00e1rio adicionar no mkdocs.yml - pymdownx.superfences: custom_fences: - name: mermaid class: mermaid format: !!python/name:pymdownx.superfences.fence_div_format extra_javascript: - https://unpkg.com/mermaid@8.5.1/dist/mermaid.min.js ```mermaid classDiagram Pessoa <|-- Eduardo class Pessoa{ +String nome +metodo(self):bool } ``` classDiagram Pessoa <|-- Jao class Pessoa{ +String nome +metodo(self):bool }","title":"Documenta\u00e7\u00e3o com MKDOCS"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#documentacao-com-mkdocs","text":"Image by WikiImages from Pixabay","title":"Documenta\u00e7\u00e3o com MKDOCS"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#introducao","text":"Essa postagem foi inspirado na live de python #189 . Se quiser mais informa\u00e7\u00f5es sobre MKDocs da uma olhada no v\u00eddeo e deixa o like. O MKDocs \u00e9 uma biblioteca focada em documenta\u00e7\u00e3o, desenvolvida em python. Ela possui v\u00e1rias funcionalidades e algumas delas ser\u00e3o mostradas abaixo. Para instalar: pip install mkdocs Ap\u00f3s a instala\u00e7\u00e3o basta digitar: mkdocs new TESTE Os arquivos necess\u00e1rios para iniciar a documenta\u00e7\u00e3o ser\u00e3o criados.","title":"Introdu\u00e7\u00e3o"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#markdown-basico","text":"Comandos dispon\u00edveis por padr\u00e3o na biblioteca.","title":"Markdown B\u00e1sico"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#titulo-h1","text":"# Exemplo","title":"T\u00edtulo (H1)"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#subtitulo-h2","text":"## Exemplo","title":"Subtitulo (H2)"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#subsubtitulo-h3","text":"### Exemplo","title":"Subsubtitulo (H3)"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#negrito","text":"**Exemplo** Exemplo","title":"Negrito"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#italico","text":"*Exemplo* Exemplo","title":"It\u00e1lico"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#citacao","text":"> Exemplo Exemplo","title":"Cita\u00e7\u00e3o"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#lista-ordenada","text":"1. Exemplo 2. Exemplo 3. Exemplo Exemplo Exemplo Exemplo","title":"Lista Ordenada"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#lista-nao-ordenada","text":"- Exemplo - Exemplo - Exemplo Exemplo Exemplo Exemplo","title":"Lista N\u00e3o Ordenada"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#linha-de-codigo","text":"`C\u00f3digo` C\u00f3digo","title":"Linha de C\u00f3digo"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#link","text":"[Site do google](https://www.google.com.br) Site do google","title":"Link"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#tabela","text":"| Nome | Idade | | ---- | ----- | | Jo\u00e3o | 28 | | Pedro | 34 | Nome Idade Jo\u00e3o 28 Pedro 34","title":"Tabela"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#markdown-estendido","text":"Para ter ainda mais funcionalidades, \u00e9 necess\u00e1rio instalar a biblioteca PyMdown Extensions : pip install pymdown-extensions Al\u00e9m disso, \u00e9 necess\u00e1rio adicionar quais extens\u00f5es ser\u00e3o usadas dentro do arquivo mkdocs.yml , por exemplo: markdown_extensions: - pymdownx.tasklist - pymdownx.emoji - pymdownx.mark - pymdownx.tilde Cada uma dessas extens\u00f5es ser\u00e3o mostradas a seguir.","title":"Markdown Estendido"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#lista-de-tarefas","text":"pymdownx.tasklist - [ ] Checar. - [ ] checar. - [X] checado. Checar. checar. checado.","title":"Lista de Tarefas"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#emoji","text":"Para mais emojis: emojipedia . Escolha um emoji e procure por Shortcodes . pymdownx.emoji :snake: :heart: :rocket:","title":"Emoji"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#tachado","text":"pymdownx.tilde ~~Exemplo~~ Exemplo","title":"Tachado"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#realcado","text":"pymdownx.mark ==Exemplo== Exemplo","title":"Real\u00e7ado"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#super-fences","text":"Dentro do pymdown-extensions existe uma funcionalidade que merece um t\u00f3pico a parte, chamado de superfences . Com ele, o MKDocs fica ainda mais poderoso. \u00c9 necess\u00e1rio informar para o MKDocs que o super fences ser\u00e1 utilizado, adicionando as linhas dentro do mkdocs.yml : markdown_extensions: # ... - pymdownx.superfences: custom_fences: - name: mermaid class: mermaid format: !!python/name:pymdownx.superfences.fence_div_format extra_javascript: - https://unpkg.com/mermaid@8.5.1/dist/mermaid.min.js","title":"Super Fences"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#bloco-de-codigo","text":"pymdownx.superfences ```{.py3 linenums=\"44\" title=\"teste.py\" hl_lines=\"1 3\"} def xpto(): \"\"\"Docstring\"\"\" return True ``` teste.py 44 45 46 def xpto (): \"\"\"Docstring\"\"\" return True","title":"Bloco de c\u00f3digo"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#formulas","text":"pymdownx.arithmatex $$ \\operatorname{ker} f=\\{g\\in G:f(g)=e_{H}\\}{\\mbox{.}} $$ \\[ \\operatorname{ker} f=\\{g\\in G:f(g)=e_{H}\\}{\\mbox{.}} \\] The homomorphism $f$ is injective if and only if its kernel is only the singleton set $e_G$, because otherwise $\\exists a,b\\in G$ with $a\\neq b$ such that $f(a)=f(b)$. The homomorphism \\(f\\) is injective if and only if its kernel is only the singleton set \\(e_G\\) , because otherwise \\(\\exists a,b\\in G\\) with \\(a\\neq b\\) such that \\(f(a)=f(b)\\) .","title":"F\u00f3rmulas"},{"location":"Documenta%C3%A7%C3%A3o/mkdocs/mkdocs/#custom-fences","text":"\u00c9 poss\u00edvel incorporar outras bibliotecas dentro do MKDocs, por exemplo a Mermaid que \u00e9 uma biblioteca para gerar diagramas e gr\u00e1ficos. Para isso, \u00e9 necess\u00e1rio adicionar no mkdocs.yml - pymdownx.superfences: custom_fences: - name: mermaid class: mermaid format: !!python/name:pymdownx.superfences.fence_div_format extra_javascript: - https://unpkg.com/mermaid@8.5.1/dist/mermaid.min.js ```mermaid classDiagram Pessoa <|-- Eduardo class Pessoa{ +String nome +metodo(self):bool } ``` classDiagram Pessoa <|-- Jao class Pessoa{ +String nome +metodo(self):bool }","title":"Custom Fences"},{"location":"Linguagens/Rust/Cap1/","text":"Introdu\u00e7\u00e3o Instalando o Rust no linux Escrevendo o Hello World! Usando cargo (gerenciador de pacotes e sistema de build) Instalando o Rust no linux Devemos baixar o rustup , que \u00e9 responsp\u00e1vel por baixar o rust e fazer a instala\u00e7\u00e3o curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh Algumas informa\u00e7\u00f5es devem aparecer Welcome to Rust! This will download and install the official compiler for the Rust programming language, and its package manager, Cargo. Rustup metadata and toolchains will be installed into the Rustup home directory, located at: /home/jao/Documents/Programs/rust/rustup/ This can be modified with the RUSTUP_HOME environment variable. The Cargo home directory located at: /home/jao/Documents/Programs/rust/cargo/ This can be modified with the CARGO_HOME environment variable. The cargo, rustc, rustup and other commands will be added to Cargo's bin directory , located at: /home/jao/.cargo/bin This path will then be added to your PATH environment variable by modifying the profile files located at: /home/jao/.profile /home/jao/.zshenv You can uninstall at any time with rustup self uninstall and these changes will be reverted. Current installation options: default host triple: x86_64-unknown-linux-gnu default toolchain: stable (default) profile: default modify PATH variable: yes 1) Proceed with installation (default) 2) Customize installation 3) Cancel installation Basta digitar 1 e a instala\u00e7\u00e3o ir\u00e1 come\u00e7ar. Se tudo occorrer bem, a seguinte mensagem deve aparecer Rust is installed now. Great! To get started you may need to restart your current shell. This would reload your PATH environment variable to include Cargo's bin directory (/home/jao/Documents/Programs/rust/cargo//bin). To configure your current shell, run: source /home/jao/Documents/Programs/rust/cargo//env Alguns comandos \u00fateis rustup update rustup self uninstall rustc --version rustup doc Escrevendo o Hello World! Crie um arquivo chamado main.rs e adicione o conte\u00fado main.rs fn main () { println! ( \"Hello World!\" ); } Para compilar e executar, basta digitar no terminal rustc main.rc ./main O resultado ser\u00e1 o texto Hello World! Alguns comandos \u00fateis rustfmt (para formatar o c\u00f3digo) Usando cargo (gerenciador de pacotes e sistema de build) Para criar um projeto utilizando o cargo , basta usar o comando cargo new hello_cargo Um arquivo main.rs ser\u00e1 criado dentro da pasta hello_cargo/src/ . Para compilar o c\u00f3digo, basta digitar cargo build dentro da pasta hello_cargo, a pasta target/ ser\u00e1 criada e o execut\u00e1vel est\u00e1 em hello_cargo/target/debug , chamado de hello_cargo Comandos \u00fateis cargo run (para executar o programa) cargo check (para fazer as checagens no c\u00f3digo, sem compilar) cargo build --release (para fazer uma build de release, por padr\u00e3o a build \u00e9 de debug).","title":"Introdu\u00e7\u00e3o"},{"location":"Linguagens/Rust/Cap1/#introducao","text":"Instalando o Rust no linux Escrevendo o Hello World! Usando cargo (gerenciador de pacotes e sistema de build)","title":"Introdu\u00e7\u00e3o"},{"location":"Linguagens/Rust/Cap1/#instalando-o-rust-no-linux","text":"Devemos baixar o rustup , que \u00e9 responsp\u00e1vel por baixar o rust e fazer a instala\u00e7\u00e3o curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh Algumas informa\u00e7\u00f5es devem aparecer Welcome to Rust! This will download and install the official compiler for the Rust programming language, and its package manager, Cargo. Rustup metadata and toolchains will be installed into the Rustup home directory, located at: /home/jao/Documents/Programs/rust/rustup/ This can be modified with the RUSTUP_HOME environment variable. The Cargo home directory located at: /home/jao/Documents/Programs/rust/cargo/ This can be modified with the CARGO_HOME environment variable. The cargo, rustc, rustup and other commands will be added to Cargo's bin directory , located at: /home/jao/.cargo/bin This path will then be added to your PATH environment variable by modifying the profile files located at: /home/jao/.profile /home/jao/.zshenv You can uninstall at any time with rustup self uninstall and these changes will be reverted. Current installation options: default host triple: x86_64-unknown-linux-gnu default toolchain: stable (default) profile: default modify PATH variable: yes 1) Proceed with installation (default) 2) Customize installation 3) Cancel installation Basta digitar 1 e a instala\u00e7\u00e3o ir\u00e1 come\u00e7ar. Se tudo occorrer bem, a seguinte mensagem deve aparecer Rust is installed now. Great! To get started you may need to restart your current shell. This would reload your PATH environment variable to include Cargo's bin directory (/home/jao/Documents/Programs/rust/cargo//bin). To configure your current shell, run: source /home/jao/Documents/Programs/rust/cargo//env","title":"Instalando o Rust no linux"},{"location":"Linguagens/Rust/Cap1/#alguns-comandos-uteis","text":"rustup update rustup self uninstall rustc --version rustup doc","title":"Alguns comandos \u00fateis"},{"location":"Linguagens/Rust/Cap1/#escrevendo-o-hello-world","text":"Crie um arquivo chamado main.rs e adicione o conte\u00fado main.rs fn main () { println! ( \"Hello World!\" ); } Para compilar e executar, basta digitar no terminal rustc main.rc ./main O resultado ser\u00e1 o texto Hello World!","title":"Escrevendo o Hello World!"},{"location":"Linguagens/Rust/Cap1/#alguns-comandos-uteis_1","text":"rustfmt (para formatar o c\u00f3digo)","title":"Alguns comandos \u00fateis"},{"location":"Linguagens/Rust/Cap1/#usando-cargo-gerenciador-de-pacotes-e-sistema-de-build","text":"Para criar um projeto utilizando o cargo , basta usar o comando cargo new hello_cargo Um arquivo main.rs ser\u00e1 criado dentro da pasta hello_cargo/src/ . Para compilar o c\u00f3digo, basta digitar cargo build dentro da pasta hello_cargo, a pasta target/ ser\u00e1 criada e o execut\u00e1vel est\u00e1 em hello_cargo/target/debug , chamado de hello_cargo","title":"Usando cargo (gerenciador de pacotes e sistema de build)"},{"location":"Linguagens/Rust/Cap1/#comandos-uteis","text":"cargo run (para executar o programa) cargo check (para fazer as checagens no c\u00f3digo, sem compilar) cargo build --release (para fazer uma build de release, por padr\u00e3o a build \u00e9 de debug).","title":"Comandos \u00fateis"},{"location":"Linguagens/Rust/Cap2/","text":"Adivinha\u00e7\u00e3o Introdu\u00e7\u00e3o Dando continuidade ao conhecimento do Rust , vamos ao cap\u00edtulo 2 do livro: The Rust Programming Language Ele prop\u00f5em introduzir alguns conceitos comuns da linguagem, criando o jogo da adivinha\u00e7\u00e3o Configurando o Projeto Criei um novo projeto utilizando o Cargo : cargo new adivinhacao Come\u00e7ando o Jogo Vou dividir em alguns passos para facilitar o passo a passo da cria\u00e7\u00e3o do jogo. Para compilar o programa utilizei o cargo build e para executar cargo run . Input O primeiro passo \u00e9 saber como fazer um input do usu\u00e1rio. Para isso, segue o c\u00f3digo abaixo: src/main.rs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // Baseado no exemplo do pr\u00f3prio livo, com algumas modifica\u00e7\u00f5es use std :: io ; //Lib para tratar de I/O fn main () { // Observe o termo \"mut\", pois essa vari\u00e1vel // ser\u00e1 alterada com a entrada do usu\u00e1rio let mut guess = String :: new (); io :: stdin () . read_line ( & mut guess ) // L\u00ea a entrada e atribui a vari\u00e1vel \"guess\" . expect ( \"Failed to read line\" ); // Caso algo saia errado, mostra a mensagem println! ( \"You guessed: {guess}\" ); //Mostra a entrada do usu\u00e1rio } N\u00fameros Aleat\u00f3rios O Rust n\u00e3o possui a gera\u00e7\u00e3o de n\u00fameros aleat\u00f3rios em sua biblioteca padr\u00e3o. Com isso, usei o rand dispon\u00edvel no crate . Para isso, \u00e9 necess\u00e1rio adicionar a biblioteca no arquivo Cargo.toml : [dependencies] rand = \"0.8.3\" Agora utilize o comando cargo build para instalar a depend\u00eancia. Voltando ao c\u00f3digo, vamos adicionar biblioteca e a fun\u00e7\u00e3o que gera os n\u00fameros: src/main.rs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // Baseado no exemplo do pr\u00f3prio livro, com algumas modifica\u00e7\u00f5es use std :: io ; //Lib para tratar de I/O use rand :: Rng ; //Lib para gerar n\u00fameros rand\u00f4micos fn main () { // Gera um n\u00famero inteiro de 0 a 100 let secret_number = rand :: thread_rng (). gen_range ( 1 ..= 100 ); println! ( \"The secret number is: {secret_number}\" ); // Observe o termo \"mut\", pois essa vari\u00e1vel // ser\u00e1 alterada com a entrada do usu\u00e1rio let mut guess = String :: new (); io :: stdin () . read_line ( & mut guess ) // L\u00ea a entrada e atribui a vari\u00e1vel \"guess\" . expect ( \"Failed to read line\" ); // Caso algo saia errado, mostra a mensagem println! ( \"You guessed: {guess}\" ); //Mostra a entrada do usu\u00e1rio } Comparando Uma vez que a entrada do usu\u00e1rio e o n\u00famero rand\u00f4mico est\u00e3o dispon\u00edveis, s\u00f3 resta fazer a compara\u00e7\u00e3o entre os dois e checar se \u00e9 menor, maior ou igual. src/main.rs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // Baseado no exemplo do pr\u00f3prio livro, com algumas modifica\u00e7\u00f5es use std :: io ; //Lib para tratar de I/O use rand :: Rng ; //Lib para gerar n\u00fameros rand\u00f4micos use std :: cmp :: Ordering ; //Lib para fazer compara\u00e7\u00e3o fn main () { // Gera um n\u00famero inteiro de 0 a 100 let secret_number = rand :: thread_rng (). gen_range ( 1 ..= 100 ); println! ( \"The secret number is: {secret_number}\" ); // Observe o termo \"mut\", pois essa vari\u00e1vel // ser\u00e1 alterada com a entrada do usu\u00e1rio let mut guess = String :: new (); io :: stdin () . read_line ( & mut guess ) // L\u00ea a entrada e atribui a vari\u00e1vel \"guess\" . expect ( \"Failed to read line\" ); // Caso algo saia errado, mostra a mensagem // Converte a entrada para inteiro let guess : u32 = guess . trim (). parse (). expect ( \" \\n\\n >>>> Please type a integer number! <<<< \\n\\n \" ); println! ( \"You guessed: {guess}\" ); //Mostra a entrada do usu\u00e1rio // Compara e informa se o n\u00famero \u00e9 menor, maior ou igual match guess . cmp ( & secret_number ) { Ordering :: Less => println! ( \"Too small!\" ), Ordering :: Greater => println! ( \"Too big!\" ), Ordering :: Equal => println! ( \"You win!\" ), } } Tentando Novamente At\u00e9 agora o jogo s\u00f3 permite apenas uma tentativa ( try hard ). Agora vou adicionar o loop para fazer v\u00e1rias tentativas. src/main.rs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 // Baseado no exemplo do pr\u00f3prio livro, com algumas modifica\u00e7\u00f5es use std :: io ; //Lib para tratar de I/O use rand :: Rng ; //Lib para gerar n\u00fameros rand\u00f4micos use std :: cmp :: Ordering ; //Lib para fazer compara\u00e7\u00e3o fn main () { // Gera um n\u00famero inteiro de 0 a 100 let secret_number = rand :: thread_rng (). gen_range ( 1 ..= 100 ); println! ( \"The secret number is: {secret_number}\" ); loop { // Observe o termo \"mut\", pois essa vari\u00e1vel // ser\u00e1 alterada com a entrada do usu\u00e1rio let mut guess = String :: new (); io :: stdin () . read_line ( & mut guess ) // L\u00ea a entrada e atribui a vari\u00e1vel \"guess\" . expect ( \"Failed to read line\" ); // Caso algo saia errado, mostra a mensagem // Converte a entrada para inteiro let guess : u32 = guess . trim (). parse (). expect ( \" \\n\\n >>>> Please type a integer number! <<<< \\n\\n \" ); println! ( \"You guessed: {guess}\" ); //Mostra a entrada do usu\u00e1rio // Compara e informa se o n\u00famero \u00e9 menor, maior ou igual match guess . cmp ( & secret_number ) { Ordering :: Less => println! ( \"Too small!\" ), Ordering :: Greater => println! ( \"Too big!\" ), Ordering :: Equal => println! ( \"You win!\" ), } } } Ganhando Mesmo digitando o n\u00famero correto, o jogo ainda permite fazer uma nova tentativa. Vou adicionar um break quando o n\u00famero digitado for o correto. src/main.rs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 // Baseado no exemplo do pr\u00f3prio livro, com algumas modifica\u00e7\u00f5es use std :: io ; //Lib para tratar de I/O use rand :: Rng ; //Lib para gerar n\u00fameros rand\u00f4micos use std :: cmp :: Ordering ; //Lib para fazer compara\u00e7\u00e3o fn main () { // Gera um n\u00famero inteiro de 0 a 100 let secret_number = rand :: thread_rng (). gen_range ( 1 ..= 100 ); println! ( \"The secret number is: {secret_number}\" ); loop { // Observe o termo \"mut\", pois essa vari\u00e1vel // ser\u00e1 alterada com a entrada do usu\u00e1rio let mut guess = String :: new (); io :: stdin () . read_line ( & mut guess ) // L\u00ea a entrada e atribui a vari\u00e1vel \"guess\" . expect ( \"Failed to read line\" ); // Caso algo saia errado, mostra a mensagem // Converte a entrada para inteiro let guess : u32 = guess . trim (). parse (). expect ( \" \\n\\n >>>> Please type a integer number! <<<< \\n\\n \" ); println! ( \"You guessed: {guess}\" ); //Mostra a entrada do usu\u00e1rio // Compara e informa se o n\u00famero \u00e9 menor, maior ou igual match guess . cmp ( & secret_number ) { Ordering :: Less => println! ( \"Too small!\" ), Ordering :: Greater => println! ( \"Too big!\" ), Ordering :: Equal => { println! ( \"You win!\" ); break ; } } } } Tratando Erros Caso a entrada do usu\u00e1rio n\u00e3o seja exatamente um inteiro, ocorre um crash no jogo. Vou adicionar um tratamento para lidar com esse problema. src/main.rs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 // Baseado no exemplo do pr\u00f3prio livro, com algumas modifica\u00e7\u00f5es use std :: io ; //Lib para tratar de I/O use rand :: Rng ; //Lib para gerar n\u00fameros rand\u00f4micos use std :: cmp :: Ordering ; //Lib para fazer compara\u00e7\u00e3o fn main () { // Gera um n\u00famero inteiro de 0 a 100 let secret_number = rand :: thread_rng (). gen_range ( 1 ..= 100 ); println! ( \"The secret number is: {secret_number}\" ); loop { // Observe o termo \"mut\", pois essa vari\u00e1vel // ser\u00e1 alterada com a entrada do usu\u00e1rio let mut guess = String :: new (); io :: stdin () . read_line ( & mut guess ) // L\u00ea a entrada e atribui a vari\u00e1vel \"guess\" . expect ( \"Failed to read line\" ); // Caso algo saia errado, mostra a mensagem // Converte a entrada para inteiro let guess : u32 = match guess . trim (). parse () { Ok ( num ) => num , Err ( _ ) => { println! ( \"Entrada Inv\u00e1lido\" ); continue ; } }; println! ( \"You guessed: {guess}\" ); //Mostra a entrada do usu\u00e1rio // Compara e informa se o n\u00famero \u00e9 menor, maior ou igual match guess . cmp ( & secret_number ) { Ordering :: Less => println! ( \"Too small!\" ), Ordering :: Greater => println! ( \"Too big!\" ), Ordering :: Equal => { println! ( \"You win!\" ); break ; } } } } Conclus\u00e3o Criar o jogo introduziu o conceito de match , loop , mut e Crate . Que s\u00e3o b\u00e1sicos na linguagem.","title":"Adivinha\u00e7\u00e3o"},{"location":"Linguagens/Rust/Cap2/#adivinhacao","text":"","title":"Adivinha\u00e7\u00e3o"},{"location":"Linguagens/Rust/Cap2/#introducao","text":"Dando continuidade ao conhecimento do Rust , vamos ao cap\u00edtulo 2 do livro: The Rust Programming Language Ele prop\u00f5em introduzir alguns conceitos comuns da linguagem, criando o jogo da adivinha\u00e7\u00e3o","title":"Introdu\u00e7\u00e3o"},{"location":"Linguagens/Rust/Cap2/#configurando-o-projeto","text":"Criei um novo projeto utilizando o Cargo : cargo new adivinhacao","title":"Configurando o Projeto"},{"location":"Linguagens/Rust/Cap2/#comecando-o-jogo","text":"Vou dividir em alguns passos para facilitar o passo a passo da cria\u00e7\u00e3o do jogo. Para compilar o programa utilizei o cargo build e para executar cargo run .","title":"Come\u00e7ando o Jogo"},{"location":"Linguagens/Rust/Cap2/#input","text":"O primeiro passo \u00e9 saber como fazer um input do usu\u00e1rio. Para isso, segue o c\u00f3digo abaixo: src/main.rs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // Baseado no exemplo do pr\u00f3prio livo, com algumas modifica\u00e7\u00f5es use std :: io ; //Lib para tratar de I/O fn main () { // Observe o termo \"mut\", pois essa vari\u00e1vel // ser\u00e1 alterada com a entrada do usu\u00e1rio let mut guess = String :: new (); io :: stdin () . read_line ( & mut guess ) // L\u00ea a entrada e atribui a vari\u00e1vel \"guess\" . expect ( \"Failed to read line\" ); // Caso algo saia errado, mostra a mensagem println! ( \"You guessed: {guess}\" ); //Mostra a entrada do usu\u00e1rio }","title":"Input"},{"location":"Linguagens/Rust/Cap2/#numeros-aleatorios","text":"O Rust n\u00e3o possui a gera\u00e7\u00e3o de n\u00fameros aleat\u00f3rios em sua biblioteca padr\u00e3o. Com isso, usei o rand dispon\u00edvel no crate . Para isso, \u00e9 necess\u00e1rio adicionar a biblioteca no arquivo Cargo.toml : [dependencies] rand = \"0.8.3\" Agora utilize o comando cargo build para instalar a depend\u00eancia. Voltando ao c\u00f3digo, vamos adicionar biblioteca e a fun\u00e7\u00e3o que gera os n\u00fameros: src/main.rs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // Baseado no exemplo do pr\u00f3prio livro, com algumas modifica\u00e7\u00f5es use std :: io ; //Lib para tratar de I/O use rand :: Rng ; //Lib para gerar n\u00fameros rand\u00f4micos fn main () { // Gera um n\u00famero inteiro de 0 a 100 let secret_number = rand :: thread_rng (). gen_range ( 1 ..= 100 ); println! ( \"The secret number is: {secret_number}\" ); // Observe o termo \"mut\", pois essa vari\u00e1vel // ser\u00e1 alterada com a entrada do usu\u00e1rio let mut guess = String :: new (); io :: stdin () . read_line ( & mut guess ) // L\u00ea a entrada e atribui a vari\u00e1vel \"guess\" . expect ( \"Failed to read line\" ); // Caso algo saia errado, mostra a mensagem println! ( \"You guessed: {guess}\" ); //Mostra a entrada do usu\u00e1rio }","title":"N\u00fameros Aleat\u00f3rios"},{"location":"Linguagens/Rust/Cap2/#comparando","text":"Uma vez que a entrada do usu\u00e1rio e o n\u00famero rand\u00f4mico est\u00e3o dispon\u00edveis, s\u00f3 resta fazer a compara\u00e7\u00e3o entre os dois e checar se \u00e9 menor, maior ou igual. src/main.rs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // Baseado no exemplo do pr\u00f3prio livro, com algumas modifica\u00e7\u00f5es use std :: io ; //Lib para tratar de I/O use rand :: Rng ; //Lib para gerar n\u00fameros rand\u00f4micos use std :: cmp :: Ordering ; //Lib para fazer compara\u00e7\u00e3o fn main () { // Gera um n\u00famero inteiro de 0 a 100 let secret_number = rand :: thread_rng (). gen_range ( 1 ..= 100 ); println! ( \"The secret number is: {secret_number}\" ); // Observe o termo \"mut\", pois essa vari\u00e1vel // ser\u00e1 alterada com a entrada do usu\u00e1rio let mut guess = String :: new (); io :: stdin () . read_line ( & mut guess ) // L\u00ea a entrada e atribui a vari\u00e1vel \"guess\" . expect ( \"Failed to read line\" ); // Caso algo saia errado, mostra a mensagem // Converte a entrada para inteiro let guess : u32 = guess . trim (). parse (). expect ( \" \\n\\n >>>> Please type a integer number! <<<< \\n\\n \" ); println! ( \"You guessed: {guess}\" ); //Mostra a entrada do usu\u00e1rio // Compara e informa se o n\u00famero \u00e9 menor, maior ou igual match guess . cmp ( & secret_number ) { Ordering :: Less => println! ( \"Too small!\" ), Ordering :: Greater => println! ( \"Too big!\" ), Ordering :: Equal => println! ( \"You win!\" ), } }","title":"Comparando"},{"location":"Linguagens/Rust/Cap2/#tentando-novamente","text":"At\u00e9 agora o jogo s\u00f3 permite apenas uma tentativa ( try hard ). Agora vou adicionar o loop para fazer v\u00e1rias tentativas. src/main.rs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 // Baseado no exemplo do pr\u00f3prio livro, com algumas modifica\u00e7\u00f5es use std :: io ; //Lib para tratar de I/O use rand :: Rng ; //Lib para gerar n\u00fameros rand\u00f4micos use std :: cmp :: Ordering ; //Lib para fazer compara\u00e7\u00e3o fn main () { // Gera um n\u00famero inteiro de 0 a 100 let secret_number = rand :: thread_rng (). gen_range ( 1 ..= 100 ); println! ( \"The secret number is: {secret_number}\" ); loop { // Observe o termo \"mut\", pois essa vari\u00e1vel // ser\u00e1 alterada com a entrada do usu\u00e1rio let mut guess = String :: new (); io :: stdin () . read_line ( & mut guess ) // L\u00ea a entrada e atribui a vari\u00e1vel \"guess\" . expect ( \"Failed to read line\" ); // Caso algo saia errado, mostra a mensagem // Converte a entrada para inteiro let guess : u32 = guess . trim (). parse (). expect ( \" \\n\\n >>>> Please type a integer number! <<<< \\n\\n \" ); println! ( \"You guessed: {guess}\" ); //Mostra a entrada do usu\u00e1rio // Compara e informa se o n\u00famero \u00e9 menor, maior ou igual match guess . cmp ( & secret_number ) { Ordering :: Less => println! ( \"Too small!\" ), Ordering :: Greater => println! ( \"Too big!\" ), Ordering :: Equal => println! ( \"You win!\" ), } } }","title":"Tentando Novamente"},{"location":"Linguagens/Rust/Cap2/#ganhando","text":"Mesmo digitando o n\u00famero correto, o jogo ainda permite fazer uma nova tentativa. Vou adicionar um break quando o n\u00famero digitado for o correto. src/main.rs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 // Baseado no exemplo do pr\u00f3prio livro, com algumas modifica\u00e7\u00f5es use std :: io ; //Lib para tratar de I/O use rand :: Rng ; //Lib para gerar n\u00fameros rand\u00f4micos use std :: cmp :: Ordering ; //Lib para fazer compara\u00e7\u00e3o fn main () { // Gera um n\u00famero inteiro de 0 a 100 let secret_number = rand :: thread_rng (). gen_range ( 1 ..= 100 ); println! ( \"The secret number is: {secret_number}\" ); loop { // Observe o termo \"mut\", pois essa vari\u00e1vel // ser\u00e1 alterada com a entrada do usu\u00e1rio let mut guess = String :: new (); io :: stdin () . read_line ( & mut guess ) // L\u00ea a entrada e atribui a vari\u00e1vel \"guess\" . expect ( \"Failed to read line\" ); // Caso algo saia errado, mostra a mensagem // Converte a entrada para inteiro let guess : u32 = guess . trim (). parse (). expect ( \" \\n\\n >>>> Please type a integer number! <<<< \\n\\n \" ); println! ( \"You guessed: {guess}\" ); //Mostra a entrada do usu\u00e1rio // Compara e informa se o n\u00famero \u00e9 menor, maior ou igual match guess . cmp ( & secret_number ) { Ordering :: Less => println! ( \"Too small!\" ), Ordering :: Greater => println! ( \"Too big!\" ), Ordering :: Equal => { println! ( \"You win!\" ); break ; } } } }","title":"Ganhando"},{"location":"Linguagens/Rust/Cap2/#tratando-erros","text":"Caso a entrada do usu\u00e1rio n\u00e3o seja exatamente um inteiro, ocorre um crash no jogo. Vou adicionar um tratamento para lidar com esse problema. src/main.rs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 // Baseado no exemplo do pr\u00f3prio livro, com algumas modifica\u00e7\u00f5es use std :: io ; //Lib para tratar de I/O use rand :: Rng ; //Lib para gerar n\u00fameros rand\u00f4micos use std :: cmp :: Ordering ; //Lib para fazer compara\u00e7\u00e3o fn main () { // Gera um n\u00famero inteiro de 0 a 100 let secret_number = rand :: thread_rng (). gen_range ( 1 ..= 100 ); println! ( \"The secret number is: {secret_number}\" ); loop { // Observe o termo \"mut\", pois essa vari\u00e1vel // ser\u00e1 alterada com a entrada do usu\u00e1rio let mut guess = String :: new (); io :: stdin () . read_line ( & mut guess ) // L\u00ea a entrada e atribui a vari\u00e1vel \"guess\" . expect ( \"Failed to read line\" ); // Caso algo saia errado, mostra a mensagem // Converte a entrada para inteiro let guess : u32 = match guess . trim (). parse () { Ok ( num ) => num , Err ( _ ) => { println! ( \"Entrada Inv\u00e1lido\" ); continue ; } }; println! ( \"You guessed: {guess}\" ); //Mostra a entrada do usu\u00e1rio // Compara e informa se o n\u00famero \u00e9 menor, maior ou igual match guess . cmp ( & secret_number ) { Ordering :: Less => println! ( \"Too small!\" ), Ordering :: Greater => println! ( \"Too big!\" ), Ordering :: Equal => { println! ( \"You win!\" ); break ; } } } }","title":"Tratando Erros"},{"location":"Linguagens/Rust/Cap2/#conclusao","text":"Criar o jogo introduziu o conceito de match , loop , mut e Crate . Que s\u00e3o b\u00e1sicos na linguagem.","title":"Conclus\u00e3o"},{"location":"RTOS/zephyr/zephyr/","text":"Zephyr + Esp32 + Blinky = \u2764\ufe0f Image by methodshop from Pixabay Introdu\u00e7\u00e3o Recentemente voltei a pesquisar sobre Internet of Things (IoT) e durante uma conversas no trabalho fiquei sabendo do Zephyr. Por sorte, um Webnar da Embarcados aconteceu e pude me interar mais sobre essa plataforma. S\u00f3 tenho uma palavra para definir: Sensacional \ud83e\udd2f Instalando depend\u00eancias Estou usando Ubuntu 22.04 . sudo apt install --no-install-recommends git cmake ninja-build gperf \\ ccache dfu-util device-tree-compiler wget \\ python3-dev python3-pip python3-setuptools python3-tk python3-wheel xz-utils file \\ make gcc gcc-multilib g++-multilib libsdl2-dev O Zephyr usa o python para gerenciar os pacotes, algumas depend\u00eancias tamb\u00e9m s\u00e3o necess\u00e1rias pip3 install west Ap\u00f3s isso, \u00e9 necess\u00e1rio definir o local onde os arquivos ser\u00e3o salvos. No exemplo vou usar o caminho /home/jao/Documents/Workspace/IoT west init /home/jao/Documents/Workspace/IoT/PASTA_DO_ZEPHYR Alguns arquivos ser\u00e3o baixados do reposit\u00f3rio . Em seguida: PS: Demora... cd /home/jao/Documents/Workspace/IoT/PASTA_DO_ZEPHYR west update Depois de terminar a atualiza\u00e7\u00e3o, \u00e9 necess\u00e1rio exportar algumas vari\u00e1veis de ambiente: west zephyr-export e ent\u00e3o instalar as dep\u00eancencias restantes do python: pip3 install -r /home/jao/Documents/Workspace/IoT/PASTA_DO_ZEPHYR/zephyr/scripts/requirements.txt Baixando a toolchain Como vamos utilizar o Esp32, a toolchain pode ser baixada aqui . No meu caso estou usando a plataforma linux-amd64 Ap\u00f3s baixar a toolchain correto, extraia e adicione o caminho da pasta a vari\u00e1vel de ambiente ESPRESSIF_TOOLCHAIN_PATH export ESPRESSIF_TOOLCHAIN_PATH=/home/jao/Documents/Workspace/IoT/xtensa-esp32-elf/xtensa-esp32-elf/ \u00c9 necess\u00e1rio adicionar outra vari\u00e1vel: export ZEPHYR_TOOLCHAIN_VARIANT=\"espressif\" Finalmente, podemos baixar os pacotes referentes ao Esp32 do Zephyr: PS: O camando deve ser dado dentro da pasta do Zephyr, no caso: /home/jao/Documents/Workspace/IoT/PASTA_DO_ZEPHYR west espressif update Ap\u00f3s esse passo, o ambiente de configura\u00e7\u00e3o para o Esp32 estar\u00e1 finalizado. Exemplo Blinky Na vers\u00e3o atual do Zephyr 3.0.0 , \u00e9 necess\u00e1rio adicionar um m\u00f3dulo no device driver para que o led built-in sej\u00e1 reconhecido. Para isso, \u00e9 necess\u00e1rio criar um arquivo dentro do exemplo do Blincky do pr\u00f3prio Zephyr touch /home/jao/Documents/Workspace/IoT/PASTA_DO_ZEPHYR/zephyr/samples/basic/blinky/esp32.overlay o arquivo deve conter o seguinte conte\u00fado: / { aliases { led0 = &led0; }; leds { compatible = \"gpio-leds\"; led0: led_0 { gpios = <&gpio0 2 GPIO_ACTIVE_HIGH>; label = \"LED 0\"; }; }; }; Na linha gpios = <&gpio0 2 GPIO_ACTIVE_HIGH>; , o n\u00famero 2 \u00e9 referente ao gpio associado ao led built-in . Agora \u00e9 s\u00f3 compilar: PS: dentro da pasta: /home/jao/Documents/Workspace/IoT/PASTA_DO_ZEPHYR/ west build -p auto -b esp32 zephyr/samples/basic/blinky Muitas vezes o arquivo CMakeCache.txt, precisa ser deletado. Ele fica localizado em : /home/jao/Documents/Workspace/IoT/PASTA_DO_ZEPHYR/build/ Se tudo ocorrer bem, a seguinte mensagem deve aparecer: [103/103] Linking C executable zephyr/zephyr.elf Memory region Used Size Region Size %age Used mcuboot_hdr: 32 B 32 B 100.00% metadata: 28 B 32 B 87.50% ROM: 31172 B 4194240 B 0.74% iram0_0_seg: 13004 B 128 KB 9.92% irom0_0_seg: 13692 B 3342304 B 0.41% dram0_0_seg: 1240 B 180736 B 0.69% dram0_1_seg: 53 KB 110032 B 49.32% drom0_0_seg: 3826 B 4194240 B 0.09% rtc_iram_seg: 0 GB 8 KB 0.00% rtc_slow_seg: 0 GB 4 KB 0.00% IDT_LIST: 0 GB 8 KB 0.00% esptool.py v3.3-dev Creating esp32 image... Merged 6 ELF sections Successfully created esp32 image. Para flashar no esp32, pasta digitar o seguinte comando: west flash O resultado deve ser algo semelhante: Flash will be erased from 0x00010000 to 0x00033fff... Flash params set to 0x0220 Wrote 32768 bytes at 0x00001000 in 0.7 seconds (390.4 kbit/s)... Hash of data verified. Wrote 16384 bytes at 0x00008000 in 0.3 seconds (515.8 kbit/s)... Hash of data verified. Wrote 147456 bytes at 0x00010000 in 2.0 seconds (594.7 kbit/s)... Hash of data verified. Leaving... Hard resetting via RTS pin... Se o seguinte erro acontecer: /dev/ttyS0 failed to connect: Failed to connect to Espressif device: No serial data received. For troubleshooting steps visit: https://docs.espressif.com/projects/esptool/en/latest/troubleshooting.html A fatal error occurred: Could not connect to an Espressif device on any of the 2 available serial ports. Talvez seja necess\u00e1rio ficar segurando o bot\u00e3o boot do Esp32. \u00c9 isso, at\u00e9 a pr\u00f3xima.","title":"Zephyr + Esp32 + Blinky = \u2764\ufe0f"},{"location":"RTOS/zephyr/zephyr/#zephyr-esp32-blinky","text":"Image by methodshop from Pixabay","title":"Zephyr + Esp32 + Blinky = \u2764\ufe0f"},{"location":"RTOS/zephyr/zephyr/#introducao","text":"Recentemente voltei a pesquisar sobre Internet of Things (IoT) e durante uma conversas no trabalho fiquei sabendo do Zephyr. Por sorte, um Webnar da Embarcados aconteceu e pude me interar mais sobre essa plataforma. S\u00f3 tenho uma palavra para definir: Sensacional \ud83e\udd2f","title":"Introdu\u00e7\u00e3o"},{"location":"RTOS/zephyr/zephyr/#instalando-dependencias","text":"Estou usando Ubuntu 22.04 . sudo apt install --no-install-recommends git cmake ninja-build gperf \\ ccache dfu-util device-tree-compiler wget \\ python3-dev python3-pip python3-setuptools python3-tk python3-wheel xz-utils file \\ make gcc gcc-multilib g++-multilib libsdl2-dev O Zephyr usa o python para gerenciar os pacotes, algumas depend\u00eancias tamb\u00e9m s\u00e3o necess\u00e1rias pip3 install west Ap\u00f3s isso, \u00e9 necess\u00e1rio definir o local onde os arquivos ser\u00e3o salvos. No exemplo vou usar o caminho /home/jao/Documents/Workspace/IoT west init /home/jao/Documents/Workspace/IoT/PASTA_DO_ZEPHYR Alguns arquivos ser\u00e3o baixados do reposit\u00f3rio . Em seguida: PS: Demora... cd /home/jao/Documents/Workspace/IoT/PASTA_DO_ZEPHYR west update Depois de terminar a atualiza\u00e7\u00e3o, \u00e9 necess\u00e1rio exportar algumas vari\u00e1veis de ambiente: west zephyr-export e ent\u00e3o instalar as dep\u00eancencias restantes do python: pip3 install -r /home/jao/Documents/Workspace/IoT/PASTA_DO_ZEPHYR/zephyr/scripts/requirements.txt","title":"Instalando depend\u00eancias"},{"location":"RTOS/zephyr/zephyr/#baixando-a-toolchain","text":"Como vamos utilizar o Esp32, a toolchain pode ser baixada aqui . No meu caso estou usando a plataforma linux-amd64 Ap\u00f3s baixar a toolchain correto, extraia e adicione o caminho da pasta a vari\u00e1vel de ambiente ESPRESSIF_TOOLCHAIN_PATH export ESPRESSIF_TOOLCHAIN_PATH=/home/jao/Documents/Workspace/IoT/xtensa-esp32-elf/xtensa-esp32-elf/ \u00c9 necess\u00e1rio adicionar outra vari\u00e1vel: export ZEPHYR_TOOLCHAIN_VARIANT=\"espressif\" Finalmente, podemos baixar os pacotes referentes ao Esp32 do Zephyr: PS: O camando deve ser dado dentro da pasta do Zephyr, no caso: /home/jao/Documents/Workspace/IoT/PASTA_DO_ZEPHYR west espressif update Ap\u00f3s esse passo, o ambiente de configura\u00e7\u00e3o para o Esp32 estar\u00e1 finalizado.","title":"Baixando a toolchain"},{"location":"RTOS/zephyr/zephyr/#exemplo-blinky","text":"Na vers\u00e3o atual do Zephyr 3.0.0 , \u00e9 necess\u00e1rio adicionar um m\u00f3dulo no device driver para que o led built-in sej\u00e1 reconhecido. Para isso, \u00e9 necess\u00e1rio criar um arquivo dentro do exemplo do Blincky do pr\u00f3prio Zephyr touch /home/jao/Documents/Workspace/IoT/PASTA_DO_ZEPHYR/zephyr/samples/basic/blinky/esp32.overlay o arquivo deve conter o seguinte conte\u00fado: / { aliases { led0 = &led0; }; leds { compatible = \"gpio-leds\"; led0: led_0 { gpios = <&gpio0 2 GPIO_ACTIVE_HIGH>; label = \"LED 0\"; }; }; }; Na linha gpios = <&gpio0 2 GPIO_ACTIVE_HIGH>; , o n\u00famero 2 \u00e9 referente ao gpio associado ao led built-in . Agora \u00e9 s\u00f3 compilar: PS: dentro da pasta: /home/jao/Documents/Workspace/IoT/PASTA_DO_ZEPHYR/ west build -p auto -b esp32 zephyr/samples/basic/blinky Muitas vezes o arquivo CMakeCache.txt, precisa ser deletado. Ele fica localizado em : /home/jao/Documents/Workspace/IoT/PASTA_DO_ZEPHYR/build/ Se tudo ocorrer bem, a seguinte mensagem deve aparecer: [103/103] Linking C executable zephyr/zephyr.elf Memory region Used Size Region Size %age Used mcuboot_hdr: 32 B 32 B 100.00% metadata: 28 B 32 B 87.50% ROM: 31172 B 4194240 B 0.74% iram0_0_seg: 13004 B 128 KB 9.92% irom0_0_seg: 13692 B 3342304 B 0.41% dram0_0_seg: 1240 B 180736 B 0.69% dram0_1_seg: 53 KB 110032 B 49.32% drom0_0_seg: 3826 B 4194240 B 0.09% rtc_iram_seg: 0 GB 8 KB 0.00% rtc_slow_seg: 0 GB 4 KB 0.00% IDT_LIST: 0 GB 8 KB 0.00% esptool.py v3.3-dev Creating esp32 image... Merged 6 ELF sections Successfully created esp32 image. Para flashar no esp32, pasta digitar o seguinte comando: west flash O resultado deve ser algo semelhante: Flash will be erased from 0x00010000 to 0x00033fff... Flash params set to 0x0220 Wrote 32768 bytes at 0x00001000 in 0.7 seconds (390.4 kbit/s)... Hash of data verified. Wrote 16384 bytes at 0x00008000 in 0.3 seconds (515.8 kbit/s)... Hash of data verified. Wrote 147456 bytes at 0x00010000 in 2.0 seconds (594.7 kbit/s)... Hash of data verified. Leaving... Hard resetting via RTS pin... Se o seguinte erro acontecer: /dev/ttyS0 failed to connect: Failed to connect to Espressif device: No serial data received. For troubleshooting steps visit: https://docs.espressif.com/projects/esptool/en/latest/troubleshooting.html A fatal error occurred: Could not connect to an Espressif device on any of the 2 available serial ports. Talvez seja necess\u00e1rio ficar segurando o bot\u00e3o boot do Esp32. \u00c9 isso, at\u00e9 a pr\u00f3xima.","title":"Exemplo Blinky"}]}
{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>A ideia do blog \u00e9 reunir os aprendizados relacionados a sistemas embarcados. Com foco em bootloader, kernel e Root Filesystem.</p> <p>ps: Mas com algumas coisas de Android embarcado e RTOS :)</p> <p>Placas:</p> <ul> <li>Beaglebone</li> <li>VIM3</li> <li>QEMU (virtual)</li> </ul> <p>Microcontroladores:</p> <ul> <li>Pi pico</li> <li>ESP32</li> </ul> <p>The goal of this blog is to gather learnings about embedded systems, focused in:</p> <ul> <li>Bootloader: U-boot, LittleKernel</li> <li>Kernel Linux: mainline</li> <li>Mininal RFS: Busybox, Dropbear</li> </ul> <p>Boards used in this journey until now:</p> <ul> <li>Beaglebone</li> <li>VIM3</li> <li>QEMU (virtual)</li> </ul> <p>MCUs:   - Pi Pico   - ESP32</p> <p>This blog is written in PT-BR because I want to help to disseminate embedded system in Brazil.</p>"},{"location":"android/boards/qemu/hal/aidl/","title":"Implementando a AIDL","text":"Image by methodshop from Pixabay <p>Baseado no curso: Android 12 Internals material, labs and discussion</p>"},{"location":"android/boards/qemu/hal/aidl/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>A partir do Android 12, novas Hardware Abstraction Layer (HAL) passam a ser obrigatoriamente implementadas utilizando Android Interface Definition Language (AIDL). Por isso, criei esse post.</p>"},{"location":"android/boards/qemu/hal/aidl/#implementacao","title":"Implementa\u00e7\u00e3o","text":"<p>Vou tentar dividir em alguns t\u00f3picos para facilitar.</p>"},{"location":"android/boards/qemu/hal/aidl/#hal","title":"HAL","text":"<p>Na pasta raiz do AOSP, criei o seguinte caminho:</p> <pre><code>mkdir -p device/casa/emulator/interfaces/foo/aidl/\n</code></pre> <p>Dentro da pasta, criei o seguinte arquivo:</p> Android.bp<pre><code>aidl_interface {\n    name: \"mypackage.mysubpackage.fooAIDL\",\n    vendor: true,\n    srcs: [\"mypackage/mysubpackage/fooAIDL/*.aidl\"],\n    stability: \"vintf\",\n    owner: \"CASA\",\n    backend: {\n        cpp: {\n            enabled: true,\n        },\n        java: {\n            sdk_version: \"module_current\",\n        },\n    },\n}\n</code></pre> <p>ainda dentro da pasta, criei o seguinte caminho:</p> <pre><code>mkdir -p mypackage/mysubpackage/fooAIDL/\n</code></pre> <p>com o seguinte arquivo:</p> ITest.aidl<pre><code>package mypackage.mysubpackage.fooAIDL;\n\n@VintfStability\ninterface ITest {\n    String getTest();\n    boolean setTest(in String param);\n}\n</code></pre> <p>O resultado foi esse:</p> <pre><code>device/casa/emulator/interfaces/foo/aidl\n\u251c\u2500\u2500 Android.bp\n\u2514\u2500\u2500 mypackage\n    \u2514\u2500\u2500 mysubpackage\n        \u2514\u2500\u2500 fooAIDL\n            \u2514\u2500\u2500 ITest.aidl\n</code></pre> <p>Agora no arquivo do produto, no meu caso:</p> emulator.mk<pre><code>...\nPRODUCT_PACKAGES += \\\n    mypackage.mysubpackage.fooAIDL \\\n</code></pre> <p>Na pasta raiz do AOSP, digite:</p> <p><pre><code>m mypackage.mysubpackage.fooAIDL-update-api\n</code></pre> Esse comando vai gerar a pasta <code>aidl_api</code>:</p> <pre><code>device/casa/emulator/interfaces/foo/aidl\n\u251c\u2500\u2500 aidl_api\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 mypackage.mysubpackage.fooAIDL\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 current\n\u2502\u00a0\u00a0         \u2514\u2500\u2500 mypackage\n\u2502\u00a0\u00a0             \u2514\u2500\u2500 mysubpackage\n\u2502\u00a0\u00a0                 \u2514\u2500\u2500 fooAIDL\n\u2502\u00a0\u00a0                     \u2514\u2500\u2500 ITest.aidl\n\u251c\u2500\u2500 Android.bp\n\u2514\u2500\u2500 mypackage\n    \u2514\u2500\u2500 mysubpackage\n        \u2514\u2500\u2500 fooAIDL\n            \u2514\u2500\u2500 ITest.aidl\n</code></pre> <p>Esse comando faz uma esp\u00e9cie de versionamento da AIDL.</p> <p>Agora dentro da pasta <code>device/casa/emulator/interfaces/foo/aidl</code>, digite o comando:</p> <pre><code>mm\n</code></pre> <p>Ela ir\u00e1 gerar as classes necess\u00e1rias dentro da pasta :</p> <pre><code>out/soong/.intermediates/device/casa/emulator/interfaces/foo/aidl\n\u251c\u2500\u2500 mypackage.mysubpackage.fooAIDL-api\n\u251c\u2500\u2500 mypackage.mysubpackage.fooAIDL-V1-cpp\n\u251c\u2500\u2500 mypackage.mysubpackage.fooAIDL-V1-cpp-source\n\u251c\u2500\u2500 mypackage.mysubpackage.fooAIDL-V1-java\n\u251c\u2500\u2500 mypackage.mysubpackage.fooAIDL-V1-java-source\n\u251c\u2500\u2500 mypackage.mysubpackage.fooAIDL-V1-ndk\n\u251c\u2500\u2500 mypackage.mysubpackage.fooAIDL-V1-ndk_platform\n\u251c\u2500\u2500 mypackage.mysubpackage.fooAIDL-V1-ndk_platform-source\n\u2514\u2500\u2500 mypackage.mysubpackage.fooAIDL-V1-ndk-source\n</code></pre>"},{"location":"android/boards/qemu/hal/aidl/#servico","title":"Servi\u00e7o","text":"<p>Criei a pasta <code>device/casa/emulator/interfaces/foo/aidl/default/</code>, e dentro dela os arquivos:</p> Test.h<pre><code>#pragma once\n\n// Mesmo caminho ap\u00f3s:\n// mypackage.mysubpackage.fooAIDL-V1-ndk_platform-source/gen/include/\n// dentro da pasta : \n// out/soong/.intermediates/device/casa/emulator/interfaces/foo/aidl\n#include &lt;aidl/mypackage/mysubpackage/fooAIDL/BnTest.h&gt;\n\nnamespace aidl::mypackage::mysubpackage::fooAIDL {\n\nclass Test : public BnTest {\n  public:\n    ndk::ScopedAStatus getTest(std::string* _aidl_return) override;\n    ndk::ScopedAStatus setTest(const std::string&amp; in_param, bool* _aidl_return) override;\n};\n\n}  // namespace aidl::mypackage::mysubpackage::fooAIDL\n</code></pre> Test.cpp<pre><code>#include \"Test.h\"\n\n#include &lt;utils/Log.h&gt;\n#include &lt;sys/stat.h&gt;\n\nnamespace aidl::mypackage::mysubpackage::fooAIDL {\n\n// conservative|powersave|performance|schedutil\nstatic const char SCALING_GOVERNOR[] = \\\n        \"/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor\";\n\nstatic int write_value(const char *file, const char *value)\n{\n    int to_write, written, ret, fd;\n\n    fd = TEMP_FAILURE_RETRY(open(file, O_WRONLY));\n    if (fd &lt; 0) {\n        return -1;\n    }\n\n    to_write = strlen(value) + 1;\n    written = TEMP_FAILURE_RETRY(write(fd, value, to_write));\n    if (written == -1) {\n        ret = -2;\n    } else if (written != to_write) {\n        ret = -3;\n    } else {\n        ret = 0;\n    }\n\n    errno = 0;\n    close(fd);\n\n    return ret;\n}\n\nndk::ScopedAStatus Test::getTest(std::string* _aidl_return) {\n    char str[20];\n    int fd;\n    ssize_t ret = 0;\n    struct stat info;\n    void *data = NULL;\n    size_t size;\n\n    // If open returns error code EINTR, retry again until error code\n    // is not a temporary failure\n    fd = TEMP_FAILURE_RETRY(open(SCALING_GOVERNOR, O_RDONLY));\n    if (fd &lt; 0) {\n        ndk::ScopedAStatus::fromServiceSpecificError(-1);\n    }\n\n    fstat(fd, &amp;info);\n    size = info.st_size;\n    data = malloc(size);\n    if (data == NULL) {\n        *_aidl_return = \"error can't malloc\";\n        goto exit;\n    }\n\n    ret = read(fd, data, size);\n    if (ret &lt; 0) {\n        *_aidl_return = \"error reading fd\";\n        goto exit;\n    }\n\n    snprintf(str, sizeof(str), \"%s\", (const unsigned char*)data);\n    ALOGI(\"Test AIDL::getTest data=(%s)\", str);\n    *_aidl_return = str;\n\nexit:\n    close(fd);\n    free(data);\n    return ndk::ScopedAStatus::ok();\n}\n\nndk::ScopedAStatus Test::setTest(const std::string&amp; in_param, bool* _aidl_return) {\n    ALOGI(\"Test AIDL::setTest data=(%s)\", in_param.c_str());\n    *_aidl_return = write_value(SCALING_GOVERNOR, in_param.c_str()) == 0;\n    return ndk::ScopedAStatus::ok();\n}\n\n}  // namespace aidl::vendor::eightman::cpu\n</code></pre> service.cpp<pre><code>#define LOG_TAG \"mypackage.mysubpackage.fooAIDL-service\"\n\n#include &lt;android-base/logging.h&gt;\n#include &lt;android/binder_process.h&gt;\n#include &lt;binder/ProcessState.h&gt;\n\n#include &lt;android/binder_manager.h&gt;\n#include &lt;binder/IServiceManager.h&gt;\n\n#include \"Test.h\"\n\nusing aidl::mypackage::mysubpackage::fooAIDL::Test;\nusing std::string_literals::operator\"\"s;\n\nint main() {\n    // Enable vndbinder to allow vendor-to-vendor binder calls.\n    android::ProcessState::initWithDriver(\"/dev/vndbinder\");\n\n    ABinderProcess_startThreadPool();\n\n    LOG(INFO) &lt;&lt; \"Test aidl service for fooAIDL is starting.,,\";\n\n    std::shared_ptr&lt;Test&gt; test = ndk::SharedRefBase::make&lt;Test&gt;();\n    const std::string name = Test::descriptor + \"/default\"s;\n    CHECK_EQ(STATUS_OK, AServiceManager_addService(test-&gt;asBinder().get(), name.c_str()));\n\n    LOG(INFO) &lt;&lt; \"Initialized fooAIDL cpu\";\n\n    ABinderProcess_joinThreadPool();\n\n    return EXIT_FAILURE;  // should not reach\n}\n</code></pre> Android.bp<pre><code>cc_binary {\n    name: \"mypackage.mysubpackage.fooAIDL-service\",\n    vendor: true,\n    relative_install_path: \"hw\",\n    init_rc: [\"mypackage.mysubpackage.fooAIDL-service.rc\"],\n    vintf_fragments: [\"mypackage.mysubpackage.fooAIDL-service.xml\"],\n\n    srcs: [\n        \"service.cpp\",\n        \"Test.cpp\"\n    ],\n\n    cflags: [\n        \"-Wall\",\n        \"-Werror\",\n    ],\n\n    shared_libs: [\n        \"libbase\",\n        \"liblog\",\n        \"libhardware\",\n        \"libbinder_ndk\",\n        \"libbinder\",\n        \"libutils\",\n        \"mypackage.mysubpackage.fooAIDL-V1-ndk_platform\",\n    ],\n}\n</code></pre> mypackage.mysubpackage.fooAIDL-service.rc<pre><code>service mypackage.mysubpackage.fooAIDL-service /vendor/bin/hw/mypackage.mysubpackage.fooAIDL-service\n    interface aidl mypackage.mysubpackage.fooAIDL-service.ITest/default\n    class hal\n    user system\n    group system\n\non boot\n    chown system system /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor\n    chmod 0660 /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor\n</code></pre> mypackage.mysubpackage.fooAIDL-service.xml<pre><code>&lt;manifest version=\"1.0\" type=\"device\"&gt;\n    &lt;hal format=\"aidl\"&gt;\n        &lt;name&gt;mypackage.mysubpackage.fooAIDL&lt;/name&gt;\n        &lt;version&gt;1&lt;/version&gt;\n        &lt;fqname&gt;ITest/default&lt;/fqname&gt;\n    &lt;/hal&gt;\n&lt;/manifest&gt;\n</code></pre> <p>Agora s\u00f3 resta adicionar o servi\u00e7o no produto:</p> emulator.mk<pre><code>...\nPRODUCT_PACKAGES += \\\n    mypackage.mysubpackage.fooAIDL \\\n    mypackage.mysubpackage.fooAIDL-service\n</code></pre>"},{"location":"android/boards/qemu/hal/aidl/#permissoes","title":"Permiss\u00f5es","text":"<p>Rebuildando e checando o <code>dmesg</code>:</p> <pre><code>10-08 07:51:06.674     0     0 I init    : Parsing file /vendor/etc/init/mypackage.mysubpackage.fooAIDL-service.rc...\n10-08 07:51:10.482     0     0 E init    : Could not start service 'mypackage.mysubpackage.fooAIDL-service' as part of class 'hal': File /vendor/bin/hw/mypackage.mysubpackage.fooAIDL-service(labeled \"u:object_r:vendor_file:s0\") has incorrect label or no domain transition from u:r:init:s0 to another SELinux domain defined. Have you configured your service correctly? https://source.android.com/security/selinux/device-policy#label_new_services_and_address_denials. Note: this error shows up even in permissive mode in order to make auditing denials possible.\n10-08 07:51:10.560     0     0 I init    : processing action (boot) from (/vendor/etc/init/mypackage.mysubpackage.fooAIDL-service.rc:7)\n</code></pre> <p>Para resolver esse problema, criei uma pasta:</p> <pre><code>mkdir -p /device/casa/emulator/sepolicy\n</code></pre> <p>e dentro dela os arquivos:</p> file_contexts<pre><code>/vendor/bin/hw/mypackage\\.mysubpackage\\.fooAIDL-service         u:object_r:hal_fooAIDL_default_exec:s0\n</code></pre> hal_fooAIDL_default.te<pre><code>type hal_fooAIDL_default, domain;\ntype hal_fooAIDL_default_exec, exec_type, vendor_file_type, file_type;\n\ninit_daemon_domain(hal_fooAIDL_default);\n</code></pre> <p>Rebuildando e checando o <code>dmesg</code>:</p> <pre><code>10-08 08:11:08.392     0     0 I init    : starting service 'mypackage.mysubpackage.fooAIDL-service'...\n10-08 08:11:09.375  1932  1932 I mypackage.mysubpackage.fooAIDL-service: Test aidl service for fooAIDL is starting.,,\n10-08 08:11:09.369  1932  1932 W mypackage.mysub: type=1400 audit(0.0:20): avc: denied { read } for name=\"vndbinder\" dev=\"binder\" ino=6 scontext=u:r:hal_fooAIDL_default:s0 tcontext=u:object_r:vndbinder_device:s0 tclass=chr_file permissive=0\n10-08 08:11:09.369  1932  1932 W Binder:1932_2: type=1400 audit(0.0:21): avc: denied { call } for scontext=u:r:hal_fooAIDL_default:s0 tcontext=u:r:servicemanager:s0 tclass=binder permissive=0\n10-08 08:11:09.378  1932  1932 F mypackage.mysubpackage.fooAIDL-service: Check failed: STATUS_OK == AServiceManager_addService(test-&gt;asBinder().get(), name.c_str()) (STATUS_OK=0, AServiceManager_addService(test-&gt;asBinder().get(), name.c_str())=-129) \n10-08 08:11:09.373  1932  1932 W Binder:1932_2: type=1400 audit(0.0:22): avc: denied { call } for scontext=u:r:hal_fooAIDL_default:s0 tcontext=u:r:servicemanager:s0 tclass=binder permissive=0\n10-08 08:11:09.389  1937  1937 F DEBUG   : Cmdline: /vendor/bin/hw/mypackage.mysubpackage.fooAIDL-service\n10-08 08:11:09.389  1937  1937 F DEBUG   : pid: 1932, tid: 1932, name: Binder:1932_2  &gt;&gt;&gt; /vendor/bin/hw/mypackage.mysubpackage.fooAIDL-service &lt;&lt;&lt;\n10-08 08:11:09.390  1937  1937 F DEBUG   :       #03 pc 00000000000031a9  /vendor/bin/hw/mypackage.mysubpackage.fooAIDL-service (main+889) (BuildId: fdbc2fbc6416778b0057ade844657474)\n10-08 08:11:08.424     0     0 I init    : Service 'mypackage.mysubpackage.fooAIDL-service' (pid 1932) received signal 6\n10-08 08:11:08.424     0     0 I init    : Sending signal 9 to service 'mypackage.mysubpackage.fooAIDL-service' (pid 1932) process group...\n10-08 08:11:08.425     0     0 E init    : process with updatable components 'mypackage.mysubpackage.fooAIDL-service' exited 4 times in 4 minutes\n</code></pre> <p>Para resolver, criei os seguintes arquivos:</p> service_contexts<pre><code>mypackage.mysubpackage.fooAIDL.ITest/default          u:object_r:fooAIDL_service:s0\n</code></pre> service.te<pre><code>type fooAIDL_service, service_manager_type, vendor_service;\n</code></pre> <p>e adicionando essas configura\u00e7\u00f5es no arquivo:</p> hal_fooAIDL_default.te<pre><code>type hal_fooAIDL_default, domain;\ntype hal_fooAIDL_default_exec, exec_type, vendor_file_type, file_type;\n\ninit_daemon_domain(hal_fooAIDL_default);\nvndbinder_use(hal_fooAIDL_default);\nadd_service(hal_fooAIDL_default, fooAIDL_service);\n</code></pre> <p>Rebuildando e checando o <code>dmesg</code>:</p> <pre><code>10-08 08:32:41.525     0     0 E apexd   : Native process 'mypackage.mysubpackage.fooAIDL-service' is crashing. Attempting a revert\n10-08 08:32:46.496     0     0 I init    : starting service 'mypackage.mysubpackage.fooAIDL-service'...\n10-08 08:32:46.622  1949  1949 I mypackage.mysubpackage.fooAIDL-service: Test aidl service for fooAIDL is starting.,,\n10-08 08:32:46.618  1949  1949 W Binder:1949_2: type=1400 audit(0.0:15): avc: denied { call } for scontext=u:r:hal_fooAIDL_default:s0 tcontext=u:r:servicemanager:s0 tclass=binder permissive=0\n10-08 08:32:46.625  1949  1949 F mypackage.mysubpackage.fooAIDL-service: Check failed: STATUS_OK == AServiceManager_addService(test-&gt;asBinder().get(), name.c_str()) (STATUS_OK=0, AServiceManager_addService(test-&gt;asBinder().get(), name.c_str())=-129) \n10-08 08:32:46.622  1949  1949 W Binder:1949_2: type=1400 audit(0.0:16): avc: denied { call } for scontext=u:r:hal_fooAIDL_default:s0 tcontext=u:r:servicemanager:s0 tclass=binder permissive=0\n10-08 08:32:46.638  1954  1954 F DEBUG   : Cmdline: /vendor/bin/hw/mypackage.mysubpackage.fooAIDL-service\n10-08 08:32:46.638  1954  1954 F DEBUG   : pid: 1949, tid: 1949, name: Binder:1949_2  &gt;&gt;&gt; /vendor/bin/hw/mypackage.mysubpackage.fooAIDL-service &lt;&lt;&lt;\n10-08 08:32:46.639  1954  1954 F DEBUG   :       #03 pc 00000000000031a9  /vendor/bin/hw/mypackage.mysubpackage.fooAIDL-service (main+889) (BuildId: fdbc2fbc6416778b0057ade844657474)\n10-08 08:32:46.527     0     0 I init    : Service 'mypackage.mysubpackage.fooAIDL-service' (pid 1949) received signal 6\n10-08 08:32:46.527     0     0 I init    : Sending signal 9 to service 'mypackage.mysubpackage.fooAIDL-service' (pid 1949) process group...\n10-08 08:32:46.533     0     0 E init    : process with updatable components 'mypackage.mysubpackage.fooAIDL-service' exited 4 times in 4 minutes\n</code></pre> <p>Para resolver, foi adicionado a seguinte configura\u00e7\u00e3o ao arquivo:</p> hal_fooAIDL_default.te<pre><code>type hal_fooAIDL_default, domain;\ntype hal_fooAIDL_default_exec, exec_type, vendor_file_type, file_type;\n\ninit_daemon_domain(hal_fooAIDL_default);\nvndbinder_use(hal_fooAIDL_default);\nadd_service(hal_fooAIDL_default, fooAIDL_service);\nallow hal_fooAIDL_service servicemanager:binder { call transfer };\n</code></pre> <p>Rebuildando e checando o <code>dmesg</code>:</p> <pre><code>10-08 08:47:08.591     0     0 I init    : Parsing file /vendor/etc/init/mypackage.mysubpackage.fooAIDL-service.rc...\n10-08 08:47:13.008     0     0 I init    : starting service 'mypackage.mysubpackage.fooAIDL-service'...\n10-08 08:47:13.054     0     0 I init    : processing action (boot) from (/vendor/etc/init/mypackage.mysubpackage.fooAIDL-service.rc:7)\n10-08 08:47:13.049   369   369 I mypackage.mysubpackage.fooAIDL-service: Test aidl service for fooAIDL is starting.,,\n10-08 08:47:13.049   170   170 I servicemanager: Found mypackage.mysubpackage.fooAIDL.ITest/default in device VINTF manifest.\n10-08 08:47:13.049   369   369 I mypackage.mysubpackage.fooAIDL-service: Initialized fooAIDL cpu\n</code></pre> <p>At\u00e9 aqui, tudo certo \ud83d\ude04.</p>"},{"location":"android/boards/qemu/hal/aidl/#testando","title":"Testando","text":"<p>Para testar a HAL, criei a pasta:</p> <p><pre><code>mkdir -p /device/casa/emulator/interfaces/foo/aidl/default/halTest\n</code></pre> e dentro dela os seguintes arquivos:</p> HalTest.cpp<pre><code>#include &lt;aidl/mypackage/mysubpackage/fooAIDL/ITest.h&gt;\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\n#include &lt;android/binder_manager.h&gt;\n\nusing ::aidl::mypackage::mysubpackage::fooAIDL::ITest;\n\n\nint main(int argc, char *argv[]) {\n\n    std::shared_ptr&lt;ITest&gt; mHal;\n    std::string a;\n    bool c;\n\n    if (argc != 2) {\n        std::cout &lt;&lt; \"USAGE ./cpu_client &lt;conservative|powersave|performance|schedutil&gt;\\n\";\n        exit(0);\n    }\n\n    AIBinder* binder = AServiceManager_waitForService(\"mypackage.mysubpackage.fooAIDL.ITest/default\");\n\n    if (binder == nullptr){\n        std::cout &lt;&lt; \"Failed to get cpu service\\n\";\n        exit(-1);\n    }\n\n    mHal = ITest::fromBinder(ndk::SpAIBinder(binder));\n\n\n    mHal-&gt;getTest(&amp;a);\n    std::cout &lt;&lt; \"getScalingGovernor:\" &lt;&lt; a &lt;&lt; std::endl;\n\n    mHal-&gt;setTest(argv[1], &amp;c);\n    std::cout &lt;&lt; \"setScalingGovernor:\" &lt;&lt; c &lt;&lt; std::endl;\n\n    mHal-&gt;getTest(&amp;a);\n    std::cout &lt;&lt; \"getScalingGovernor:\" &lt;&lt; a &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre> Android.bp<pre><code>cc_binary {\n    name: \"foo_AIDL_tester\",\n    vendor: true,\n    relative_install_path: \"hw\",\n\n    srcs: [\"HalTest.cpp\"],\n\n    shared_libs: [\n        \"libbase\",\n        \"liblog\",\n        \"libhardware\",\n        \"libbinder_ndk\",\n        \"libbinder\",\n        \"libutils\",\n        \"mypackage.mysubpackage.fooAIDL-V1-ndk_platform\"\n    ],\n}\n</code></pre> <p>Rebuildando utilizando o comando:</p> <pre><code>adb root\nadb shell \"/vendor/bin/hw/foo_AIDL_tester performance\"\n</code></pre> <p>o programa deve retorna a seguinte mensagem: </p> <p>getScalingGovernor:schedutil  setScalingGovernor:0  getScalingGovernor:schedutil </p> <p>N\u00e3o houve altera\u00e7\u00e3o para <code>performance</code>, continuou em <code>schedutil</code>. Checando o <code>dmesg</code>:</p> <pre><code>10-09 06:38:08.315   370   383 I mypackage.mysubpackage.fooAIDL-service: Test AIDL::getTest data=(schedutil\n10-09 06:38:08.315   370   383 I mypackage.mysubpackage.fooAIDL-service: )\n10-09 06:38:08.316   370   383 I mypackage.mysubpackage.fooAIDL-service: Test AIDL::setTest data=(performance)\n10-09 06:38:08.311   370   370 W Binder:370_1: type=1400 audit(0.0:6): avc: denied { write } for name=\"scaling_governor\" dev=\"sysfs\" ino=19629 scontext=u:r:hal_fooAIDL_default:s0 tcontext=u:object_r:sysfs_devices_system_cpu:s0 tclass=file permissive=0\n10-09 06:38:08.317   370   383 I mypackage.mysubpackage.fooAIDL-service: Test AIDL::getTest data=(schedutil\n10-09 06:38:08.317   370   383 I mypackage.mysubpackage.fooAIDL-service: )\n</code></pre> <p>Para resolver isso, devemos adicionar ao arquivo:</p> hal_fooAIDL_default.te<pre><code>type hal_fooAIDL_default, domain;\ntype hal_fooAIDL_default_exec, exec_type, vendor_file_type, file_type;\n\ninit_daemon_domain(hal_fooAIDL_default);\nvndbinder_use(hal_fooAIDL_default);\nadd_service(hal_fooAIDL_default, fooAIDL_service);\nallow hal_fooAIDL_service servicemanager:binder { call transfer };\nallow hal_fooAIDL_default sysfs_devices_system_cpu:file write;\n</code></pre> <p>Rebuildando e executando o comando:</p> <pre><code>adb root\nadb shell \"/vendor/bin/hw/foo_AIDL_tester performance\"\n</code></pre> <p>O programa deve retornar a seguinte mensagem:</p> <p>getScalingGovernor:schedutil  setScalingGovernor:1  getScalingGovernor:performance  </p> <p>Agora houve a altera\u00e7\u00e3o de <code>schedutil</code> \u27a1\ufe0f <code>performance</code>.</p>"},{"location":"android/boards/qemu/hal/aidl/#conclusao","title":"Conclus\u00e3o","text":"<p>Implementar a AIDL \u00e9 relativamente mais simples que a HIDL. Durante a implementa\u00e7\u00e3o, percebi que os m\u00e9todos implementados que sobrep\u00f5em os m\u00e9todos virtuais retornam um valor para o <code>binder</code>. Por isso, se quisermos ter alguma informa\u00e7\u00e3o externada, \u00e9 preciso passar algum ponteiro para dentro do m\u00e9todo, adicionar as informa\u00e7\u00f5es relevantes e depois acessa-lo externamente ao m\u00e9todo. Como ocorre no arquivo <code>HalTest.cpp</code>, para as vari\u00e1veis <code>a</code> e <code>c</code>.</p>"},{"location":"android/boards/qemu/hal/hidl/","title":"Implementando a HIDL","text":"Image by methodshop from Pixabay <p>Baseado no curso: Android 12 Internals material, labs and discussion</p>"},{"location":"android/boards/qemu/hal/hidl/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>Umas das coisas mais dif\u00edceis que eu encontrei durante o processo de entender o sistema Android, foi sobre Hardware Abstraction Layer (HAL). Que \u00e9 a forma de conectar o framework do Android com a parte do hardware. Atualmente, a forma mais disseminada de fazer essa conex\u00e3o \u00e9 utilizando a HAL Interface Definition Language (HIDL). Que irei abordar nesse post.</p>"},{"location":"android/boards/qemu/hal/hidl/#definicoes","title":"Defini\u00e7\u00f5es","text":"<p>Quando um aplicativo A precisa se comunicar com um aplicativo B, existem duas formas grosseiramente de se fazer isso. A primeira \u00e9 passando diretamente a regi\u00e3o de mem\u00f3ria do aplicativo A para o aplicativo B. A segunda \u00e9 utilizando um mecanismo que gerencie essa troca de informa\u00e7\u00e3o entre o aplicativo A e o aplicativo B. Essa comunica\u00e7\u00e3o entre aplicativos \u00e9 conhecida como inter-process communication (IPC), que utilizam proxy e stub para fazer a comunica\u00e7\u00e3o, como uma esp\u00e9cie de cliente-servidor.</p> <p>No Android, esse mecanismo \u00e9 o <code>Binder</code> e o \"protocolo\" que esse mecanismo utiliza \u00e9 a HAL, que por sua vez pode ser implementada com a HIDL. Nesse sistema os equivalentes do proxy e stub s\u00e3o o Binder Proxy (Bp) e Binder Native (Bn). Dessa forma, as siglas <code>Bp</code> e <code>Bn</code> ir\u00e3o aparecer constantemente no processo de implementa\u00e7\u00e3o da HAL do Android.</p> <p>N\u00e3o confundir com a extens\u00e3o <code>.Bp</code> (Blueprint) que faz refer\u00eancia aos arquivos de build do Android.</p>"},{"location":"android/boards/qemu/hal/hidl/#implementacao","title":"Implementa\u00e7\u00e3o","text":"<p>Vou tentar dividir em alguns t\u00f3picos para facilitar.</p>"},{"location":"android/boards/qemu/hal/hidl/#hal","title":"HAL","text":"<p>Na pasta raiz do AOSP, criei o seguinte caminho:</p> <pre><code>mkdir -p device/casa/emulator/interfaces/foo/1.0\n</code></pre> <p>A pasta <code>foo/</code> \u00e9 o nome da HAL e a pasta <code>1.0/</code> seria a vers\u00e3o dessa HAL. Dentro da pasta <code>1.0/</code> criei os arquivos:</p> Android.bp<pre><code>hidl_interface {\n    name: \"mypackage.mysubpackage.foo@1.0\",\n    root: \"mypackage.mysubpackage\",\n    srcs: [\n        \"ITest.hal\",\n    ],\n    interfaces: [\n        \"android.hidl.base@1.0\",\n    ],\n    gen_java: true,\n    product_specific: true,\n}\n</code></pre> ITest.hal<pre><code>package mypackage.mysubpackage.foo@1.0;\n\ninterface ITest {\n    getTest() generates (string res);\n    setTest(string param) generates (bool res);\n};\n</code></pre> <p>Algumas coisas que podem causar confus\u00e3o e geralmente d\u00e3o problema de compila\u00e7\u00e3o s\u00e3o os nomes. Nesse caso, no arquivo Android.bp a tag <code>root</code> \u00e9 um prefixo para a tag <code>name</code> (<code>mypackage.mysubpackage</code>), que \u00e9 seguida do nome da HAL (foo) com sua vers\u00e3o (1.0). No arquivo ITest.hal, o <code>package</code> deve ser o mesmo nome da tag <code>name</code> do Android.bp.</p> <p>Agora dentro da pasta <code>interfaces/</code> (<code>device/casa/emulator/interfaces</code>), criei outro arquivo:</p> Android.bp<pre><code>hidl_package_root {\n    name: \"mypackage.mysubpackage\",\n    path: \"device/casa/emulator/interfaces\",\n}\n</code></pre> <p>A tag <code>name</code> desse arquivo \u00e9 igual ao da tag <code>root</code> do outro arquivo Android.bp. A tag <code>path</code> \u00e9 o caminho relativo da pasta raiz do AOSP at\u00e9 a pasta <code>interfaces</code>.</p> <p>Finalmente, dentro da pasta <code>device/casa/emulator/interfaces/foo/1.0</code> o seguinte comando foi usado:</p> <pre><code>mm -j8\n</code></pre> <p>Ele compila a HAL foo. Ao final do processo uma mensagem similar deve aparecer:</p> <p>============================================  [100% 149/149] Copy: out/target/product/emulator/data/nativetest/product/mypackage.mysubpackage.foo@1.0-adapter/mypackage.mysubpackage.foo@1.0.so.toc build completed successfully (7 seconds) #### </p> <p>Os arquivos gerados est\u00e3o dentro do diret\u00f3rio:</p> <p>out/soong/.intermediates/device/casa/emulator/interfaces/foo/1.0</p> <p>No curso Android 12 Internals \u00e9 dado mais detalhes sobre alguns arquivos dentro dessa pasta.</p> <p>Por fim, \u00e9 necess\u00e1rio adicionar a HAL foo ao final do produto, no meu caso, emulator.mk ( <code>device/casa/emulator/emulator.mk</code>), da seguinte forma:</p> emulator.mk<pre><code>...\nPRODUCT_PACKAGES += \\\n    mypackage.mysubpackage.foo@1.0\n</code></pre> <p>Agora \u00e9 s\u00f3 rebuildar o AOSP <code>m -j8</code>.</p> <p>Ap\u00f3s o build terminar, na pasta do produto dentro da pasta <code>out/</code> \u00e9 poss\u00edvel ver onde a HAL foi adicionada:</p> <p>./vendor/lib/mypackage.mysubpackage.foo@1.0.so ./vendor/lib/mypackage.mysubpackage.foo@1.0-adapter-helper.so ./vendor/lib64/mypackage.mysubpackage.foo@1.0.so ./vendor/lib64/mypackage.mysubpackage.foo@1.0-adapter-helper.so</p> <p>./product/lib/mypackage.mysubpackage.foo@1.0.so ./product/lib/mypackage.mysubpackage.foo@1.0-adapter-helper.so ./product/lib64/mypackage.mysubpackage.foo@1.0.so ./product/lib64/mypackage.mysubpackage.foo@1.0-adapter-helper.so ./product/framework/mypackage.mysubpackage.foo-V1.0-java.jar ./product/framework/mypackage.mysubpackage.foo-V1.0-java-shallow.jar</p> <p>Ser\u00e3o adicionados na imagem <code>vendor.img</code> e <code>product.img</code>.</p>"},{"location":"android/boards/qemu/hal/hidl/#servico","title":"Servi\u00e7o","text":"<p>Antes de criar o servi\u00e7o, precisamos implementar o que ser\u00e1 processado dentro das duas fun\u00e7\u00f5es que definidas no ITest.hal. Quando compilamos a HAL no passo anterior, o Android criou 2 m\u00e9todos virtuais dentro do arquivo: </p> <p><code>out/soong/.intermediates/device/casa/emulator/interfaces/foo/1.0/mypackage.mysubpackage.foo@1.0_genc++_headers/gen/mypackage/mysubpackage/foo/1.0/ITest.h</code></p> <p>Os m\u00e9todos s\u00e3o:</p> ITest.h<pre><code>/**\n* Return callback for getTest\n*/\nusing getTest_cb = std::function&lt;void(const ::android::hardware::hidl_string&amp; res)&gt;;\n\nvirtual ::android::hardware::Return&lt;void&gt; getTest(getTest_cb _hidl_cb) = 0;\nvirtual ::android::hardware::Return&lt;bool&gt; setTest(const ::android::hardware::hidl_string&amp; param) = 0;\n</code></pre> <p>Para fazer a implementa\u00e7\u00e3o desses m\u00e9todos, criei dentro da pasta <code>device/casa/emulator/interfaces/foo/1.0/default</code> os arquivos:</p> Test.h<pre><code>#ifndef MYPACKAGE_MYSUBPACKAGE_FOO_V1_0_ITEST_H\n#define MYPACKAGE_MYSUBPACKAGE_FOO_V1_0_ITEST_H\n\n// Mesmo caminho ap\u00f3s:\n// mypackage.mysubpackage.foo@1.0_genc++_headers/gen/\n// dentro da pasta out/\n#include &lt;mypackage/mysubpackage/foo/1.0/ITest.h&gt;\n\nnamespace mypackage {\nnamespace mysubpackage {\nnamespace foo {\nnamespace V1_0 {\nnamespace implementation {\n\n\nusing ::android::hardware::hidl_string; // const hidl_string\nusing ::android::hardware::Return; // Return&lt;void&gt;\nusing ::android::hardware::Void; // return Void();\nusing ::mypackage::mysubpackage::foo::V1_0::ITest; // public ITest\n\nclass Test : public ITest {\n    public:\n        Return&lt;bool&gt; setTest(const hidl_string&amp; param) override;\n        Return&lt;void&gt; getTest(getTest_cb _hidl_c) override;\n};\n\nextern \"C\" ITest* HIDL_FETCH_ITest(const char* name);\n\n} // namespace implementation\n} // namespace V1_0 \n} // namespace foo\n} // namespace mysubpackage\n} // namespace mypackage\n\n#endif\n</code></pre> Test.cpp<pre><code>#include \"Test.h\"\n\n#include &lt;utils/Log.h&gt; //ALOGI e ALOGE\n#include &lt;sys/stat.h&gt; // struct stat info\n\n\nnamespace mypackage {\nnamespace mysubpackage {\nnamespace foo {\nnamespace V1_0 {\nnamespace implementation {\n\n// conservative|powersave|performance|schedutil\nstatic const char SCALING_GOVERNOR[] = \"/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor\";\n\nstatic int write_value(const char *file, const char *value)\n{\n    int to_write, written, ret, fd;\n\n    fd = TEMP_FAILURE_RETRY(open(file, O_WRONLY));\n    if (fd &lt; 0) {\n    ALOGE(\"write_value failed to open\");\n        return -1;\n    }\n\n    to_write = strlen(value) + 1;\n    written = TEMP_FAILURE_RETRY(write(fd, value, to_write));\n    if (written == -1) {\n        ret = -2;\n    } else if (written != to_write) {\n        ret = -3;\n    } else {\n        ret = 0;\n    }\n\n    errno = 0;\n    close(fd);\n\n    return ret;\n}\n\nReturn&lt;bool&gt; Test::setTest(const hidl_string&amp; param) {\n    ALOGI(\"Test::setTest data=(%s)\", param.c_str());\n    return write_value(SCALING_GOVERNOR, param.c_str()) == 0;\n}\n\nReturn&lt;void&gt; Test::getTest(getTest_cb _hidl_cb) {\n    char str[20];\n    int fd;\n    ssize_t ret = 0;\n    struct stat info;\n    void *data = NULL;\n    size_t size;\n\n    // If open returns error code EINTR, retry again until error code\n    // is not a temporary failure\n    fd = TEMP_FAILURE_RETRY(open(SCALING_GOVERNOR, O_RDONLY));\n    if (fd &lt; 0) {\n        _hidl_cb(\"error can open fd\");\n        return Void();\n    }\n\n    fstat(fd, &amp;info);\n    size = info.st_size;\n    data = malloc(size);\n    if (data == NULL) {\n        _hidl_cb(\"error can't malloc\");\n        close(fd);\n        free(data);\n        return Void();\n    }\n\n    ret = read(fd, data, size);\n    if (ret &lt; 0) {\n        _hidl_cb(\"error reading fd\");\n        close(fd);\n        free(data);\n        return Void();\n    }\n\n    snprintf(str, sizeof(str), \"%s\", (const unsigned char*)data);\n    ALOGI(\"Test:getTest data=(%s)\", str);\n    _hidl_cb(str);\n}\n\n// Methods from ::android::hidl::base::V1_0::IBase follow.\nITest* HIDL_FETCH_ITest(const char* /* name */) {\n    return new Test();\n}\n\n} // namespace implementation\n} // namespace V1_0 \n} // namespace foo\n} // namespace mysubpackage\n} // namespace mypackage\n</code></pre> <p>Fiz praticamente o mesmo c\u00f3digo do curso, ele \u00e9 capaz de alterar de checar o escalonador do processador. A ideia aqui n\u00e3o \u00e9 explicar o c\u00f3digo, e sim s\u00f3 implementar alguma coisa nos 2 m\u00e9todos. Voce pode implementar qualquer outra coisa.</p> <p>Uma vez que o c\u00f3digo foi implementado, precisamos criar o servi\u00e7o que deixar\u00e1 o mesmo dispon\u00edvel. Dentro da mesma pasta foi criado o arquivo:</p> service.cpp<pre><code>#define LOG_TAG \"mypackage.mysubpackage.foo@1.0-service\"\n\n#include &lt;mypackage/mysubpackage/foo/1.0/ITest.h&gt;\n\n#include &lt;log/log.h&gt;\n#include &lt;hidl/HidlTransportSupport.h&gt;\n\n#include \"Test.h\"\n\nusing android::sp;\nusing android::status_t;\nusing android::OK;\n\n// libhwbinder:\nusing android::hardware::configureRpcThreadpool;\nusing android::hardware::joinRpcThreadpool;\n\n// Generated HIDL files\nusing mypackage::mysubpackage::foo::V1_0::ITest;\nusing mypackage::mysubpackage::foo::V1_0::implementation::Test;\n\nusing namespace mypackage;\n\nint main(int /* argc */, char** /* argv */) {\n    ALOGI(\"Foo Service 1.0 for test is starting.\");\n\n    // Android Strong Pointer (don't GC until exit)\n    sp&lt;ITest&gt; service = new Test();\n    if (service == nullptr) {\n        ALOGE(\"Can not create an instance of ITest HAL, exiting.\");\n        return 1;\n    }\n\n    // system/libhidl/transport/include/hidl/HidlTransportSupport.h\n    // Configures the threadpool used for handling incoming RPC calls in this process:\n    // @param maxThreads maximum number of threads in this process\n    // @param callerWillJoin whether the caller will join the threadpool later.\n    configureRpcThreadpool(1, true /*callerWillJoin*/);\n\n    // registerAsService calls registerAsServiceInternal in\n    // system/libhidl/transport/ServiceManagement.cpp\n    // registerAsServiceInternal registers with hwservicemanager\n    status_t status = service-&gt;registerAsService();\n    if (status != OK) {\n        ALOGE(\"Could not register service for ITest HAL (%d), exiting.\", status);\n        return 1;\n    }\n    ALOGI(\"Test Service is ready\");\n\n    // system/libhidl/transport/include/hidl/HidlTransportSupport.h\n    // Joins a threadpool that you configured earlier\n    joinRpcThreadpool();\n\n    // In normal operation, we don't expect the thread pool to exit\n    ALOGE(\"Test Service is shutting down\");\n    return 1;\n}\n</code></pre> <p>De modo geral, a implementa\u00e7\u00e3o \u00e9 a mesma. S\u00f3 precisa ficar atento ao nome da HAL, nesse caso <code>Test</code>.</p> <p>Agora \u00e9 necess\u00e1rio criar o arquivo:</p> Android.bp<pre><code>cc_binary {\n    relative_install_path: \"hw\",\n    name: \"mypackage.mysubpackage.foo@1.0-service\",\n    init_rc: [\"mypackage.mysubpackage.foo@1.0-service.rc\"],\n    srcs: [\"service.cpp\", \"Test.cpp\"],\n    vendor: true,\n    // system_ext_specific: true,\n    vintf_fragments: [\"mypackage.mysubpackage.foo@1.0-service.xml\"],\n\n    shared_libs: [\n        \"libhidlbase\",\n        \"liblog\",\n        \"libutils\",\n        \"libhardware\",\n        \"mypackage.mysubpackage.foo@1.0\",\n    ],\n}\n</code></pre> <p>Precisamos agora criar 2 arquivos mypackage.mysubpackage.foo@1.0-service.rc e mypackage.mysubpackage.foo@1.0-service.xml, referente as tags <code>init_rc</code> e  <code>vintf_fragments</code> respectivamente.</p> mypackage.mysubpackage.foo@1.0-service.rc<pre><code>service mysubpackage_foo_hal_service /vendor/bin/hw/mypackage.mysubpackage.foo@1.0-service\n        interface mypackage.mysubpackage.foo@1.0::ITest default\n        class hal\n        user system\n        group system\n</code></pre> mypackage.mysubpackage.foo@1.0-service.xml<pre><code>&lt;manifest version=\"1.0\" type=\"device\"&gt;\n    &lt;hal format=\"hidl\"&gt;\n        &lt;name&gt;mypackage.mysubpackage.foo&lt;/name&gt;\n        &lt;transport&gt;hwbinder&lt;/transport&gt;\n        &lt;version&gt;1.0&lt;/version&gt;\n        &lt;interface&gt;\n            &lt;name&gt;ITest&lt;/name&gt;\n            &lt;instance&gt;default&lt;/instance&gt;\n        &lt;/interface&gt;\n        &lt;fqname&gt;@1.0::ITest/default&lt;/fqname&gt;\n    &lt;/hal&gt;\n&lt;/manifest&gt;\n</code></pre> <p>Agora \u00e9 s\u00f3 fazer um rebuild <code>m -j8</code>.</p> <p>Podemos checar dentro da pasta <code>/out/target/product/emulator/vendor</code> os seguintes arquivos ap\u00f3s o build:</p> <p>./bin/hw/mypackage.mysubpackage.foo@1.0-service ./lib/mypackage.mysubpackage.foo@1.0.so ./lib/mypackage.mysubpackage.foo@1.0-adapter-helper.so ./lib64/mypackage.mysubpackage.foo@1.0.so ./lib64/mypackage.mysubpackage.foo@1.0-adapter-helper.so ./etc/init/mypackage.mysubpackage.foo@1.0-service.rc ./etc/vintf/manifest/mypackage.mysubpackage.foo@1.0-service.xml</p>"},{"location":"android/boards/qemu/hal/hidl/#permissao","title":"Permiss\u00e3o","text":"<p>Iniciando dispositivo, e capturando o log do <code>dmesg</code>, \u00e9 poss\u00edvel encontrar a seguinte mensagem:</p> <pre><code>10-02 11:57:23.566     0     0 I init    : Parsing file /vendor/etc/init/mypackage.mysubpackage.foo@1.0-service.rc...\n10-02 11:57:27.172     0     0 E init    : Could not start service 'mysubpackage_foo_hal_service' as part of class 'hal': File /vendor/bin/hw/mypackage.mysubpackage.foo@1.0-service(labeled \"u:object_r:vendor_file:s0\") has incorrect label or no domain transition from u:r:init:s0 to another SELinux domain defined. Have you configured your service correctly? https://source.android.com/security/selinux/device-policy#label_new_services_and_address_denials. Note: this error shows up even in permissive mode in order to make auditing denials possible.\n</code></pre> <p>Esse erro \u00e9 referente a falta de permiss\u00e3o que nosso servi\u00e7o possui. Vamos fazer as devidas configura\u00e7\u00f5es.</p> <p>Criei a pasta Sepolicy dentro do produto:</p> <pre><code>mkdir -p device/casa/emulator/sepolicy\n</code></pre> <p>Dentro da pasta foi criado os arquivos:</p> file_contexts<pre><code>/vendor/bin/hw/mypackage\\.mysubpackage\\.foo@1\\.0-service u:object_r:hal_mysubpackage_default_exec:s0\n</code></pre> hal_mysubpackage_default.te<pre><code>type hal_mysubpackage_default, domain;\ntype hal_mysubpackage_default_exec, exec_type, vendor_file_type, file_type;\n\ninit_daemon_domain(hal_mysubpackage_default);\n</code></pre> <p>Al\u00e9m disso, \u00e9 necess\u00e1rio adicionar a pasta na compila\u00e7\u00e3o do AOSP. Isso \u00e9 feito dentro do BoardConfig.mk do produto, no meu caso <code>device/casa/emulator/BoardConfig.mk</code>:</p> BoardConfig.mk<pre><code>...\nBOARD_SEPOLICY_DIRS += device/casa/emulator/sepolicy\n</code></pre> <p>Agora \u00e9 s\u00f3 recompilar o AOSP.</p> <p>Ap\u00f3s o build, capturando o log do <code>dmesg</code>, podemos encontrar a seguinte mensagem:</p> <pre><code>10-02 14:30:53.735   370   370 W mypackage.mysub: type=1400 audit(0.0:1020): avc: denied { read } for name=\"u:object_r:hwservicemanager_prop:s0\" dev=\"tmpfs\" ino=168 scontext=u:r:hal_mysubpackage_default:s0 tcontext=u:object_r:hwservicemanager_prop:s0 tclass=file permissive=0\n</code></pre> <p>Essa mensagem \u00e9 referente ao SELinux audit messages e para resolve-las \u00e9 necessario criar as SELinux allow rules. Para isso, pode se usar o <code>policycoreutils</code>, que pode ser instalado com o comando:</p> <pre><code>sudo apt install policycoreutils-python-utils\n</code></pre> <p>Agora precisamos baixar o arquivo policy do device, para isso \u00e9 usado o comando:</p> <pre><code>adb pull /sys/fs/selinux/policy\n</code></pre> <p>Na mesma pasta onde foi baixado o arquivo policy, foi usado o seguinte comando:</p> <pre><code>adb logcat -b all -d | audit2allow -p policy\n</code></pre> <p>Foi retornado a seguinte mensagem:</p> <p>============= hal_mysubpackage_default ==============  allow hal_mysubpackage_default hwservicemanager_prop:file read;</p> <p>Essa mensagem diz que a HAL precisa de permiss\u00e3o de leitura em <code>hwservicemanager_prop</code>. Para fazer isso, adicionamos a seguinte linha no arquivo:</p> hal_mysubpackage_default.te<pre><code>type hal_mysubpackage_default, domain;\ntype hal_mysubpackage_default_exec, exec_type, vendor_file_type, file_type;\n\ninit_daemon_domain(hal_mysubpackage_default);\n\n# allow hal_mysubpackage_default hwservicemanager_prop:file read;\nget_prop(hal_mysubpackage_default, hwservicemanager_prop); \n</code></pre> <p>Rebuildando e checando o <code>dmesg</code>, agora encontramos as seguinte mensagem:</p> <pre><code>10-02 14:53:10.769     0     0 I init    : starting service 'mysubpackage_foo_hal_service'...\n10-02 14:53:11.162  1855  1855 I mypackage.mysubpackage.foo@1.0-service: Foo Service 1.0 for test is starting.\n10-02 14:53:11.163  1855  1855 E HidlServiceManagement: Could not get transport for mypackage.mysubpackage.foo@1.0::ITest/default: Status(EX_TRANSACTION_FAILED): 'FAILED_TRANSACTION: '\n10-02 14:53:11.163  1855  1855 E mypackage.mysubpackage.foo@1.0-service: Could not register service for ITest HAL (-2147483648), exiting.\n10-02 14:53:11.160  1855  1855 W mypackage.mysub: type=1400 audit(0.0:11): avc: denied { call } for scontext=u:r:hal_mysubpackage_default:s0 tcontext=u:r:hwservicemanager:s0 tclass=binder permissive=0\n10-02 14:53:10.783     0     0 I init    : Service 'mysubpackage_foo_hal_service' (pid 1855) exited with status 1\n10-02 14:53:10.785     0     0 I init    : Sending signal 9 to service 'mysubpackage_foo_hal_service' (pid 1855) process group...\n10-02 14:53:10.786     0     0 E init    : process with updatable components 'mysubpackage_foo_hal_service' exited 4 times in 4 minutes\n</code></pre> <p>Para resolver, vamos novamente usar os seguintes comandos:</p> <pre><code>adb pull /sys/fs/selinux/policy\nadb logcat -b all -d | audit2allow -p policy\n</code></pre> <p>Ele retorna a seguinte mensagem:</p> <p>============= hal_mysubpackage_default ============== allow hal_mysubpackage_default hwservicemanager:binder call;</p> <p>Ela informa que \u00e9 necess\u00e1rio fazer a chamada do <code>hwservicemanager</code>. Para isso, adicionamos ao arquivo:</p> hal_mysubpackage_default.te<pre><code>type hal_mysubpackage_default, domain;\ntype hal_mysubpackage_default_exec, exec_type, vendor_file_type, file_type;\n\ninit_daemon_domain(hal_mysubpackage_default);\n\n# allow hal_mysubpackage_default hwservicemanager_prop:file read;\nget_prop(hal_mysubpackage_default, hwservicemanager_prop); \n\n# allow hal_mysubpackage_default hwservicemanager:binder call;\nhwbinder_use(hal_mysubpackage_default);\n</code></pre> <p>Rebuildando e checando o <code>dmesg</code>, temos a seguinte mensagem:</p> <pre><code>10-02 15:05:28.709     0     0 I init    : starting service 'mysubpackage_foo_hal_service'...\n10-02 15:05:29.551  1891  1891 I mypackage.mysubpackage.foo@1.0-service: Foo Service 1.0 for test is starting. \n10-02 15:05:29.551   172   172 E SELinux : avc:  denied  { find } for interface=mypackage.mysubpackage.foo::ITest sid=u:r:hal_mysubpackage_default:s0 pid=1891 scontext=u:r:hal_mysubpackage_default:s0 tcontext=u:object_r:default_android_hwservice:s0 tclass=hwservice_manager permissive=0\n10-02 15:05:29.551  1891  1891 E HidlServiceManagement: Service mypackage.mysubpackage.foo@1.0::ITest/default must be in VINTF manifest in order to register/get.\n10-02 15:05:29.551  1891  1891 E mypackage.mysubpackage.foo@1.0-service: Could not register service for ITest HAL (-2147483648), exiting.\n10-02 15:05:28.722     0     0 I init    : Service 'mysubpackage_foo_hal_service' (pid 1891) exited with status 1\n10-02 15:05:28.722     0     0 I init    : Sending signal 9 to service 'mysubpackage_foo_hal_service' (pid 1891) process group...\n10-02 15:05:28.723     0     0 E init    : process with updatable components 'mysubpackage_foo_hal_service' exited 4 times in 4 minutes\n</code></pre> <p>Esse erro ocorre devido ao conflito de regras do <code>domain</code>, definido no arquivo hal_mysubpackage_default.te. Para obter mais informa\u00e7\u00f5es, sugiro checar o curso.</p> <p>Para resolver, vamos novamente usar os seguintes comandos:</p> <pre><code>adb pull /sys/fs/selinux/policy\nadb logcat -b all -d | audit2allow -p policy\n</code></pre> <p>Ele retorna a seguinte mensagem:</p> <p>============= hal_mysubpackage_default ==============  allow hal_mysubpackage_default default_android_hwservice:hwservice_manager find;</p> <p>Para resolver isso, foi criado dentro da pasta <code>device/casa/emulator/sepolicy</code> os arquivos:</p> hwservice.te<pre><code>type hal_mysubpackage_hwservice, hwservice_manager_type;\n</code></pre> hwservice_contexts<pre><code>mypackage.mysubpackage.foo::ITest       u:object_r:hal_mysubpackage_hwservice:s0\n</code></pre> <p>E adicionamos as seguintes linhas ao arquivo:</p> hal_mysubpackage_default.te<pre><code>type hal_mysubpackage_default, domain;\ntype hal_mysubpackage_default_exec, exec_type, vendor_file_type, file_type;\n\ninit_daemon_domain(hal_mysubpackage_default);\n\n# allow hal_mysubpackage_default hwservicemanager_prop:file read;\nget_prop(hal_mysubpackage_default, hwservicemanager_prop); \n\n# allow hal_mysubpackage_default hwservicemanager:binder call;\nhwbinder_use(hal_mysubpackage_default);\n\n# allow hal_mysubpackage_default default_android_hwservice:hwservice_manager find;\nadd_hwservice(hal_mysubpackage_default, hal_mysubpackage_hwservice);\n</code></pre> <p>Rebuildando e checando o <code>dmesg</code>, temos a seguinte mensagem:</p> <pre><code>10-02 15:27:27.714     0     0 I init    : Parsing file /vendor/etc/init/mypackage.mysubpackage.foo@1.0-service.rc...\n10-02 15:27:35.135     0     0 I init    : starting service 'mysubpackage_foo_hal_service'...\n10-02 15:27:35.135   370   370 I mypackage.mysubpackage.foo@1.0-service: Foo Service 1.0 for test is starting.\n10-02 15:27:35.141   370   370 I HidlServiceManagement: Registered mypackage.mysubpackage.foo@1.0::ITest/default\n10-02 15:27:35.141   370   370 I HidlServiceManagement: Removing namespace from process name mypackage.mysubpackage.foo@1.0-service to foo@1.0-service.\n10-02 15:27:35.141   370   370 I mypackage.mysubpackage.foo@1.0-service: Test Service is ready\n</code></pre> <p>Agora nosso servi\u00e7o est\u00e1 com todas as permiss\u00f5es necess\u00e1rias. Observe que algumas das mensagens foram implementadas no arquivo service.cpp</p>"},{"location":"android/boards/qemu/hal/hidl/#testando","title":"Testando","text":"<p>Para criar um bin\u00e1rio para teste, foi criado na pasta <code>device/casa/emulator/interfaces/foo/1.0/default/halTest</code> os seguintes arquivos:</p> <p>HalTest.cpp<pre><code>#include &lt;mypackage/mysubpackage/foo/1.0/ITest.h&gt;\n\n#include &lt;hidl/Status.h&gt;\n#include &lt;hidl/LegacySupport.h&gt;\n#include &lt;utils/misc.h&gt;\n#include &lt;hidl/HidlSupport.h&gt;\n#include &lt;iostream&gt;\n#include &lt;cstdlib&gt;\n#include &lt;string&gt;\n\nusing ::android::sp;\nusing ::mypackage::mysubpackage::foo::V1_0::ITest;\nusing android::hardware::hidl_string;\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        std::cout &lt;&lt; \"USAGE ./cpu_client &lt;conservative|powersave|performance|schedutil&gt;\\n\";\n        exit(0);\n    }\n\n    android::sp&lt;ITest&gt; cpuService = ITest::getService();\n    if (cpuService == nullptr) {\n        std::cout &lt;&lt; \"Failed to get cpu service\\n\";\n        exit(-1);\n    }\n\n    cpuService-&gt;getTest([&amp;](hidl_string result) {\n        std::cout &lt;&lt; \"getScalingGovernor:\" &lt;&lt; result &lt;&lt; std::endl;\n    });\n\n    bool result = cpuService-&gt;setTest(argv[1]);\n    std::cout &lt;&lt; \"setScalingGovernor:\" &lt;&lt; result &lt;&lt; std::endl;\n\n    cpuService-&gt;getTest([&amp;](hidl_string result) {\n        std::cout &lt;&lt; \"getScalingGovernor:\" &lt;&lt; result &lt;&lt; std::endl;\n    });\n\n    return 0;\n}\n</code></pre> Android.bp<pre><code>cc_binary {\n    relative_install_path: \"hw\",\n    defaults: [\"hidl_defaults\"],\n    name: \"subpackage_foo_tester\",\n    srcs: [\"HalTest.cpp\"],\n    vendor: true,\n\n    shared_libs: [\n        \"liblog\",\n        \"libhardware\",\n        \"libhidlbase\",\n        \"libutils\",\n        \"mypackage.mysubpackage.foo@1.0\",\n    ],\n}\n</code></pre></p> <p>Agora adicionando o bin\u00e1rio ao produto, no arquivo:</p> emulator.mk<pre><code>...\nPRODUCT_PACKAGES += \\\n    mypackage.mysubpackage.foo@1.0\n\nPRODUCT_PACKAGES_DEBUG += \\\n    subpackage_foo_tester\n</code></pre> <p>Re-buildando o AOSP e executando os seguintes comandos:</p> <pre><code>adb root\nadb shell\nvendor/bin/hw/subpackage_foo_tester performance\n</code></pre> <p>O caminho do bin\u00e1rio \u00e9 relativo a <code>vendor=true</code> (vendor/), <code>cc_binary</code> (bin/) e <code>relative_install_path</code> (hw/). O resultado do caminho \u00e9 <code>vendor/bin/hw/</code>.</p> <p>Checando o <code>dmesg</code>, encontramos a seguinte mensagem:</p> <pre><code>10-02 21:03:19.861   371   371 I mypackage.mysubpackage.foo@1.0-service: Test:getTest data=(schedutil\n10-02 21:03:19.861   371   371 I mypackage.mysubpackage.foo@1.0-service: )\n10-02 21:03:19.861   371   371 I mypackage.mysubpackage.foo@1.0-service: Test::setTest data=(performance)\n10-02 21:03:19.861   371   371 E mypackage.mysubpackage.foo@1.0-service: write_value failed to open\n10-02 21:03:19.861   371   371 I mypackage.mysubpackage.foo@1.0-service: Test:getTest data=(schedutil\n10-02 21:03:19.861   371   371 I mypackage.mysubpackage.foo@1.0-service: )\n</code></pre> <p>Isso se deve porque somente o usu\u00e1rio <code>root</code> tem permiss\u00e3o para escrever no caminho <code>/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor</code> (definido no arquivo Teste.cpp). Ent\u00e3o precisamos dar permiss\u00e3o para o nosso aplicativo, para isso vamos adicionar ao arquivo:</p> mypackage.mysubpackage.foo@1.0-service.rc<pre><code>service mysubpackage_foo_hal_service /vendor/bin/hw/mypackage.mysubpackage.foo@1.0-service\n    interface mypackage.mysubpackage.foo@1.0::ITest default\n    class hal\n    user system\n    group system\n\non boot\n    chown system system /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor\n    chmod 0664 /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor\n</code></pre> <p>Rebuildando e execuntado o bin\u00e1rio de teste, temos a seguinte mensagem :</p> <p>getScalingGovernor:schedutil</p> <p>setScalingGovernor:0 getScalingGovernor:schedutil</p> <p>Obervar que o <code>ScalingGovernor</code> n\u00e3o foi alterado. No log de <code>dmesg</code>, temos essa:</p> <pre><code>10-02 21:09:09.854   370   370 I mypackage.mysubpackage.foo@1.0-service: Test:getTest data=(schedutil\n10-02 21:09:09.854   370   370 I mypackage.mysubpackage.foo@1.0-service: )\n10-02 21:09:09.854   370   370 I mypackage.mysubpackage.foo@1.0-service: Test::setTest data=(performance)\n10-02 21:09:09.854   370   370 E mypackage.mysubpackage.foo@1.0-service: write_value failed to open\n10-02 21:09:09.853   370   370 W foo@1.0-service: type=1400 audit(0.0:5): avc: denied { write } for name=\"scaling_governor\" dev=\"sysfs\" ino=19629 scontext=u:r:hal_mysubpackage_default:s0 tcontext=u:object_r:sysfs_devices_system_cpu:s0 tclass=file permissive=0\n10-02 21:09:09.858   370   370 I mypackage.mysubpackage.foo@1.0-service: Test:getTest data=(schedutil\n10-02 21:09:09.858   370   370 I mypackage.mysubpackage.foo@1.0-service: )\n</code></pre> <p>Como \u00e9 um problema do <code>audit</code>, repetimos os passos:</p> <pre><code>adb pull /sys/fs/selinux/policy\nadb logcat -b all -d | audit2allow -p policy\n</code></pre> <p>retornando a mensagem:</p> <p>============= hal_mysubpackage_default ==============  allow hal_mysubpackage_default sysfs_devices_system_cpu:file write;</p> <p>Foi preciso adicionar ao arquivo:</p> hal_mysubpackage_default.te<pre><code>type hal_mysubpackage_default, domain;\ntype hal_mysubpackage_default_exec, exec_type, vendor_file_type, file_type;\n\ninit_daemon_domain(hal_mysubpackage_default);\n\n# allow hal_mysubpackage_default hwservicemanager_prop:file read;\nget_prop(hal_mysubpackage_default, hwservicemanager_prop); \n\n# allow hal_mysubpackage_default hwservicemanager:binder call;\nhwbinder_use(hal_mysubpackage_default);\n\n# allow hal_mysubpackage_default default_android_hwservice:hwservice_manager find;\nadd_hwservice(hal_mysubpackage_default, hal_mysubpackage_hwservice);\n\nallow hal_mysubpackage_default sysfs_devices_system_cpu:file write;\n</code></pre> <p>Rebuildando e execuntado o bin\u00e1rio de teste, temos a seguinte mensagem :</p> <p>getScalingGovernor:schedutil</p> <p>setScalingGovernor:1 getScalingGovernor:performance</p> <p>Obervar que o <code>ScalingGovernor</code> foi alterado para performance. No log de <code>dmesg</code>, n\u00e3o encontramos nenhum tipo de erro:</p> <pre><code>10-02 21:16:46.620   375   375 I mypackage.mysubpackage.foo@1.0-service: Test:getTest data=(schedutil\n10-02 21:16:46.620   375   375 I mypackage.mysubpackage.foo@1.0-service: )\n10-02 21:16:46.620   375   375 I mypackage.mysubpackage.foo@1.0-service: Test::setTest data=(performance)\n10-02 21:16:46.639   375   375 I mypackage.mysubpackage.foo@1.0-service: Test:getTest data=(performance\n10-02 21:16:46.639   375   375 I mypackage.mysubpackage.foo@1.0-service: )\n</code></pre>"},{"location":"android/boards/qemu/hal/hidl/#conclusao","title":"Conclus\u00e3o","text":"<p>Nesse post eu tentei mostrar de forma mais pr\u00e1tica, como \u00e9 implementado uma HIDL. Existe muita teoria envolvida, principalmente na parte de permiss\u00f5es, que s\u00e3o abordadas de uma forma um pouco mais profunda no curso Android 12 Internals material, labs and discussion. Ao final, fiz um aplicativo para testar a implementa\u00e7\u00e3o. </p> <p>\ud83e\udd47</p>"},{"location":"android/boards/vim3/bootloader/Carregando/","title":"Decifrando o BOOTCMD","text":"Image by Gerd Altmann from Pixabay"},{"location":"android/boards/vim3/bootloader/Carregando/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>Na minha saga para desvendar o mundo dos sistemas embarcados, nesse post eu pretendo entender explicar como o u-boot mainline carrega o kernel Android na VIM3.</p>"},{"location":"android/boards/vim3/bootloader/Carregando/#o-bootcmd","title":"O bootcmd","text":"<p>Depois que que o u-boot \u00e9 carregado, ele executa comandos para encontrar o kernel. Para isso, \u00e9 gerado um script para checar as poss\u00edveis formas de carrega-lo. </p> <p>O primeiro passo foi dar o comando printenv no console do u-boot, resultando nas seguintes informa\u00e7\u00f5es:</p> <pre><code>arch=arm\navb_verify=avb init ${mmcdev}; avb verify $slot_suffix;\nbaudrate=115200\nboard=vim3\nboard_name=vim3\nboot_a_script=load ${devtype} ${devnum}:${distro_bootpart} ${scriptaddr} ${prefix}${script}; source ${scriptaddr}\nboot_efi_binary=load ${devtype} ${devnum}:${distro_bootpart} ${kernel_addr_r} efi/boot/bootaa64.efi; if fdt addr -q ${fdt_addr_r}; then bootefi ${kernel_addr_r} ${fdt_addr_r};else bootefi ${kernel_addr_r} ${fdtcontroladdr};fi\nboot_efi_bootmgr=if fdt addr -q ${fdt_addr_r}; then bootefi bootmgr ${fdt_addr_r};else bootefi bootmgr;fi\nboot_extlinux=sysboot ${devtype} ${devnum}:${distro_bootpart} any ${scriptaddr} ${prefix}${boot_syslinux_conf}\nboot_net_usb_start=usb start\nboot_pci_enum=pci enum\nboot_prefixes=/ /boot/\nboot_script_dhcp=boot.scr.uimg\nboot_scripts=boot.scr.uimg boot.scr\nboot_source=sd\nboot_syslinux_conf=extlinux/extlinux.conf\nboot_targets=fastboot recovery system panic \nbootcmd=run distro_bootcmd\nbootcmd_fastboot=setenv run_fastboot 0;if test \"${boot_source}\" = \"usb\"; then echo Fastboot forced by usb rom boot;setenv run_fastboot 1;fi;if test \"${run_fastboot}\" -eq 0; then if gpt verify mmc ${mmcdev} ${partitions}; then; else echo Broken MMC partition scheme;setenv run_fastboot 1;fi; fi;if test \"${run_fastboot}\" -eq 0; then if bcb load 2 misc; then if bcb test command = bootonce-bootloader; then echo BCB: Bootloader boot...; bcb clear command; bcb store; setenv run_fastboot 1;elif bcb test command = boot-fastboot; then echo BCB: fastboot userspace boot...; setenv force_recovery 1;fi; else echo Warning: BCB is corrupted or does not exist; fi;fi;if test \"${run_fastboot}\" -eq 1; then echo Running Fastboot...;fastboot 0; fi\nbootcmd_panic=fastboot 0; reset\nbootcmd_recovery=pinmux dev pinctrl@14;pinmux dev pinctrl@40;setenv run_recovery 0;if run check_button; then echo Recovery button is pressed;setenv run_recovery 1;fi; if bcb load 2 misc; then if bcb test command = boot-recovery; then echo BCB: Recovery boot...; setenv run_recovery 1;fi;else echo Warning: BCB is corrupted or does not exist; fi;if test \"${skip_recovery}\" -eq 1; then echo Recovery skipped by environment;setenv run_recovery 0;fi;if test \"${force_recovery}\" -eq 1; then echo Recovery forced by environment;setenv run_recovery 1;fi;if test \"${run_recovery}\" -eq 1; then echo Running Recovery...;mmc dev ${mmcdev};setenv bootargs \"${bootargs} androidboot.serialno=${serial#}\"; if test \"${force_avb}\" -eq 1; then if run avb_verify; then echo AVB verification OK.;setenv bootargs \"$bootargs $avb_bootargs\";else echo AVB verification failed.;exit; fi;else setenv bootargs \"$bootargs androidboot.verifiedbootstate=orange\";echo Running without AVB...; fi;part start mmc ${mmcdev} recovery${slot_suffix} boot_start;part size mmc ${mmcdev} recovery${slot_suffix} boot_size;if mmc read ${loadaddr} ${boot_start} ${boot_size}; then echo Preparing FDT...; if test $board_name = sei510; then echo \"  Reading DTB for sei510...\"; setenv dtb_index 0;elif test $board_name = sei610; then echo \"  Reading DTB for sei610...\"; setenv dtb_index 1;elif test $board_name = vim3l; then echo \"  Reading DTB for vim3l...\"; setenv dtb_index 2;elif test $board_name = vim3; then echo \"  Reading DTB for vim3...\"; setenv dtb_index 3;else echo Error: Android boot is not supported for $board_name; exit; fi; abootimg get dtb --index=$dtb_index dtb_start dtb_size; cp.b $dtb_start $fdt_addr_r $dtb_size; fdt addr $fdt_addr_r  0x80000; if test $board_name = sei510; then echo \"  Reading DTBO for sei510...\"; setenv dtbo_index 0;elif test $board_name = sei610; then echo \"  Reading DTBO for sei610...\"; setenv dtbo_index 1;elif test $board_name = vim3l; then echo \"  Reading DTBO for vim3l...\"; setenv dtbo_index 2;elif test $board_name = vim3; then echo \"  Reading DTBO for vim3...\"; setenv dtbo_index 3;else echo Error: Android boot is not supported for $board_name; exit; fi; part start mmc ${mmcdev} dtbo${slot_suffix} p_dtbo_start; part size mmc ${mmcdev} dtbo${slot_suffix} p_dtbo_size; mmc read ${dtboaddr} ${p_dtbo_start} ${p_dtbo_size}; echo \"  Applying DTBOs...\"; adtimg addr $dtboaddr; adtimg get dt --index=$dtbo_index dtbo0_addr; fdt apply $dtbo0_addr;setenv bootargs \"$bootargs androidboot.dtbo_idx=$dtbo_index \";echo Running Android Recovery...;bootm ${loadaddr} ${loadaddr} ${fdt_addr_r};fi;echo Failed to boot Android...;reset;fi\nbootcmd_system=echo Loading Android boot partition...;mmc dev ${mmcdev};setenv bootargs ${bootargs} androidboot.serialno=${serial#}; if test \"${force_avb}\" -eq 1; then if run avb_verify; then echo AVB verification OK.;setenv bootargs \"$bootargs $avb_bootargs\";else echo AVB verification failed.;exit; fi;else setenv bootargs \"$bootargs androidboot.verifiedbootstate=orange\";echo Running without AVB...; fi;part start mmc ${mmcdev} boot${slot_suffix} boot_start;part size mmc ${mmcdev} boot${slot_suffix} boot_size;if mmc read ${loadaddr} ${boot_start} ${boot_size}; then echo Preparing FDT...; if test $board_name = sei510; then echo \"  Reading DTB for sei510...\"; setenv dtb_index 0;elif test $board_name = sei610; then echo \"  Reading DTB for sei610...\"; setenv dtb_index 1;elif test $board_name = vim3l; then echo \"  Reading DTB for vim3l...\"; setenv dtb_index 2;elif test $board_name = vim3; then echo \"  Reading DTB for vim3...\"; setenv dtb_index 3;else echo Error: Android boot is not supported for $board_name; exit; fi; abootimg get dtb --index=$dtb_index dtb_start dtb_size; cp.b $dtb_start $fdt_addr_r $dtb_size; fdt addr $fdt_addr_r  0x80000; if test $board_name = sei510; then echo \"  Reading DTBO for sei510...\"; setenv dtbo_index 0;elif test $board_name = sei610; then echo \"  Reading DTBO for sei610...\"; setenv dtbo_index 1;elif test $board_name = vim3l; then echo \"  Reading DTBO for vim3l...\"; setenv dtbo_index 2;elif test $board_name = vim3; then echo \"  Reading DTBO for vim3...\"; setenv dtbo_index 3;else echo Error: Android boot is not supported for $board_name; exit; fi; part start mmc ${mmcdev} dtbo${slot_suffix} p_dtbo_start; part size mmc ${mmcdev} dtbo${slot_suffix} p_dtbo_size; mmc read ${dtboaddr} ${p_dtbo_start} ${p_dtbo_size}; echo \"  Applying DTBOs...\"; adtimg addr $dtboaddr; adtimg get dt --index=$dtbo_index dtbo0_addr; fdt apply $dtbo0_addr;setenv bootargs \"$bootargs androidboot.dtbo_idx=$dtbo_index \";setenv bootargs \"${bootargs}  \"  ; echo Running Android...;bootm ${loadaddr} ${loadaddr} ${fdt_addr_r};fi;echo Failed to boot Android...;\nbootdelay=2\ncheck_button=gpio input ${gpio_recovery};test $? -eq 0;\ncpu=armv8\ndistro_bootcmd=setenv nvme_need_init; for target in ${boot_targets}; do run bootcmd_${target}; done\ndtboaddr=0x08200000\nefi_dtb_prefixes=/ /dtb/ /dtb/current/\nethaddr=c8:63:14:71:2d:35\nfastboot_raw_partition_bootenv=0x0 0xfff mmcpart 2\nfastboot_raw_partition_bootloader=0x1 0xfff mmcpart 1\nfdt_addr_r=0x01000000\nfdtcontroladdr=f0efa100\nfdtfile=amlogic/meson-g12b-a311d-khadas-vim3.dtb\nforce_avb=0\ngpio_recovery=88\nkernel_addr_r=0x01080000\nload_efi_dtb=load ${devtype} ${devnum}:${distro_bootpart} ${fdt_addr_r} ${prefix}${efi_fdtfile}\nload_logo=if test \"${boot_source}\" != \"usb\" &amp;&amp; gpt verify mmc ${mmcdev} ${partitions}; then; mmc dev ${mmcdev};part start mmc ${mmcdev} logo boot_start;part size mmc ${mmcdev} logo boot_size;if mmc read ${loadaddr} ${boot_start} ${boot_size}; then bmp display ${loadaddr} m m;fi;fi;\nloadaddr=0x01080000\nmmc_boot=if mmc dev ${devnum}; then devtype=mmc; run scan_dev_for_boot_part; fi\nmmcdev=2\nnvme_boot=run boot_pci_enum; run nvme_init; if nvme dev ${devnum}; then devtype=nvme; run scan_dev_for_boot_part; fi\nnvme_init=if ${nvme_need_init}; then setenv nvme_need_init false; nvme scan; fi\npartitions=uuid_disk=${uuid_gpt_disk};name=logo,start=512K,size=2M,uuid=43a3305d-150f-4cc9-bd3b-38fca8693846;name=misc,size=512K,uuid=${uuid_gpt_misc};name=dtbo,size=8M,uuid=${uuid_gpt_dtbo};name=vbmeta,size=512K,uuid=${uuid_gpt_vbmeta};name=boot,size=32M,bootable,uuid=${uuid_gpt_boot};name=recovery,size=32M,uuid=${uuid_gpt_recovery};name=cache,size=256M,uuid=${uuid_gpt_cache};name=super,size=1792M,uuid=${uuid_gpt_super};name=userdata,size=12786M,uuid=${uuid_gpt_userdata};name=rootfs,size=-,uuid=ddb8c3f6-d94d-4394-b633-3134139cc2e0;\npxefile_addr_r=0x01080000\nramdisk_addr_r=0x13000000\nscan_dev_for_boot=echo Scanning ${devtype} ${devnum}:${distro_bootpart}...; for prefix in ${boot_prefixes}; do run scan_dev_for_extlinux; run scan_dev_for_scripts; done;run scan_dev_for_efi;\nscan_dev_for_boot_part=part list ${devtype} ${devnum} -bootable devplist; env exists devplist || setenv devplist 1; for distro_bootpart in ${devplist}; do if fstype ${devtype} ${devnum}:${distro_bootpart} bootfstype; then run scan_dev_for_boot; fi; done; setenv devplist\nscan_dev_for_efi=setenv efi_fdtfile ${fdtfile}; for prefix in ${efi_dtb_prefixes}; do if test -e ${devtype} ${devnum}:${distro_bootpart} ${prefix}${efi_fdtfile}; then run load_efi_dtb; fi;done;run boot_efi_bootmgr;if test -e ${devtype} ${devnum}:${distro_bootpart} efi/boot/bootaa64.efi; then echo Found EFI removable media binary efi/boot/bootaa64.efi; run boot_efi_binary; echo EFI LOAD FAILED: continuing...; fi; setenv efi_fdtfile\nscan_dev_for_extlinux=if test -e ${devtype} ${devnum}:${distro_bootpart} ${prefix}${boot_syslinux_conf}; then echo Found ${prefix}${boot_syslinux_conf}; run boot_extlinux; echo SCRIPT FAILED: continuing...; fi\nscan_dev_for_scripts=for script in ${boot_scripts}; do if test -e ${devtype} ${devnum}:${distro_bootpart} ${prefix}${script}; then echo Found U-Boot script ${prefix}${script}; run boot_a_script; echo SCRIPT FAILED: continuing...; fi; done\nscriptaddr=0x08000000\nserial#=C86314712D35\nsoc=meson\nstderr=vidconsole,serial\nstdin=usbkbd,serial\nstdout=vidconsole,serial\nusb_boot=usb start; if usb dev ${devnum}; then devtype=usb; run scan_dev_for_boot_part; fi\nvendor=amlogic\n\nEnvironment size: 9785/65532 bytes\n=&gt; \n</code></pre> <p>Estudaremos inicialmente essa sa\u00edda, come\u00e7ando pelo bootcmd (linha 18). Ele \u00e9 o ponta p\u00e9 inicial para o script.</p> <p>Podemos observar que ele executa outra fun\u00e7\u00e3o:</p> <pre><code>bootcmd=run distro_bootcmd\n</code></pre> <p>Ele executa a distro_bootcmd (linha 26).</p>"},{"location":"android/boards/vim3/bootloader/Carregando/#o-distro_bootcmd","title":"O distro_bootcmd","text":"<p>Essa fun\u00e7\u00e3o \u00e9 um pouco mais elaborada, quebrei em v\u00e1rias linhas. Vamos analiz\u00e1-las</p> <pre><code>distro_bootcmd=\nsetenv nvme_need_init; \nfor target in ${boot_targets}; \n    do run bootcmd_${target}; \ndone\n</code></pre> <p>A flag nvme_need_init n\u00e3o est\u00e1 setada,  mas podemos encontrar alguns detalhes no arquivo:</p> <p>include/config_distro_bootcmd.h</p> <p>No diret\u00f3rio do c\u00f3digo fonte do u-boot, n\u00e3o vou focar nessa linha pois n\u00e3o \u00e9 de interesse utilizar o NVME (ainda ).</p> <p>Seguindo no c\u00f3digo, podemos obsevar que a vari\u00e1vel boot_targets  (atribu\u00edda na linha 17) \u00e9 iterada com os seguintes valores:</p> <pre><code>boot_targets=fastboot recovery system panic \n</code></pre> <p>Cada valor \u00e9 concatenado com a string bootcmd_, resultando em:</p> <ul> <li>bootcmd_fastboot</li> <li>bootcmd_recovery</li> <li>bootcmd_system</li> <li>bootcmd_panic</li> </ul>"},{"location":"android/boards/vim3/bootloader/Carregando/#as-ramificacoes-do-bootcmd_","title":"As ramifica\u00e7\u00f5es do bootcmd_","text":"<p>O distro_bootcmd acaba executando outras 4 fun\u00e7\u00f5es, vamos entender o que elas fazem.</p>"},{"location":"android/boards/vim3/bootloader/Carregando/#o-bootcmd_fastboot","title":"O bootcmd_fastboot","text":"<p>Atribu\u00edda na linha 19, ela possui a seguinte implementa\u00e7\u00e3o:</p> <pre><code>bootcmd_fastboot=\nsetenv run_fastboot 0;\n\nif test \"${boot_source}\" = \"usb\"; then \n    echo Fastboot forced by usb rom boot;\n    setenv run_fastboot 1;\nfi;\n\nif test \"${run_fastboot}\" -eq 0; then \n    if gpt verify mmc ${mmcdev} ${partitions}; then; \n    else \n        echo Broken MMC partition scheme;\n        setenv run_fastboot 1;\n    fi; \nfi;\n\nif test \"${run_fastboot}\" -eq 0; then \n    if bcb load 2 misc; then \n        if bcb test command = bootonce-bootloader; then \n            echo BCB: Bootloader boot...; \n            bcb clear command; \n            bcb store; \n            setenv run_fastboot 1;\n        elif bcb test command = boot-fastboot; then \n            echo BCB: fastboot userspace boot...; \n            setenv force_recovery 1;\n        fi; \n    else \n        echo Warning: BCB is corrupted or does not exist; \n    fi;\nfi;\n\nif test \"${run_fastboot}\" -eq 1; then \n    echo Running Fastboot...;\n    fastboot 0; \nfi\n</code></pre> <p>A flag run_fastboot \u00e9 setada para 0. A vari\u00e1vel boot_source \u00e9 atribu\u00edda na linha 15:</p> <pre><code>boot_source=sd\n</code></pre> <p>Com isso, o primeiro <code>if</code> n\u00e3o \u00e9 acionado. No proximo <code>if</code> j\u00e1 sabemos que <code>run_fastboot==0</code>, ao entrar no <code>if</code> \u00e9 checado a vari\u00e1vel <code>mmcdev</code> que \u00e9 atribu\u00edda na linha 42 e a vari\u00e1vel <code>partitions</code>, atribu\u00edda na linha 45:</p> <pre><code>mmcdev=2\n</code></pre> <pre><code>partitions=\nuuid_disk=${uuid_gpt_disk};\nname=logo,start=512K,size=2M,uuid=43a3305d-150f-4cc9-bd3b-38fca8693846;\nname=misc,size=512K,uuid=${uuid_gpt_misc};\nname=dtbo,size=8M,uuid=${uuid_gpt_dtbo};\nname=vbmeta,size=512K,uuid=${uuid_gpt_vbmeta};\nname=boot,size=32M,bootable,uuid=${uuid_gpt_boot};\nname=recovery,size=32M,uuid=${uuid_gpt_recovery};\nname=cache,size=256M,uuid=${uuid_gpt_cache};\nname=super,size=1792M,uuid=${uuid_gpt_super};\nname=userdata,size=12786M,uuid=${uuid_gpt_userdata};\nname=rootfs,size=-,uuid=ddb8c3f6-d94d-4394-b633-3134139cc2e0;\n</code></pre> <p>Logo, na linha <code>if gpt verify mmc ${mmcdev} ${partitions}; then;</code> \u00e9 checado se as parti\u00e7\u00f5es existem, nesse caso no eMMC da placa (<code>mmcdev=2</code>), caso contr\u00e1rio imprime a mensagem de erro <code>Broken MMC partition scheme;</code> e seta a flag run_fastboot para 1.</p> <p>Mais adiante, \u00e9 checado novamente a flag run_fastboot. Caso as parti\u00e7\u00f5es no eMMC estejam corretas, \u00e9 checado <code>if bcb load 2 misc; then</code>. Essa linha tenta carregar a parti\u00e7\u00e3o <code>misc</code> do eMMC (mais informa\u00e7\u00f5es nesse link). Se tudo der certo, em seguida \u00e9 checado o conte\u00fado da v\u00e1ri\u00e1vel <code>command</code> que foi guardada dentro da parti\u00e7\u00e3o <code>misc</code>: </p> <ul> <li><code>if bcb test command = bootonce-bootloader; then</code> </li> <li><code>elif bcb test command = boot-fastboot; then</code></li> </ul> <p>Caso algum problema ocorra ao carregar a parti\u00e7\u00e3o <code>misc</code>, a seguinte mensagem \u00e9 impressa na tela <code>Warning: BCB is corrupted or does not exist;</code>. </p> <p>O \u00faltimo <code>if</code> checa se a flag run_fastboot \u00e9 1, caso positivo \u00e9 impresso na tela a mensagem <code>Running Fastboot...</code> e entra no modo Fastboot com o comando <code>fastboot 0</code>.</p>"},{"location":"android/boards/vim3/bootloader/Carregando/#o-bootcmd_recovery","title":"O bootcmd_recovery","text":"<p>Atribu\u00eddo na linha 21 e possui a seguinte implementa\u00e7\u00e3o:</p> <pre><code>bootcmd_recovery=\npinmux dev pinctrl@14;\npinmux dev pinctrl@40;\n\nsetenv run_recovery 0;\n\nif run check_button; then \n    echo Recovery button is pressed;\n    setenv run_recovery 1;\nfi; \n\nif bcb load 2 misc; then \n    if bcb test command = boot-recovery; then \n        echo BCB: Recovery boot...; \n        setenv run_recovery 1;\n    fi;\nelse \n    echo Warning: BCB is corrupted or does not exist; \nfi;\n\nif test \"${skip_recovery}\" -eq 1; then \n    echo Recovery skipped by environment;\n    setenv run_recovery 0;\nfi;\n\nif test \"${force_recovery}\" -eq 1; then \n    echo Recovery forced by environment;\n    setenv run_recovery 1;\nfi;\n\nif test \"${run_recovery}\" -eq 1; then \n    echo Running Recovery...;\n    mmc dev ${mmcdev};\n    setenv bootargs \"${bootargs} androidboot.serialno=${serial#}\"; \n    if test \"${force_avb}\" -eq 1; then \n        if run avb_verify; then \n            echo AVB verification OK.;\n            setenv bootargs \"$bootargs $avb_bootargs\";\n        else \n            echo AVB verification failed.;\n            exit; \n        fi;\n    else \n        setenv bootargs \"$bootargs androidboot.verifiedbootstate=orange\";\n        echo Running without AVB...; \n    fi;\n\n    part start mmc ${mmcdev} recovery${slot_suffix} boot_start;\n    part size mmc ${mmcdev} recovery${slot_suffix} boot_size;\n\n    if mmc read ${loadaddr} ${boot_start} ${boot_size}; then \n\n        echo Preparing FDT...; \n        if test $board_name = sei510; then \n            echo \"  Reading DTB for sei510...\"; \n            setenv dtb_index 0;\n        elif test $board_name = sei610; then \n            echo \"  Reading DTB for sei610...\"; \n            setenv dtb_index 1;\n        elif test $board_name = vim3l; then \n            echo \"  Reading DTB for vim3l...\"; \n            setenv dtb_index 2;\n        elif test $board_name = vim3; then \n            echo \"  Reading DTB for vim3...\"; \n            setenv dtb_index 3;\n        else \n            echo Error: Android boot is not supported for $board_name; \n            exit; \n        fi;\n\n        abootimg get dtb --index=$dtb_index dtb_start dtb_size; \n        cp.b $dtb_start $fdt_addr_r $dtb_size; \n        fdt addr $fdt_addr_r  0x80000; \n\n        if test $board_name = sei510; then \n            echo \"  Reading DTBO for sei510...\"; \n            setenv dtbo_index 0;\n        elif test $board_name = sei610; then \n            echo \"  Reading DTBO for sei610...\"; \n            setenv dtbo_index 1;\n        elif test $board_name = vim3l; then \n            echo \"  Reading DTBO for vim3l...\"; \n            setenv dtbo_index 2;\n        elif test $board_name = vim3; then \n            echo \"  Reading DTBO for vim3...\"; \n            setenv dtbo_index 3;\n        else \n            echo Error: Android boot is not supported for $board_name; \n            exit; \n        fi; \n\n        part start mmc ${mmcdev} dtbo${slot_suffix} p_dtbo_start; \n        part size mmc ${mmcdev} dtbo${slot_suffix} p_dtbo_size; \n        mmc read ${dtboaddr} ${p_dtbo_start} ${p_dtbo_size}; \n        echo \"  Applying DTBOs...\"; \n        adtimg addr $dtboaddr; \n        adtimg get dt --index=$dtbo_index dtbo0_addr; \n        fdt apply $dtbo0_addr;\n        setenv bootargs \"$bootargs androidboot.dtbo_idx=$dtbo_index \";\n        echo Running Android Recovery...;\n        bootm ${loadaddr} ${loadaddr} ${fdt_addr_r};\n    fi;\n    echo Failed to boot Android...;\n    reset;\nfi\n</code></pre> <p>As duas primeiras linhas:</p> <pre><code>pinmux dev pinctrl@14;\npinmux dev pinctrl@40;\n</code></pre> <p>A pr\u00edncipio n\u00e3o funcionam, tentei ver o status desses pinos e retornaram <code>pinctrl@14 not found</code> e <code>pinctrl@40 not found</code>. Talvez esteja faltando alguma implementa\u00e7\u00e3o.</p> <p>Seguindo no c\u00f3digo, a flag run_recovery \u00e9 setada para 0 e ent\u00e3o a fun\u00e7\u00e3o <code>check_button</code> \u00e9 checada. Ela foi atribu\u00edda na linha 24:</p> <p><pre><code>check_button=gpio input ${gpio_recovery};test $? -eq 0;\n</code></pre> Na linha 36 a vari\u00e1vel <code>gpio_recovery=88</code> \u00e9 atribu\u00edda. Por padr\u00e3o, esse GPIO \u00e9 setado para 1 <code>gpio: pin 88 (gpio 88) value is 1</code>, logo o valor retornado \u00e9 falso. Dessa forma, a compara\u00e7\u00e3o <code>if run check_button; then</code> n\u00e3o \u00e9 acionada.</p> <p>Mais adiante, a parti\u00e7\u00e3o <code>misc</code> \u00e9 carregada novamente e \u00e9 checado se a vari\u00e1vel <code>command</code> est\u00e1 setada para <code>boot-recovery</code>. Em seguinda, a v\u00e1ri\u00e1vel <code>skip_recovery</code> n\u00e3o est\u00e1 setada, logo n\u00e3o entra no pr\u00f3ximo <code>if</code>.</p> <p>Se a vari\u00e1vel <code>force_recovery</code> foi setada na etapa do bootcmd_fastboot, ent\u00e3o a linha <code>if test \"${force_recovery}\" -eq 1; then</code> \u00e9 acionada \u00e9 a vari\u00e1vel a flag run_recovery \u00e9 setada para 1. Isso faz com que o pr\u00f3ximo <code>if</code> seja acionado (<code>if test \"${run_recovery}\" -eq 1; then</code>) e come\u00e7ar o processo de entrar no modo Recovery.</p> <p>Vimos na se\u00e7\u00e3o anterior que <code>mmcdev=2</code>. Com isso, o comando <code>mmc dev ${mmcdev};</code> ativa o eMMC. A pr\u00f3xima linha adiciona a vari\u00e1vel <code>bootargs</code> a propriedade <code>androidboot.serialno=${serial#}</code>. A vari\u00e1vel <code>serial#</code> \u00e9 atribu\u00edda na linha 54:</p> <pre><code>serial#=C86314712D35\n</code></pre> <p>Seguindo, \u00e9 checado a v\u00e1ri\u00e1vel <code>force_avb=0</code>, atribu\u00edda na linha 35. Como o Android Verified Boot (AVB) n\u00e3o est\u00e1 setado, \u00e9 adicionado mais uma propriedade ao <code>bootargs</code>:</p> <pre><code>setenv bootargs \"$bootargs androidboot.verifiedbootstate=orange\";\n</code></pre> <p>Mais a frente, temos a linha:</p> <pre><code>part start mmc ${mmcdev} recovery${slot_suffix} boot_start;\n</code></pre> <p>a vari\u00e1vel <code>slot_suffix</code> n\u00e3o est\u00e1 setada. Dessa forma, essa linha procura o inicio da parti\u00e7\u00e3o recovery dentro do eMMC e adiciona o valor na vari\u00e1vel <code>boot_start</code>. A linha: </p> <pre><code>part size mmc ${mmcdev} recovery${slot_suffix} boot_size;\n</code></pre> <p>\u00e9 semelhante, mas nesse caso armazena o tamanho da parti\u00e7\u00e3o recovery na vari\u00e1vel <code>boot_size</code>.</p> <p>Na linha seguinte:</p> <pre><code>if mmc read ${loadaddr} ${boot_start} ${boot_size}; then \n</code></pre> <p>a vari\u00e1vel <code>loadaddr=0x01080000</code> \u00e9 atribu\u00edda na linha 40. A parti\u00e7\u00e3o recovery \u00e9 carregada e se tudo ocorrer corretamente, segue dentro do <code>if</code>. A vari\u00e1vel <code>board_name=vim3</code> \u00e9 atribu\u00edda na linha 5, consequentemente, setando a flag <code>setenv dtb_index 3;</code>.</p> <p>A pr\u00f3xima linha:</p> <pre><code>abootimg get dtb --index=$dtb_index dtb_start dtb_size; \n</code></pre> <p>Armazena o endere\u00e7o e o tamanho do Device Tree Blob (DTB) nas vari\u00e1veis <code>dtb_start</code> e <code>dtb_size</code>, respectivamente.</p> <p>Seguindo, temos:</p> <pre><code>cp.b $dtb_start $fdt_addr_r $dtb_size;\n</code></pre> <p>a vari\u00e1vel <code>fdt_addr_r=0x01000000</code> \u00e9 atribu\u00edda na linha 32. A linha acima copia o conte\u00fado do DTB para o endere\u00e7o da vari\u00e1vel <code>fdt_addr_r</code>.</p> <p>Ap\u00f3s isso, a localiza\u00e7\u00e3o do ftd \u00e9 setada para o endere\u00e7o <code>0x80000</code>, pelo comando:</p> <pre><code>fdt addr $fdt_addr_r  0x80000;\n</code></pre> <p>Agora \u00e9 necess\u00e1rio carregar o Device Tree Blob Overlay (DTBO). Para isso, \u00e9 checando novamente a var\u00edavel <code>board_name</code>, consequentemente, a flag <code>setenv dtb_index 3</code> \u00e9 setada. As seguintes linhas tem fun\u00e7\u00e3o similar as anteriores:</p> <pre><code>part start mmc ${mmcdev} dtbo${slot_suffix} p_dtbo_start; \npart size mmc ${mmcdev} dtbo${slot_suffix} p_dtbo_size; \nmmc read ${dtboaddr} ${p_dtbo_start} ${p_dtbo_size}; \n</code></pre> <p>a vari\u00e1vel <code>dtboaddr=0x08200000</code> \u00e9 atribu\u00edda na linha 27. </p> <p>As linhas:</p> <pre><code>adtimg addr $dtboaddr; \nadtimg get dt --index=$dtbo_index dtbo0_addr; \nfdt apply $dtbo0_addr;\n</code></pre> <p>Seta a localiza\u00e7\u00e3o da imagem do DTBO para o endere\u00e7o da vari\u00e1vel <code>dtboaddr</code>, armazena o endere\u00e7o do DTBO na vari\u00e1vel <code>dtbo0_addr</code>. Por fim, aplica o DTBO no DTB.</p> <p>Na linha seguinte, \u00e9 adicionado a propriedade <code>setenv bootargs \"$bootargs androidboot.dtbo_idx=$dtbo_index \"</code> na vari\u00e1vel <code>bootargs</code>.</p> <p>Finalmente, na linha:</p> <pre><code>bootm ${loadaddr} ${loadaddr} ${fdt_addr_r};\n</code></pre> <p>faz o boot da imagem de recovery.</p>"},{"location":"android/boards/vim3/bootloader/Carregando/#o-bootcmd_system","title":"O bootcmd_system","text":"<p>Atribu\u00eddo na linha 22, ele possui a seguinte implementa\u00e7\u00e3o:</p> <pre><code>bootcmd_system=\n\necho Loading Android boot partition...;\n\nmmc dev ${mmcdev};\nsetenv bootargs ${bootargs} androidboot.serialno=${serial#}; \n\nif test \"${force_avb}\" -eq 1; then \n    if run avb_verify; then \n        echo AVB verification OK.;\n        setenv bootargs \"$bootargs $avb_bootargs\";\n    else \n        echo AVB verification failed.;\n        exit; \n    fi;\nelse \n    setenv bootargs \"$bootargs androidboot.verifiedbootstate=orange\";\n    echo Running without AVB...; \nfi;\n\npart start mmc ${mmcdev} boot${slot_suffix} boot_start;\npart size mmc ${mmcdev} boot${slot_suffix} boot_size;\n\nif mmc read ${loadaddr} ${boot_start} ${boot_size}; then \n    echo Preparing FDT...; \n    if test $board_name = sei510; then\n        echo \"  Reading DTB for sei510...\"; \n        setenv dtb_index 0;\n    elif test $board_name = sei610; then \n        echo \"  Reading DTB for sei610...\"; \n        setenv dtb_index 1;\n    elif test $board_name = vim3l; then \n        echo \"  Reading DTB for vim3l...\"; \n        setenv dtb_index 2;\n    elif test $board_name = vim3; then \n        echo \"  Reading DTB for vim3...\"; \n        setenv dtb_index 3;\n    else \n        echo Error: Android boot is not supported for $board_name; \n        exit; \n    fi; \n\n    abootimg get dtb --index=$dtb_index dtb_start dtb_size; \n    cp.b $dtb_start $fdt_addr_r $dtb_size; \n    fdt addr $fdt_addr_r  0x80000; \n\n    if test $board_name = sei510; then \n        echo \"  Reading DTBO for sei510...\"; \n        setenv dtbo_index 0;\n    elif test $board_name = sei610; then\n        echo \"  Reading DTBO for sei610...\";\n        setenv dtbo_index 1;\n    elif test $board_name = vim3l; then \n        echo \"  Reading DTBO for vim3l...\"; \n        setenv dtbo_index 2;\n    elif test $board_name = vim3; then\n        echo \"  Reading DTBO for vim3...\"; \n        setenv dtbo_index 3;\n    else \n        echo Error: Android boot is not supported for $board_name; \n        exit; \n    fi; \n\n    part start mmc ${mmcdev} dtbo${slot_suffix} p_dtbo_start; \n    part size mmc ${mmcdev} dtbo${slot_suffix} p_dtbo_size; \n    mmc read ${dtboaddr} ${p_dtbo_start} ${p_dtbo_size}; \n    echo \"  Applying DTBOs...\";\n    adtimg addr $dtboaddr;\n    adtimg get dt --index=$dtbo_index dtbo0_addr; \n    fdt apply $dtbo0_addr;\n    setenv bootargs \"$bootargs androidboot.dtbo_idx=$dtbo_index \";\n    setenv bootargs \"${bootargs}  \"  ; \n\n    echo Running Android...;\n\n    bootm ${loadaddr} ${loadaddr} ${fdt_addr_r};\nfi;\n\necho Failed to boot Android...;\n</code></pre> <p>Todo o processo \u00e9 o mesmo do modo recovery a diferen\u00e7a fica nas seguintes linhas:</p> <pre><code>part start mmc ${mmcdev} boot${slot_suffix} boot_start;\npart size mmc ${mmcdev} boot${slot_suffix} boot_size;\n</code></pre> <p>Observe que agora o script busca pela parti\u00e7\u00e3o <code>boot</code>. O resto segue inalterado.</p>"},{"location":"android/boards/vim3/bootloader/Carregando/#o-bootcmd_panic","title":"O bootcmd_panic","text":"<p>Atribu\u00eddo na linha 20, ele possui a seguinte implementa\u00e7\u00e3o:</p> <pre><code>bootcmd_panic=fastboot 0; reset\n</code></pre> <p>Como \u00faltimo recurso, caso n\u00e3o tenha sido poss\u00edvel fazer o boot do Android. O script entra no modo fastboot e ao sair ele reinicia a VIM3.</p>"},{"location":"android/boards/vim3/bootloader/Carregando/#conclusao","title":"Conclus\u00e3o","text":"<p>Sem d\u00favida entender esse processo n\u00e3o \u00e9 algo trivial, n\u00e3o existe uma padroniza\u00e7\u00e3o e tudo fica na m\u00e3o do desenvolvedor na hora de criar o script respons\u00e1vel por carregar o kernel do Android. Com certeza, esse passo foi fundamental para um melhor entendimento de como o Android funciona.</p>"},{"location":"android/boards/vim3/bootloader/u-boot/","title":"U-boot","text":"Image by ipicgr from Pixabay"},{"location":"android/boards/vim3/bootloader/u-boot/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>Com o intuito armazenar a maior quantidade de informa\u00e7\u00e3o poss\u00edvel aqui no blog, percebi que ainda nao tinha registrado a forma de flashar o u-boot na vim 3. Que a princ\u00edpio n\u00e3o \u00e9 uma tarefa trivial, mas vou descrever os passos.</p>"},{"location":"android/boards/vim3/bootloader/u-boot/#baixando-u-boot","title":"Baixando U-boot","text":"<p>O u-boot mainline j\u00e1 possui suporte a VIM3. Devido isso, estou usando ele ao inv\u00e9s do fornecido pela pr\u00f3pria Khadas. Essa escolha possui alguns impactos, pois o u-boot fornecido pela Khadas possui algumas implementa\u00e7\u00f5es de comandos que facilitam a usabilidade, como os comandos KBI. Em contra partida eles usam uma vers\u00e3o antiga do u-boot e meu foco \u00e9 trabalhar no mainline.</p> <p>O primeiro passo \u00e9 clonar o reposit\u00f3rio:</p> <pre><code>git clone https://github.com/u-boot/u-boot.git\n</code></pre>"},{"location":"android/boards/vim3/bootloader/u-boot/#dependencias","title":"Depend\u00eancias","text":"<p>Como a arquitetura do meu PC \u00e9 <code>x86_64</code> e a VIM3 usa a <code>aarch64</code>, \u00e9 necess\u00e1rio utilizar um <code>toolchain</code> para fazer o cross-compile. Atualmente estou utilizando o gcc-arm-10.3-2021.07-x86_64-aarch64-none-elf, mas talvez seja melhor baixar a vers\u00e3o mais atual no site da arm e procurar por aarch64-none-elf.</p> <p>Para facilitar, eu adiciono o caminho dos bin\u00e1rios da <code>toolchain</code>:</p> <pre><code>export PATH=/home/joao/Documents/boards/VIM3/1_bootloader/Android/gcc-arm-10.3-2021.07-x86_64-aarch64-none-elf/bin:$PATH\n</code></pre>"},{"location":"android/boards/vim3/bootloader/u-boot/#compilando-o-u-boot","title":"Compilando o U-boot","text":"<p>Esses passos s\u00e3o executados dentro da pasta u-boot</p> <p>O primeiro passo da compila\u00e7\u00e3o \u00e9 carregar o <code>defconfig</code>. Para o Android o nome do arquivo \u00e9 <code>khadas-vim3_android_defconfig</code> ele se encontra dentro da pasta <code>configs/</code>. Para carregar o esse arquivo utilizo o comando:</p> <pre><code>make CROSS_COMPILE=aarch64-none-elf- O=../out_android/ khadas-vim3_android_defconfig\n</code></pre> <p>Caso seja necess\u00e1rio fazer alguma altera\u00e7\u00e3o nas configura\u00e7\u00f5es, basta utilizar o seguinte comando: </p> <pre><code>make CROSS_COMPILE=aarch64-none-elf- O=../out_android/ menuconfig\n</code></pre> <p>Por fim, para compilar basta usar o comando:</p> <pre><code>make CROSS_COMPILE=aarch64-none-elf- O=../out_android/\n</code></pre> <p>Os arquivos compilados estar\u00e3o dentro da pasta out_android.</p>"},{"location":"android/boards/vim3/bootloader/u-boot/#adicionando-assinatura","title":"Adicionando assinatura","text":"<p>Para que a VIM3 reconhe\u00e7a o u-boot compilado, \u00e9 necess\u00e1rio adicionar uma assinatura no come\u00e7o do bin\u00e1rio gerado. Para isso, podemos utilizar um script:</p> <pre><code>git clone https://github.com/LibreELEC/amlogic-boot-fip.git\n</code></pre> <p>Para armazenar o u-boot assinado, criei uma pasta com o nome <code>assinado</code>.</p> <p>Agora, para adicionar a assinatura, utilizo o seguinte comando dentro da pasta <code>amlogic-boot-fip</code>:</p> <pre><code>./build-fip.sh khadas-vim3 ../out_android/u-boot.bin ../assinado\n</code></pre> <p>Ele ir\u00e1 buscar o u-boot compilado, adicionar a assinatura e salvar na pasta com o nome assinado.</p>"},{"location":"android/boards/vim3/bootloader/u-boot/#estrutura-das-pastas","title":"Estrutura das pastas","text":"<p>Para facilitar o entendimento das pastas, essa \u00e9 a hierarquia final:</p> <pre><code>.\n\u251c\u2500\u2500 amlogic-boot-fip\n\u251c\u2500\u2500 assinado\n\u251c\u2500\u2500 gcc-arm-10.3-2021.07-x86_64-aarch64-none-elf\n\u251c\u2500\u2500 out_android\n\u2514\u2500\u2500 u-boot\n</code></pre>"},{"location":"android/boards/vim3/bootloader/u-boot/#flashando-o-u-boot","title":"Flashando o U-boot","text":"<p>\u00c9 necess\u00e1rio um programa extra para flashar o u-boot no mmc da VIM3, que pode ser baixado nesse link. No meu caso, eu coloquei o programa dentro da pasta <code>assinado</code>.</p> <p>Agora \u00e9 necess\u00e1rio colocar a VIM3 em um modo especial, para isso ela precisa estar conectado ao computador pela porta USB-C e depois apertar rapidamente 3 vezes no bot\u00e3o do meio (Function Button), entre o bot\u00e3o de <code>power</code> e o de <code>reset</code>. O led azul da placa ir\u00e1 piscar rapidamente durante um espa\u00e7o de tempo, informando que ele entrou nesse modo especial.</p> <p>Agora, para flashar o u-boot podemos seguir os passos desse tutorial. Adaptando para o cen\u00e1rio desse post, dentro da pasta <code>assinado</code>, eu utilizo os seguintes comandos:</p> <pre><code>./update write u-boot.bin 0xfffa0000 0x10000\n./update run 0xfffa0000\n./update bl2_boot u-boot.bin\n</code></pre> <p>Talvez seja necess\u00e1rio ser super usu\u00e1rio para executar esses comandos</p> <p>Depois disso, a VIM3 entrar\u00e1 em modo Fastboot, e ent\u00e3o podemos executar os seguintes comandos:</p> <pre><code>fastboot oem format\nfastboot flash bootloader u-boot.bin\nfastboot erase bootenv\n</code></pre> <p>Para instalar o fastboot: sudo apt install fastboot.</p> <p>Reset a placa e pronto, o u-boot estar\u00e1 funcionando. Para ver os logs do u-boot \u00e9 necess\u00e1rio usar a porta UART. </p>"},{"location":"android/boards/vim3/hal/aidl/","title":"Blink Led AIDL","text":"Image by Wilson Nantes from Pixabay <p>Vale ressaltar que para esse post \u00e9 necess\u00e1rio j\u00e1 ter um produto buildado e para o ultimo t\u00f3pico \u00e9 preciso do display j\u00e1 em funcionamento.</p>"},{"location":"android/boards/vim3/hal/aidl/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>Depois de fazer o curso Android 12 Internals material, labs and discussion, resolvi implementar um blink led utilizando a AIDL, e c\u00e1 estou registrando os meus passos aqui .</p>"},{"location":"android/boards/vim3/hal/aidl/#informacoes-uteis","title":"Informa\u00e7\u00f5es \u00fateis","text":"<ul> <li>Vers\u00e3o do AOSP: <code>android-12.0.0_r4</code></li> <li>Vers\u00e3o do kernel Android: <code>android-amlogic-bmeson-5.4</code></li> <li>Distro para compila\u00e7ao: <code>Linux Mint 20.3</code></li> <li>Vers\u00e3o do kernel da distro: <code>5.15.0-52-generic</code></li> </ul>"},{"location":"android/boards/vim3/hal/aidl/#implementacao","title":"Implementa\u00e7\u00e3o","text":"<p>Tentarei seguir os mesmos t\u00f3picos do post: Implementando a AIDL.</p>"},{"location":"android/boards/vim3/hal/aidl/#hal","title":"HAL","text":"<p>Na raiz da pasta do AOSP criei o seguinte caminho:</p> <pre><code>mkdir -p device/casa/placamae/interfaces/userled/aidl/\n</code></pre> <p>Dentro da pasta, criei o seguinte arquivo:</p> Android.bp<pre><code>aidl_interface {\n  name: \"placamae.hal.userled\",\n  vendor: true,\n  srcs: [\"placamae/hal/userled/*.aidl\"],\n  stability: \"vintf\",\n  owner: \"Jao\",\n  backend: {\n    cpp: {\n      enabled: false, //enabled by default\n    },\n    java: {\n      sdk_version: \"module_current\",\n    },\n    ndk: {\n      //ndk_platform is generated too, but it will deprecated on Android 13.\n      //just ndk will be available.\n      enabled: true, //enabled by default, just exposing\n    }\n  },\n}\n</code></pre> <p>ainda dentro da pasta, criei o seguinte caminho:</p> <p><pre><code>mkdir -p placamae/hal/userled\n</code></pre> com o seguinte arquivo:</p> <p>IUserLed.aidl<pre><code>package placamae.hal.userled;\n\n@VintfStability\ninterface IUserLed{\n    boolean setMode(in String mode);\n}\n</code></pre> O resultado foi esse:</p> <pre><code>device/casa/placamae/interfaces/userled/aidl\n\u251c\u2500\u2500 Android.bp\n\u2514\u2500\u2500 placamae\n    \u2514\u2500\u2500 hal\n        \u2514\u2500\u2500 userled\n            \u2514\u2500\u2500 IUserLed.aidl\n</code></pre> <p>Agora \u00e9 s\u00f3 adicionar ao produto, no meu caso:</p> meuproduto.mk<pre><code>...\nPRODUCT_PACKAGES += \\\n  placamae.hal.userled\n</code></pre> <p>Agora vamos gerar os arquivos fonte para a AIDL. Para isso, na pasta raiz do AOSP, digite:</p> <p><pre><code>m placamae.hal.userled-update-api\n</code></pre> Esse comando vai gerar a pasta <code>aidl_api</code>:</p> <pre><code>device/casa/placamae/interfaces/userled/aidl\n\u251c\u2500\u2500 aidl_api\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 placamae.hal.userled\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 current\n\u2502\u00a0\u00a0         \u2514\u2500\u2500 placamae\n\u2502\u00a0\u00a0             \u2514\u2500\u2500 hal\n\u2502\u00a0\u00a0                 \u2514\u2500\u2500 userled\n\u2502\u00a0\u00a0                     \u2514\u2500\u2500 IUserLed.aidl\n\u251c\u2500\u2500 Android.bp\n\u2514\u2500\u2500 placamae\n    \u2514\u2500\u2500 hal\n        \u2514\u2500\u2500 userled\n            \u2514\u2500\u2500 IUserLed.aidl\n</code></pre> <p>Agora dentro da pasta <code>device/casa/placamae/interfaces/userled/aidl</code>, digite o comando:</p> <pre><code>mm\n</code></pre> <p>Ela ir\u00e1 gerar as classes necess\u00e1rias dentro da pasta :</p> <pre><code>out_placamae/soong/.intermediates/device/casa/placamae/interfaces/userled/aidl\n\u251c\u2500\u2500 placamae.hal.userled-api\n\u251c\u2500\u2500 placamae.hal.userled-V1-java\n\u251c\u2500\u2500 placamae.hal.userled-V1-java-source\n\u251c\u2500\u2500 placamae.hal.userled-V1-ndk\n\u251c\u2500\u2500 placamae.hal.userled-V1-ndk_platform\n\u251c\u2500\u2500 placamae.hal.userled-V1-ndk_platform-source\n\u2514\u2500\u2500 placamae.hal.userled-V1-ndk-source\n</code></pre>"},{"location":"android/boards/vim3/hal/aidl/#servico","title":"Servi\u00e7o","text":"<p>Criei a pasta <code>device/casa/placamae/interfaces/userled/aidl/default/</code>, e dentro dela os arquivos:</p> UserLed.h<pre><code>// This library is available on:\n// out/soong/.intermediates/device/casa/placamae/interfaces/userled/aidl/\n// inside: \n// placamae.hal.userled-V1-ndk_platform-source/gen/include/aidl/placamae/hal/userled\n#include &lt;aidl/placamae/hal/userled/BnUserLed.h&gt;\n\nnamespace aidl::placamae::hal::userled {\n  class UserLed : public BnUserLed {\n    public:\n      static inline const char RED_LED[] = \"/sys/devices/platform/leds/leds/vim3:red/trigger\";\n\n    public:\n      ndk::ScopedAStatus setMode(const std::string &amp;in_mode, bool *_aidl_return) override;\n      static int writeValue(const char *file, const char *value);\n  };\n}\n</code></pre> UserLed.cpp<pre><code>#include \"UserLed.h\"\n\n#include &lt;utils/Log.h&gt;\n#include &lt;android-base/logging.h&gt;\n#include &lt;sys/stat.h&gt;\n\nnamespace aidl::placamae::hal::userled {\n\n  int UserLed::writeValue(const char *file, const char *value) {\n\n    int fd;\n    int str_len = strlen(value) + 1;\n\n    fd = open(file, O_WRONLY);\n\n    if (fd &lt; 0) {\n      return -1;\n    }\n\n    if(!write(fd, value, str_len)){\n      close(fd);\n      return -1;\n    }  \n\n    close(fd);\n    return 0;\n  }\n\n  ndk::ScopedAStatus UserLed::setMode(const std::string &amp;in_mode, bool *_aidl_return) {\n    LOG(INFO) &lt;&lt; \"UserLed -&gt; setMode data=(\" &lt;&lt; in_mode.c_str() &lt;&lt; \")\";\n    *_aidl_return = this-&gt;writeValue(RED_LED, in_mode.c_str()) == 0;\n    return ndk::ScopedAStatus::ok();\n  }\n}\n</code></pre> service.cpp<pre><code>#define LOG_TAG \"placamae.hal.userled\"\n#include &lt;android-base/logging.h&gt;\n#include &lt;android/binder_process.h&gt;\n#include &lt;binder/ProcessState.h&gt;\n\n#include &lt;android/binder_manager.h&gt;\n#include &lt;binder/IServiceManager.h&gt;\n\n#include \"UserLed.h\"\n\nusing aidl::placamae::hal::userled::UserLed;\nusing std::string_literals::operator\"\"s;\n\nint main(){\n    LOG(INFO) &lt;&lt; \"UserLed -&gt; TESSSSSSTE\";\n    const std::string name = UserLed::descriptor + \"/default\"s;\n\n    android::ProcessState::initWithDriver(\"/dev/vndbinder\");\n\n    ABinderProcess_startThreadPool();\n\n    LOG(INFO) &lt;&lt; \"UserLed -&gt; Service is starting...\";\n\n    std::shared_ptr&lt;UserLed&gt; userLed = ndk::SharedRefBase::make&lt;UserLed&gt;();\n\n    CHECK_EQ(STATUS_OK, AServiceManager_addService(userLed-&gt;asBinder().get(), name.c_str()));\n\n    LOG(INFO) &lt;&lt; \"UserLed -&gt; started...\";\n\n    ABinderProcess_joinThreadPool();\n\n    return EXIT_FAILURE;  // should not reach\n}\n</code></pre> Android.bp<pre><code>cc_binary {\n  name: \"placamae.hal.userled-service\",\n  vendor: true,\n  relative_install_path: \"hw\",\n  init_rc: [\"placamae.hal.userled-service.rc\"],\n  vintf_fragments: [\"placamae.hal.userled-service.xml\"],\n\n  srcs: [\n    \"service.cpp\",\n    \"UserLed.cpp\"\n  ],\n\n  cflags: [\n    \"-Wall\",\n    \"-Werror\",\n  ],\n\n  shared_libs: [\n    \"libbase\",\n    \"liblog\",\n    \"libhardware\",\n    \"libbinder_ndk\",\n    \"libbinder\",\n    \"libutils\",\n    //ndk_platform will be deprecated on Android 13. \n    \"placamae.hal.userled-V1-ndk_platform\",\n  ],\n}\n</code></pre> placamae.hal.userled-service.rc<pre><code>service placamae.hal.userled-service /vendor/bin/hw/placamae.hal.userled-service\n    interface aidl placamae.hal.userled-service.IUserLed/default\n    class hal\n    user system\n    group system\n\non boot\n    chown system system /sys/devices/platform/leds/leds/vim3:red/trigger\n    chmod 0660 /sys/devices/platform/leds/leds/vim3:red/trigger\n</code></pre> placamae.hal.userled-service.xml<pre><code>&lt;manifest version=\"1.0\" type=\"device\"&gt;\n    &lt;hal format=\"aidl\"&gt;\n        &lt;name&gt;placamae.hal.userled&lt;/name&gt;\n        &lt;version&gt;1&lt;/version&gt;\n        &lt;fqname&gt;IUserLed/default&lt;/fqname&gt;\n    &lt;/hal&gt;\n&lt;/manifest&gt;\n</code></pre> <p>Agora s\u00f3 resta adicionar o servi\u00e7o ao produto:</p> meuproduto.mk<pre><code>...\nPRODUCT_PACKAGES += \\\n  placamae.hal.userled \\\n  placamae.hal.userled-service\n</code></pre>"},{"location":"android/boards/vim3/hal/aidl/#permissoes","title":"Permiss\u00f5es","text":"<p>Para facilitar a implementa\u00e7\u00e3o, foi definido a permiss\u00e3o permissiva, mas ainda \u00e9 necess\u00e1rio subir o servi\u00e7o. Essa etapa \u00e9 feita via sepolicy.</p> <p>Para isso, criei a pasta:</p> <pre><code>mkdir -p device/casa/placamae/sepolicy\n</code></pre> <p>Dentro dela criei os arquivos:</p> file_contexts<pre><code>/vendor/bin/hw/placamae\\.hal\\.userled-service         u:object_r:hal_userled_default_exec:s0\n</code></pre> hal_userled_default.te<pre><code>type hal_userled_default, domain;\ntype hal_userled_default_exec, exec_type, vendor_file_type, file_type;\n\ninit_daemon_domain(hal_userled_default);\n</code></pre> <p>Por fim, adicionei a pasta sepolicy no: </p> BoardConfig.mk<pre><code>...\nBOARD_SEPOLICY_DIRS += device/casa/placamae/sepolicy\n</code></pre>"},{"location":"android/boards/vim3/hal/aidl/#testando","title":"Testando","text":"<p>Para testar a HAL, criei a pasta:</p> <p><pre><code>mkdir -p device/casa/placamae/interfaces/userled/aidl/default/LedTest\n</code></pre> e dentro dela os seguintes arquivos:</p> LedTest.cpp<pre><code>#include &lt;aidl/placamae/hal/userled/IUserLed.h&gt;\n#include &lt;android/binder_manager.h&gt;\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nusing ::aidl::placamae::hal::userled::IUserLed;\n\n\nint main(int argc, char *argv[]) {\n\n    std::shared_ptr&lt;IUserLed&gt; mHal;\n    std::string a;\n    bool c;\n\n    if (argc != 2) {\n        std::cout &lt;&lt; \"USAGE ./LedTest &lt;none|heartbeat|default-on&gt;\\n\";\n        exit(0);\n    }\n\n    AIBinder* binder = AServiceManager_waitForService(\"placamae.hal.userled.IUserLed/default\");\n\n    if (binder == nullptr){\n        std::cout &lt;&lt; \"Failed to get cpu service\\n\";\n        exit(-1);\n    }\n\n    mHal = IUserLed::fromBinder(ndk::SpAIBinder(binder));\n\n    mHal-&gt;setMode(argv[1], &amp;c);\n    std::cout &lt;&lt; \"setScalingGovernor:\" &lt;&lt; c &lt;&lt; std::endl;\n\n\n    return 0;\n}\n</code></pre> Android.bp<pre><code>cc_binary {\n    name: \"LedTest\",\n    vendor: true,\n    relative_install_path: \"hw\",\n\n    srcs: [\"LedTest.cpp\"],\n\n    shared_libs: [\n        \"libbase\",\n        \"liblog\",\n        \"libhardware\",\n        \"libbinder_ndk\",\n        \"libbinder\",\n        \"libutils\",\n        //ndk_platform will be deprecated on Android 13. \n        \"placamae.hal.userled-V1-ndk_platform\",\n    ],\n}\n</code></pre> <p>Na pasta raiz do AOSP: </p> <pre><code>m -j16\n</code></pre> <p>Depois de terminar a build, flashei os bin\u00e1rios e esperei o Android subir para ter acesso ao ADB. Para testar o servi\u00e7o, utilizei os comandos: </p> <pre><code>adb root\nadb shell\ncd /vendor/bin/hw\n./LedTest heartbeat\n</code></pre> <p>Ap\u00f3s esses comandos o LED vermelho da placa come\u00e7ar\u00e1 a piscar.</p>"},{"location":"android/boards/vim3/hal/aidl/#criando-uma-aplicacao","title":"Criando uma aplica\u00e7\u00e3o","text":"<p>Para ter uma intera\u00e7\u00e3o melhor com o servi\u00e7o, criei um app simples em java. Dessa forma, \u00e9 poss\u00edvel alterar o estado do LED apenas apertando os bot\u00f5es da aplica\u00e7\u00e3o.</p> <p>Primeiro, dentro da pasta raiz do AOSP, criei a pasta:</p> <pre><code>mkdir -p device/casa/placamae/app/UserLedApp\n</code></pre> <p>Dentro dela crie os arquivos:</p> AndroidManifest.xml<pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;manifest \n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    package=\"com.example.userledapp\"&gt;\n\n    &lt;application \n        android:name=\".UserLedServiceApp\"\n        android:label=\"UserLedApp\"&gt;\n\n        &lt;activity\n            android:name=\".MainActivity\"\n            android:exported=\"true\"&gt;\n            &lt;intent-filter&gt;\n                &lt;action android:name=\"android.intent.action.MAIN\" /&gt;\n                &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;\n            &lt;/intent-filter&gt;\n        &lt;/activity&gt;\n    &lt;/application&gt;\n&lt;/manifest&gt;\n</code></pre> Android.bp<pre><code>android_app {\n    name: \"UserLedApp\",\n    certificate: \"platform\", // to be a persistent app\n    system_ext_specific: true,\n    platform_apis: true,    \n\n    static_libs: [\n        \"placamae.hal.userled-V1-java\",\n        \"androidx-constraintlayout_constraintlayout\",\n        \"androidx-constraintlayout_constraintlayout-solver\",\n    ],\n\n    // package native libs in the APK\n    use_embedded_native_libs: true,\n\n    resource_dirs: [\"res\"],\n\n    srcs: [\n        \"java/**/*.java\",\n    ],\n}\n</code></pre> <p>Depois criei a seguinte pasta:</p> <pre><code>mkdir -p device/casa/placamae/app/UserLedApp/java/com/example/userledapp/\n</code></pre> <p>e dentro delas as seguintes classes:</p> MainActivity.java<pre><code>package com.example.userledapp;\n\nimport android.app.Activity;\nimport android.os.Bundle;\nimport android.util.Log;\nimport android.view.View;\nimport android.widget.Button;\nimport android.widget.TextView;\n\npublic class MainActivity extends Activity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n    }\n\n    @Override\n    protected void onResume() {\n        super.onResume();\n    }\n\n    public void onClick(View view) {\n        String setValue = ((Button)view).getText().toString();\n\n        try {\n            UserLedServiceApp.getLed().setMode(setValue);\n        }\n        catch (android.os.RemoteException e) {\n            Log.e(\"userled\", \"AIDL Java proxy returned error\", e);\n        }\n    }\n}\n</code></pre> UserLedBroadcastReceiver.java<pre><code>package com.example.userledapp;\n\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.util.Log;\n\npublic class UserLedBroadcastReceiver extends BroadcastReceiver {\n    private static final String TAG = \"userledAppBroadcast\";\n\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        String mode = intent.getStringExtra(\"setMode\");\n        if(mode != null) {\n            try {\n                if(UserLedServiceApp.getLed().setMode(mode)) {\n                    Log.d(TAG, \"Succesfuly setMode to (\" + mode + \")\");\n                }\n                else {\n                    Log.e(TAG, \"Failed calling setMode to (\" + mode + \")\");\n                }\n            }\n            catch (android.os.RemoteException e) {\n                Log.e(TAG, \"IUserLed error\", e);\n\n            }\n        }\n    }\n}\n</code></pre> UserLedServiceApp.java<pre><code>package com.example.userledapp;\n\nimport android.app.Application;\nimport android.content.IntentFilter;\nimport android.os.IBinder;\nimport android.os.ServiceManager;\nimport android.util.Log;\n\n\npublic class UserLedServiceApp extends Application {\n\n    private static final String TAG = \"userledServiceApp\";\n    private static final String INTERFACE = \"placamae.hal.userled.IUserLed/default\";\n\n    UserLedBroadcastReceiver broadcast = new UserLedBroadcastReceiver();\n\n    private static placamae.hal.userled.IUserLed Led; // AIDL Java Proxy\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n\n        IBinder binder = ServiceManager.getService(INTERFACE);\n\n        if (binder == null) {\n            Log.e(TAG, \"Getting \" + INTERFACE + \" service daemon binder failed\");\n        }\n        else {\n            Led = placamae.hal.userled.IUserLed.Stub.asInterface(binder);\n\n            if (Led == null) {\n                Log.e(TAG, \"Getting ICpu Aidl daemon interface failed\");\n            }\n        }\n\n        IntentFilter filter = new IntentFilter(\"com.fooHIDL.fooHIDL\");\n        registerReceiver(broadcast, filter);\n    }\n\n    public void onTerminate() {\n        super.onTerminate();\n        Log.d(TAG, \"Terminated\");\n    }\n\n    // AIDL Java Proxy\n    public static placamae.hal.userled.IUserLed getLed() {\n        return Led;\n    }\n}\n</code></pre> <p>Agora criei a pasta:</p> <pre><code>mkdir -p device/casa/placamae/app/UserLedApp/res/layout\n</code></pre> <p>com o seguinte arquivo: </p> activity_main.xml<pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;androidx.constraintlayout.widget.ConstraintLayout\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"&gt;\n\n    &lt;androidx.constraintlayout.widget.Guideline\n        android:id=\"@+id/middleGuideLine\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:orientation=\"horizontal\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintGuide_percent=\"1\"\n        app:layout_constraintStart_toStartOf=\"parent\" /&gt;\n\n    &lt;Button\n        android:id=\"@+id/onButton\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"wrap_content\"\n        android:layout_marginStart=\"200dp\"\n        android:layout_marginTop=\"72dp\"\n        android:onClick=\"onClick\"\n        android:text=\"default-on\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" /&gt;\n\n    &lt;Button\n        android:id=\"@+id/offButton\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"wrap_content\"\n        android:layout_marginStart=\"440dp\"\n        android:layout_marginTop=\"76dp\"\n        android:onClick=\"onClick\"\n        android:text=\"none\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" /&gt;\n\n    &lt;Button\n        android:id=\"@+id/blinkButton\"\n        android:layout_width=\"329dp\"\n        android:layout_height=\"46dp\"\n        android:layout_marginTop=\"212dp\"\n        android:onClick=\"onClick\"\n        android:text=\"heartbeat\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" /&gt;\n\n&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;\n</code></pre> <p>A estrutura final ficou assim: </p> <pre><code>device/casa/placamae/app/UserLedApp\n\u251c\u2500\u2500 Android.bp\n\u251c\u2500\u2500 AndroidManifest.xml\n\u251c\u2500\u2500 java\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 com\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 example\n\u2502\u00a0\u00a0         \u2514\u2500\u2500 userledapp\n\u2502\u00a0\u00a0             \u251c\u2500\u2500 MainActivity.java\n\u2502\u00a0\u00a0             \u251c\u2500\u2500 UserLedBroadcastReceiver.java\n\u2502\u00a0\u00a0             \u2514\u2500\u2500 UserLedServiceApp.java\n\u2514\u2500\u2500 res\n    \u2514\u2500\u2500 layout\n        \u2514\u2500\u2500 activity_main.xml\n</code></pre> <p>Por fim, \u00e9 s\u00f3 rebuildar o AOSP, flashar as imagens e procurar pelo app <code>UserLedApp</code>.</p> <p>Esse \u00e9 o resultado do funcionamento do aplicativo ativando e desativando o LED vermelho da placa.</p> <p></p>"},{"location":"android/boards/vim3/hal/aidl/#conclusao","title":"Conclus\u00e3o","text":"<p>Apesar de posuir muitos passos, implementar uma HAL utilizando AIDL \u00e9 mais simples que uma HILD. N\u00e3o foi preciso implementar uma JNI, pois o AIDL j\u00e1 gera o backend em java. Isso e outras coisas acabam facilidando a implementa\u00e7\u00e3o.</p> <p>O Led vermleho j\u00e1 vem habilitado por padr\u00e3o pelo kernel que foi utilizado. Um pr\u00f3ximo passo seria utilizar outra porta GPIO, por padr\u00e3o, elas n\u00e3o vem ativadas e esse seria mais um desafio na parte de kernel, do que de uma HAL.</p> <p>Por fim, vale relembar que que o <code>ndk_platform</code> ira ser depreciado a partir do Android 13, sendo substitu\u00eddo pelo <code>ndk</code>, apenas. Para tirar algumas d\u00favidas de implementa\u00e7\u00e3o, costumo consultar a HAL de Power. Foi nela que encontrei essa informa\u00e7\u00e3o (ndk_platform depreciado).</p>"},{"location":"android/boards/vim3/hal/hidl/","title":"Blink Led HIDL","text":"Image by Gerd Altmann from Pixabay <p>Vale ressaltar que para esse post \u00e9 necess\u00e1rio j\u00e1 ter um produto buildado e para o ultimo t\u00f3pico \u00e9 preciso do display j\u00e1 em funcionamento.</p>"},{"location":"android/boards/vim3/hal/hidl/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>Apesar de j\u00e1 estar depreciado, o HIDL ainda pode ser largamente encontrado no c\u00f3digo fonte do AOSP. Caso algum c\u00f3digo legado apare\u00e7a, n\u00e3o custa nada ter esse tutorial pra relembrar com \u00e9 feito um processo completo de implementa\u00e7\u00e3o da HIDL.</p>"},{"location":"android/boards/vim3/hal/hidl/#informacoes-uteis","title":"Informa\u00e7\u00f5es \u00fateis","text":"<ul> <li>Vers\u00e3o do AOSP: <code>android-12.0.0_r4</code></li> <li>Vers\u00e3o do kernel Android: <code>android-amlogic-bmeson-5.4</code></li> <li>Distro para compila\u00e7ao: <code>Ubuntu 22.04.1 LTS</code></li> <li>Vers\u00e3o do kernel da distro: <code>5.15.0-53-generic</code></li> </ul>"},{"location":"android/boards/vim3/hal/hidl/#implementacao","title":"Implementa\u00e7\u00e3o","text":"<p>Tentarei seguir os mesmos t\u00f3picos do post: <code>Implementando a HIDL</code>.</p>"},{"location":"android/boards/vim3/hal/hidl/#hal","title":"HAL","text":"<p>Na raiz da pasta do AOSP criei o seguinte caminho:</p> <pre><code>mkdir -p device/casa/placamae/interfaces/userled\n</code></pre> <p>Dentro da pasta, criei o seguinte arquivo:</p> Android.bp<pre><code>hidl_package_root {\n    name: \"placamae.hal.userled\",\n    path: \"device/casa/placamae/interfaces/userled\",\n}\n</code></pre> <p>Agora, criei a pasta: </p> <pre><code>mkdir 1.0\n</code></pre> <p>e dentro dela os seguintes arquivos:</p> Android.bp<pre><code>hidl_interface {\n    name: \"placamae.hal.userled@1.0\",\n    root: \"placamae.hal.userled\", //must be a prefix of placamae.hal.userled@1.0\n    gen_java: true,\n    product_specific: true,\n\n    srcs: [\n        \"IUserLed.hal\",\n    ],\n    interfaces: [\n        \"android.hidl.base@1.0\",\n    ],\n\n}\n</code></pre> IUserLed.hal<pre><code>package placamae.hal.userled@1.0;\n\ninterface IUserLed{\n    setMode(string mode) generates (bool result);\n};\n</code></pre> <p>O resultado foi esse:</p> <pre><code>device/casa/placamae/interfaces/userled/\n\u251c\u2500\u2500 1.0\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 Android.bp\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 IUserLed.hal\n\u2514\u2500\u2500 Android.bp\n</code></pre> <p>Agora \u00e9 s\u00f3 adicionar ao produto, no meu caso:</p> meuproduto.mk<pre><code>...\nPRODUCT_PACKAGES += \\\n  placamae.hal.userled@1.0\n</code></pre> <p>Agora vamos gerar os arquivos fonte para a HIDL. Para isso, ainda dentro da pasta <code>1.0</code>, digite:</p> <pre><code>mm\n</code></pre> <p>Ele ir\u00e1 gerar as classes necess\u00e1rias dentro da pasta :</p> <pre><code>out/soong/.intermediates/device/casa/placamae/interfaces/userled/1.0/\n\u251c\u2500\u2500 placamae.hal.userled@1.0\n\u251c\u2500\u2500 placamae.hal.userled@1.0-adapter\n\u251c\u2500\u2500 placamae.hal.userled@1.0-adapter_genc++\n\u251c\u2500\u2500 placamae.hal.userled@1.0-adapter-helper\n\u251c\u2500\u2500 placamae.hal.userled@1.0-adapter-helper_genc++\n\u251c\u2500\u2500 placamae.hal.userled@1.0-adapter-helper_genc++_headers\n\u251c\u2500\u2500 placamae.hal.userled@1.0_genc++\n\u251c\u2500\u2500 placamae.hal.userled@1.0_genc++_headers\n\u251c\u2500\u2500 placamae.hal.userled-V1.0-java\n\u251c\u2500\u2500 placamae.hal.userled-V1.0-java_gen_java\n\u2514\u2500\u2500 placamae.hal.userled-V1.0-java-shallow\n</code></pre>"},{"location":"android/boards/vim3/hal/hidl/#servico","title":"Servi\u00e7o","text":"<p>Volte para a pasta raiz do AOSP</p> <pre><code>croot\n</code></pre> <p>Criei a pasta <code>device/casa/placamae/interfaces/userled/1.0/default/</code>, e dentro dela os arquivos:</p> UserLed.h<pre><code>// Mesmo caminho ap\u00f3s:\n// placamae.hal.userled@1.0_genc++_headers/gen/placamae/hal/userled/1.0/\n// dentro da pasta out/soong/.intermediates/device/casa/placamae/interfaces/userled/1.0/\n#include &lt;placamae/hal/userled/1.0/IUserLed.h&gt;\n\nnamespace placamae {\nnamespace hal {\nnamespace userled {\nnamespace V1_0 {\nnamespace implementation {\n\n\nusing ::android::hardware::hidl_string;         // const hidl_string\nusing ::android::hardware::Return;              // Return&lt;void&gt;\nusing ::android::hardware::Void;                // return Void();\nusing ::placamae::hal::userled::V1_0::IUserLed; // public IUserled\n\nclass UserLed : public IUserLed {\n    public:\n      static inline const char RED_LED[] = \"/sys/devices/platform/leds/leds/vim3:red/trigger\";\n    public:\n        Return&lt;bool&gt; setMode(const hidl_string&amp; mode) override;\n        static int writeValue(const char *file, const char *value);\n};\n\nextern \"C\" IUserLed* HIDL_FETCH_IUserled(const char* name);\n\n} // namespace implementation\n} // namespace V1_0 \n} // namespace userled\n} // namespace hal\n} // namespace placamae\n</code></pre> UserLed.cpp<pre><code>#include \"UserLed.h\"\n\n#include &lt;log/log.h&gt;\n#include &lt;sys/stat.h&gt; // struct stat info\n\nnamespace placamae {\nnamespace hal {\nnamespace userled {\nnamespace V1_0 {\nnamespace implementation {\n\nint UserLed::writeValue(const char *file, const char *value) {\n\n    int fd;\n    int str_len = strlen(value) + 1;\n\n    fd = open(file, O_WRONLY);\n\n    if (fd &lt; 0) {\n      return -1;\n    }\n\n    if(!write(fd, value, str_len)){\n      close(fd);\n      return -1;\n    }  \n\n    close(fd);\n    return 0;\n}\n\nReturn&lt;bool&gt; UserLed::setMode(const hidl_string&amp; mode) {\n    ALOGI(\"UserLed -&gt; setMode data=(%s)\", mode.c_str());\n    return this-&gt;writeValue(RED_LED, mode.c_str()) == 0;\n}\n\n// Methods from ::android::hidl::base::V1_0::IBase follow.\nIUserLed* HIDL_FETCH_IUserled(const char* /* name */) {\n    return new UserLed(); // Return new instance of this class\n}\n\n} // namespace implementation\n} // namespace V1_0 \n} // namespace userled\n} // namespace hal\n} // namespace placamae\n</code></pre> service.cpp<pre><code>#define LOG_TAG \"placamae.hal.userled@1.0-service\"\n\n#include &lt;placamae/hal/userled/1.0/IUserLed.h&gt;\n\n#include &lt;log/log.h&gt;\n#include &lt;hidl/HidlTransportSupport.h&gt;\n\n#include \"UserLed.h\"\n\nusing android::sp;\nusing android::status_t;\nusing android::OK;\n\n// libhwbinder:\nusing android::hardware::configureRpcThreadpool;\nusing android::hardware::joinRpcThreadpool;\n\n// Generated HIDL files\nusing placamae::hal::userled::V1_0::IUserLed;\nusing placamae::hal::userled::V1_0::implementation::UserLed;\n\nusing namespace placamae;\n\nint main(int /* argc */, char** /* argv */) {\n    ALOGI(\"UserLed -&gt; TESSSSSSTE\");\n\n    // Android Strong Pointer (don't GC until exit)\n    sp&lt;IUserLed&gt; service = new UserLed();\n    if (service == nullptr) {\n        ALOGE(\"Can not create an instance of UserLed HAL, exiting.\");\n        return 1;\n    }\n\n    // system/libhidl/transport/include/hidl/HidlTransportSupport.h\n    // Configures the threadpool used for handling incoming RPC calls in this process:\n    // @param maxThreads maximum number of threads in this process\n    // @param callerWillJoin whether the caller will join the threadpool later.\n    configureRpcThreadpool(1, true /*callerWillJoin*/);\n\n    // registerAsService calls registerAsServiceInternal in\n    // system/libhidl/transport/ServiceManagement.cpp\n    // registerAsServiceInternal registers with hwservicemanager\n    status_t status = service-&gt;registerAsService();\n    if (status != OK) {\n        ALOGE(\"Could not register service for UserLed HAL (%d), exiting.\", status);\n        return 1;\n    }\n    ALOGI(\"UserLed Service is ready\");\n\n    // system/libhidl/transport/include/hidl/HidlTransportSupport.h\n    // Joins a threadpool that you configured earlier\n    joinRpcThreadpool();\n\n    // In normal operation, we don't expect the thread pool to exit\n    ALOGE(\"UserLed Service is shutting down\");\n    return 1;\n}\n</code></pre> Android.bp<pre><code>cc_binary {\n    name: \"placamae.hal.userled@1.0-service\",\n    init_rc: [\"placamae.hal.userled@1.0-service.rc\"],\n    srcs: [\"service.cpp\", \"UserLed.cpp\"],\n    vintf_fragments: [\"placamae.hal.userled@1.0-service.xml\"],\n    vendor: true,\n    relative_install_path: \"hw\",\n\n    shared_libs: [\n        \"libhidlbase\",\n        \"liblog\",\n        \"libutils\",\n        \"libhardware\",\n        \"placamae.hal.userled@1.0\",\n    ],\n}\n</code></pre> placamae.hal.userled@1.0-service.rc<pre><code>service placamae.hal.userled-service /vendor/bin/hw/placamae.hal.userled@1.0-service\n        interface placamae.hal.userled@1.0::IUserLed default\n        class hal\n        user system\n        group system\n\non boot\n    chown system system /sys/devices/platform/leds/leds/vim3:red/trigger\n    chmod 0660 /sys/devices/platform/leds/leds/vim3:red/trigger\n</code></pre> placamae.hal.userled@1.0-service.xml<pre><code>&lt;manifest version=\"1.0\" type=\"device\"&gt;\n    &lt;hal format=\"hidl\"&gt;\n        &lt;name&gt;placamae.hal.userled&lt;/name&gt;\n        &lt;transport&gt;hwbinder&lt;/transport&gt;\n        &lt;version&gt;1.0&lt;/version&gt;\n        &lt;interface&gt;\n            &lt;name&gt;IUserled&lt;/name&gt;\n            &lt;instance&gt;default&lt;/instance&gt;\n        &lt;/interface&gt;\n        &lt;fqname&gt;@1.0::IUserLed/default&lt;/fqname&gt;\n    &lt;/hal&gt;\n&lt;/manifest&gt;\n</code></pre> <p>O resultado foi esse:</p> <pre><code>device/casa/placamae/interfaces/userled/\n\u251c\u2500\u2500 1.0\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 Android.bp\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 default\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 Android.bp\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 placamae.hal.userled@1.0-service.rc\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 placamae.hal.userled@1.0-service.xml\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 service.cpp\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 UserLed.cpp\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 UserLed.h\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 IUserLed.hal\n\u2514\u2500\u2500 Android.bp\n</code></pre> <p>Agora s\u00f3 resta adicionar o servi\u00e7o ao produto:</p> meuproduto.mk<pre><code>...\nPRODUCT_PACKAGES += \\\n  placamae.hal.userled@1.0 \\\n  placamae.hal.userled@1.0-service\n</code></pre>"},{"location":"android/boards/vim3/hal/hidl/#permissoes","title":"Permiss\u00f5es","text":"<p>Para facilitar a implementa\u00e7\u00e3o, foi definido a permiss\u00e3o permissiva, mas ainda \u00e9 necess\u00e1rio subir o servi\u00e7o. Essa etapa \u00e9 feita via sepolicy.</p> <p>Para isso, criei a pasta:</p> <pre><code>mkdir -p device/casa/placamae/sepolicy\n</code></pre> <p>Dentro dela criei os arquivos:</p> file_contexts<pre><code>/vendor/bin/hw/placamae\\.hal\\.userled@1\\.0-service      u:object_r:hal_userled_default_exec:s0\n</code></pre> hal_userled_default.te<pre><code>type hal_userled_default, domain;\ntype hal_userled_default_exec, exec_type, vendor_file_type, file_type;\n\ninit_daemon_domain(hal_userled_default);\n</code></pre> <p>Por fim, adicionei a pasta sepolicy no:</p> BoardConfig.mk<pre><code>...\nBOARD_SEPOLICY_DIRS += device/casa/placamae/sepolicy\n</code></pre>"},{"location":"android/boards/vim3/hal/hidl/#testando","title":"Testando","text":"<p>Para testar a HAL, criei a pasta:</p> <pre><code>mkdir -p device/casa/placamae/interfaces/userled/1.0/default/LedTest\n</code></pre> <p>e dentro dela os seguintes arquivos:</p> LedTest.cpp<pre><code>#include &lt;placamae/hal/userled/1.0/IUserled.h&gt;\n\n#include &lt;hidl/Status.h&gt;\n#include &lt;hidl/LegacySupport.h&gt;\n#include &lt;utils/misc.h&gt;\n#include &lt;hidl/HidlSupport.h&gt;\n#include &lt;iostream&gt;\n#include &lt;cstdlib&gt;\n#include &lt;string&gt;\n\nusing ::android::sp;\nusing ::placamae::hal::userled::V1_0::IUserled;\nusing android::hardware::hidl_string;\n\nint main(int argc, char *argv[]) {\n    iif (argc != 2) {\n        std::cout &lt;&lt; \"USAGE ./LedTest &lt;none|heartbeat|default-on&gt;\\n\";\n        exit(0);\n    }\n\n    android::sp&lt;IUserled&gt; mHal = IUserled::getService();\n    if (mHal == nullptr) {\n        std::cout &lt;&lt; \"Failed to get cpu service\\n\";\n        exit(-1);\n    }\n\n    bool result = mHal-&gt;setMode(argv[1]);\n    std::cout &lt;&lt; \"setScalingGovernor: (\" &lt;&lt; result &lt;&lt; \") \" &lt;&lt; argv[1] &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre> Android.bp<pre><code>cc_binary {\n    name: \"LedTest\",\n    srcs: [\"LedTest.cpp\"],\n    defaults: [\"hidl_defaults\"],\n    vendor: true,\n    relative_install_path: \"hw\",\n\n    shared_libs: [\n        \"liblog\",\n        \"libhardware\",\n        \"libhidlbase\",\n        \"libutils\",\n        \"placamae.hal.userled@1.0\",\n    ],\n}\n</code></pre> <p>Agora s\u00f3 resta adicionar o servi\u00e7o ao produto:</p> meuproduto.mk<pre><code>...\nPRODUCT_PACKAGES += \\\n  placamae.hal.userled@1.0 \\\n  placamae.hal.userled@1.0-service\n  LedTest\n</code></pre> <p>Na pasta raiz do AOSP:</p> <pre><code>m \n</code></pre> <p>Depois de terminar a build, flashei os bin\u00e1rios e esperei o Android subir para ter acesso ao ADB. Para testar o servi\u00e7o, utilizei os comandos:</p> <pre><code>adb root\nadb shell\ncd /vendor/bin/hw\n./LedTest heartbeat\n</code></pre>"},{"location":"android/boards/vim3/hal/hidl/#java-native-interface","title":"Java Native Interface","text":"<p>A Java Native Interface (JNI) \u00e9 respons\u00e1vel por fazer a interface entre o c\u00f3digo em JAVA e o c\u00f3digo em C/C++. Essa abordagem \u00e9 largamente usada no mundo JAVA, ou seja, n\u00e3o \u00e9 uma exclusividade do mundo Android.</p> <p>Criei a pasta:</p> <pre><code>mkdir -p device/casa/placamae/libs/jni\n</code></pre> <p>dentro dela os arquivos:</p> UserLedJNI.h<pre><code>#ifndef USERLEDJNI_H\n#define USERLEDJNI_H\n\n#define LOG_TAG \"USERLEDJNI.cpp\"\n#define LOG_NDEBUG 1\n\n#include \"jni.h\"\n\n#include &lt;android-base/chrono_utils.h&gt;\n#include &lt;utils/Log.h&gt;\n\n\n#include &lt;placamae/hal/userled/1.0/IUserLed.h&gt;\n\nusing ::placamae::hal::userled::V1_0::IUserLed; \n\nusing android::hardware::Return;\nusing android::hardware::Void;\nusing android::sp;\n\nclass UserLedJNI {\n\n    public:\n        inline static sp&lt;IUserLed&gt; UserLedHal = nullptr;\n        inline static bool UserLedHalExists = true;\n        inline static const char *classPathName = \"com/interfaces/UserLedJNI\"\";\n\n    public:\n        static bool getUserLedHal();\n\n        static void processReturn(const Return&lt;void&gt; &amp;ret, const char* functionName);        \n        static int registerNativeMethods(JNIEnv* env, const char* className, JNINativeMethod* gMethods, int numMethods);\n        static int registerJniUserLed(JNIEnv* env);\n\n        static void nativeInit(JNIEnv* env, jobject /* obj */);\n        static jboolean setMode(JNIEnv*  env, jclass /* clazz */, jstring mode);\n};\n\n#endif\n</code></pre> UserLedJNI.cpp<pre><code>#include \"UserLedJNI.h\"\n\nJNINativeMethod methods[] = {\n    { \"nativeInit\", \"()V\", (void*) UserLedJNI::nativeInit },\n    { \"nativeSetMode\", \"(Ljava/lang/String;)Z\", (void*) UserLedJNI::setMode },\n};\n\nstd::mutex UserLedHalMutex;\n\nbool UserLedJNI::getUserLedHal() {\n\n    if (UserLedHalExists &amp;&amp; UserLedHal == nullptr) {\n\n        UserLedHal = IUserLed::getService(); // Proxy to the service\n\n        if (UserLedHal != nullptr) {\n            ALOGI(\"Loaded foo HAL service\");\n        } \n        else {\n            ALOGI(\"Couldn't load foo HAL service\");\n            UserLedHalExists = false;\n        }\n    }\n    return UserLedHal != nullptr;\n}\n\nvoid UserLedJNI::nativeInit(JNIEnv* env, jobject /* obj */) {\n    UserLedHalMutex.lock();\n    getUserLedHal();\n    UserLedHalMutex.unlock();\n}\n\njboolean UserLedJNI::setMode(JNIEnv*  env, jclass /* clazz */, jstring mode) {\n\n    ALOGD(\"nativeSetMode\");\n\n    std::lock_guard&lt;std::mutex&gt; lock(UserLedHalMutex);\n\n    bool ret = false;\n    if (UserLedJNI::getUserLedHal()) {\n        android::base::Timer t;\n\n        const char* cMode = env-&gt;GetStringUTFChars(mode, NULL);\n        ret = UserLedJNI::UserLedHal-&gt;setMode(cMode);\n        env-&gt;ReleaseStringUTFChars(mode, cMode);\n\n        if (t.duration() &gt; 20ms) {\n            ALOGW(\"Excessive delay in setScalingGovernor\");\n        }\n    }\n\n    return ret;\n}\n\nint UserLedJNI::registerNativeMethods(JNIEnv* env, const char* className, JNINativeMethod* gMethods, int numMethods) {\n\n    jclass clazz;\n\n    ALOGE(\"registerNativeMethods '%s'\", className);\n\n    clazz = env-&gt;FindClass(className);\n\n    if (clazz == NULL) {\n        ALOGE(\"Native registration unable to find class '%s'\", className);\n        return JNI_FALSE;\n    }\n\n    if (env-&gt;RegisterNatives(clazz, gMethods, numMethods) &lt; 0) {\n        ALOGE(\"RegisterNatives failed for '%s'\", className);\n        return JNI_FALSE;\n    }\n\n    return JNI_TRUE;\n}\n\nint UserLedJNI::registerJniUserLed(JNIEnv* env) {\n    if (!registerNativeMethods(env, UserLedJNI::classPathName, methods, sizeof(methods) / sizeof(methods[0])))\n        return JNI_FALSE;\n    return JNI_TRUE;\n}\n</code></pre> onload.cpp<pre><code>#include \"jni.h\"\n#include \"utils/Log.h\"\n#include \"utils/misc.h\"\n\n\nnamespace UserLedJNI {\n     int registerJniUserLed(JNIEnv* env);\n};\n\nusing namespace UserLedJNI;\n\nextern \"C\" jint JNI_OnLoad(JavaVM* vm, void* /* reserved */)\n{\n    JNIEnv* env = NULL;\n    jint result = -1;\n\n    if (vm-&gt;GetEnv((void**) &amp;env, JNI_VERSION_1_4) != JNI_OK) {\n        ALOGE(\"GetEnv failed!\");\n        return result;\n    }\n    ALOG_ASSERT(env, \"Could not retrieve the env!\");\n\n    UserLedJNI::registerJniUserLed(env);\n    return JNI_VERSION_1_4;\n}\n</code></pre> Android.bp<pre><code>cc_library_shared {\n    name: \"libUserLedJNI\", //lib prefix is required\n    vendor: true,\n\n    defaults: [\"libUserLedJNI-libs\"],\n\n    cflags: [\n        \"-Wall\",\n        \"-Werror\",\n        \"-Wno-unused-parameter\",\n    ],\n\n    srcs: [\n        \"onload.cpp\",\n        \"UserLedJNI.cpp\"\n    ],\n}\n\ncc_defaults {\n    name: \"libUserLedJNI-libs\",\n\n    shared_libs: [\n        \"libbase\",\n        \"libcutils\",\n        \"liblog\",\n        \"libhardware\",\n        \"libhidlbase\",\n        \"libutils\",\n        \"placamae.hal.userled@1.0\"\n    ],\n\n    header_libs: [\n        \"jni_headers\",\n    ],\n}\n</code></pre> <p>Agora \u00e9 preciso adicionar o JNI ao produto:</p> meuproduto.mk<pre><code>#...\nPRODUCT_PACKAGES += \\\n  libUserLedJNI\n</code></pre>"},{"location":"android/boards/vim3/hal/hidl/#complementando-a-jni","title":"Complementando a JNI","text":"<p>Para que seja poss\u00edvel utilizar essa JNI com outros aplicativos, uma das possibilidades \u00e9 separar o cliente nativo e criar uma interface para acessar os seus m\u00e9todos. Para isso, a partir da pasta raiz do AOSP, criei o seguinte diret\u00f3rio:</p> <pre><code>mkdir -p device/casa/placamae/libs/java\n</code></pre> <p>Dentro dessa pasta, criei esse novo caminho:</p> <pre><code>mkdir -p com/interfaces\n</code></pre> <p>Dentro da pasta adicionei o seguinte arquivo:</p> UserLedJNI.java<pre><code>package com.interfaces;\nimport android.util.Log;\n\npublic class UserLedJNI {\n    static final String TAG = \"com.interfaces.UserLedJNI\";\n    static final boolean DEBUG = false;\n\n    private native void nativeInit();\n    private static native boolean nativeSetMode(String mode);\n\n    public UserLedJNI() {\n        Log.d(TAG, \"UserLedJNI onCreate()\");\n        synchronized (this) {\n            nativeInit();\n        }\n    }\n\n    public boolean setMode(String mode) {\n        return nativeSetMode(mode);\n    }\n\n    static {\n        Log.d(TAG, \"UserLedJNI static\");\n        System.loadLibrary(\"UserLedJNI\");\n    }\n}\n</code></pre> <p>Voltando para a pasta <code>device/casa/placamae/libs/java</code>, criei esse arquivo:</p> Android.bp<pre><code>java_sdk_library {\n    name: \"com.interfaces\",\n    vendor: true,\n\n    srcs: [\n        \"com/**/*.java\",\n    ],\n\n    sdk_version: \"current\",\n    compile_dex: true,\n    api_packages: [\"com.interfaces\"],\n}\n</code></pre> <p>Os arquivos ficam organizados dessa forma:</p> <pre><code>device/casa/placamae/libs/java\n\u251c\u2500\u2500 Android.bp\n\u2514\u2500\u2500 com\n    \u2514\u2500\u2500 interfaces\n        \u2514\u2500\u2500 UserLedJNI.java\n</code></pre> <p>Agora, na pasta raiz do AOSP, \u00e9 necess\u00e1rio usar o seguinte comando:</p> <pre><code>build/soong/scripts/gen-java-current-api-files.sh \"device/casa/placamae/libs/java/api\"  system- test- &amp;&amp; m update-api\n</code></pre> <p>Um erro ocorrer\u00e1 informando, que \u00e9 necess\u00e1rio mapear alguns filegroups:</p> <pre><code>com.interfaces.api.public.latest\ncom.interfaces-removed.api.public.latest\ncom.interfaces-incompatibilities.api.public.latest\ncom.interfaces.api.system.latest\ncom.interfaces-removed.api.system.latest\ncom.interfaces-incompatibilities.api.system.latest\n</code></pre> <p>Observe tamb\u00e9m que uma pasta com o nome <code>api</code> foi criada.</p> <p>Os filegroups s\u00e3o adicionados em:</p> device/casa/placamae/libs/java/libs/java/Android.bp<pre><code>java_sdk_library {\n    name: \"com.interfaces\",\n    vendor: true,\n\n    srcs: [\n        \"com/**/*.java\",\n    ],\n\n    sdk_version: \"current\",\n    compile_dex: true,\n    api_packages: [\"com.interfaces\"],\n}\n\nfilegroup {\n    name: \"com.interfaces.api.public.latest\",\n    srcs: [\"api/current.txt\"]\n}\n\nfilegroup {\n    name: \"com.interfaces-removed.api.public.latest\",\n    srcs: [\"api/removed.txt\"]\n}\n\nfilegroup {\n    name: \"com.interfaces-incompatibilities.api.public.latest\",\n    srcs: [\"api/incompatibilities.txt\"]\n}\n\nfilegroup {\n    name: \"com.interfaces.api.system.latest\",\n    srcs: [\"api/system-current.txt\"]\n}\n\nfilegroup {\n    name: \"com.interfaces-removed.api.system.latest\",\n    srcs: [\"api/system-removed.txt\"]\n}\n\nfilegroup {\n    name: \"com.interfaces-incompatibilities.api.system.latest\",\n    srcs: [\"api/system-incompatibilities.txt\"]\n}\n</code></pre> <p>Ainda resta criar 2 arquivos vazios dentro da pasta <code>api</code>:</p> <pre><code>touch device/casa/placamae/libs/java/api/incompatibilities.txt\ntouch device/casa/placamae/libs/java/api/system-incompatibilities.txt\n</code></pre> <p>A estrutura ficou assim:</p> <p><pre><code>device/casa/placamae/libs/java\n\u251c\u2500\u2500 Android.bp\n\u251c\u2500\u2500 api\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 current.txt\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 incompatibilities.txt\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 removed.txt\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 system-current.txt\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 system-incompatibilities.txt\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 system-removed.txt\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 test-current.txt\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 test-removed.txt\n\u2514\u2500\u2500 com\n    \u2514\u2500\u2500 interfaces\n        \u2514\u2500\u2500 UserLedJNI.java\n</code></pre> Executando novamente o comando:</p> <pre><code>build/soong/scripts/gen-java-current-api-files.sh \"device/casa/placamae/libs/java/api\"  system- test- &amp;&amp; m update-api\n</code></pre> <p>A build deve resultar em sucesso.</p>"},{"location":"android/boards/vim3/hal/hidl/#aplicacao","title":"Aplica\u00e7\u00e3o","text":"<p>Para ter uma intera\u00e7\u00e3o melhor com as camadas que foram criadas, criei um app simples em java. Dessa forma, \u00e9 poss\u00edvel alterar o estado do LED apenas apertando os bot\u00f5es da aplica\u00e7\u00e3o.</p> <p>Primeiro, dentro da pasta raiz do AOSP, criei a pasta:</p> <pre><code>mkdir -p device/casa/placamae/app/UserLedApp\n</code></pre> <p>Dentro dela crie os arquivos:</p> AndroidManifest.xml<pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n  package=\"com.example.userledapp\"&gt;\n\n  &lt;application \n      android:name=\".UserLedServiceApp\"\n      android:label=\"UserLedApp\"\n\n      android:requiredForAllUsers=\"true\"\n      android:persistent=\"true\"&gt;\n      &lt;uses-library android:name=\"com.interfaces\" /&gt;\n\n      &lt;activity\n            android:name=\".MainActivity\"\n            android:exported=\"true\"&gt;\n            &lt;intent-filter&gt;\n                &lt;action android:name=\"android.intent.action.MAIN\" /&gt;\n                &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;\n            &lt;/intent-filter&gt;\n        &lt;/activity&gt;\n    &lt;/application&gt;\n&lt;/manifest&gt;\n</code></pre> Android.bp<pre><code>android_app {\n    name: \"UserLedApp\",\n    certificate: \"platform\", // to be a persistent app\n    vendor: true,\n    sdk_version: \"current\",\n\n    static_libs: [\n        \"androidx-constraintlayout_constraintlayout\",\n        \"androidx-constraintlayout_constraintlayout-solver\",\n    ],\n\n    resource_dirs: [\"res\"],\n\n    srcs: [\"java/**/*.java\"],\n\n    defaults: [\"hidl_defaults\"],\n    jni_libs: [\"libUserLedJNI\"],\n    libs: [\"com.interfaces\"],\n }\n</code></pre> <p>Depois criei a seguinte pasta:</p> <pre><code>mkdir -p device/casa/placamae/app/UserLedApp/java/com/example/userledapp/\n</code></pre> <p>e dentro delas as seguintes classes:</p> MainActivity.java<pre><code>package com.example.userledapp;\n\nimport android.app.Activity;\nimport android.os.Bundle;\nimport android.util.Log;\nimport android.view.View;\nimport android.widget.Button;\nimport android.widget.TextView;\n\npublic class MainActivity extends Activity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n    }\n\n    @Override\n    protected void onResume() {\n        super.onResume();\n    }\n\n    public void onClick(View view) {\n        String setValue = ((Button)view).getText().toString();\n        UserLedServiceApp.getLed().setMode(setValue);\n    }\n}\n</code></pre> UserLedBroadcastReceiver.java<pre><code>package com.example.userledapp;\n\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.util.Log;\n\npublic class UserLedBroadcastReceiver extends BroadcastReceiver {\n    private static final String TAG = \"userledAppBroadcast\";\n\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        String mode = intent.getStringExtra(\"setMode\");\n        if(mode != null) {\n            if(UserLedServiceApp.getLed().setMode(mode)) {\n                Log.d(TAG, \"Succesfuly setMode to (\" + mode + \")\");\n            }\n            else {\n                Log.e(TAG, \"Failed calling setMode to (\" + mode + \")\");\n            }\n        }\n    }\n}\n</code></pre> UserLedServiceApp.java<pre><code>package com.example.userledapp;\n\nimport android.app.Application;\nimport android.content.IntentFilter;\nimport android.util.Log;\nimport com.interfaces.UserLedJNI;\n\n\npublic class UserLedServiceApp extends Application {\n    private static final String TAG = \"userledServiceApp\";\n\n    UserLedBroadcastReceiver broadcast = new UserLedBroadcastReceiver();\n    private static UserLedJNI userledjni; // JAVA -&gt; JNI -&gt; HIDL\n\n    public void onCreate() {\n        super.onCreate();\n\n        Log.d(TAG, \"onCreate()\");\n        userledjni = new UserLedJNI();\n\n        Log.d(TAG, \"setMode(default-on) =&gt; \" + userledjni.setMode(\"default-on\"));\n\n        IntentFilter filter = new IntentFilter(\"com.fooHIDL.fooHIDL\");\n        registerReceiver(broadcast, filter);\n    }\n\n    public void onTerminate() {\n        super.onTerminate();\n        Log.d(TAG, \"Terminated\");\n    }\n\n    public static UserLedJNI getLed() {\n        return userledjni;\n    }\n}\n</code></pre> <p>Agora criei a pasta:</p> <pre><code>mkdir -p device/casa/placamae/app/UserLedApp/res/layout\n</code></pre> <p>com o seguinte arquivo:</p> activity_main.xml<pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;androidx.constraintlayout.widget.ConstraintLayout\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"&gt;\n\n    &lt;androidx.constraintlayout.widget.Guideline\n        android:id=\"@+id/middleGuideLine\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:orientation=\"horizontal\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintGuide_percent=\"1\"\n        app:layout_constraintStart_toStartOf=\"parent\" /&gt;\n\n    &lt;Button\n        android:id=\"@+id/onButton\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"wrap_content\"\n        android:layout_marginStart=\"200dp\"\n        android:layout_marginTop=\"72dp\"\n        android:onClick=\"onClick\"\n        android:text=\"default-on\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" /&gt;\n\n    &lt;Button\n        android:id=\"@+id/offButton\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"wrap_content\"\n        android:layout_marginStart=\"440dp\"\n        android:layout_marginTop=\"76dp\"\n        android:onClick=\"onClick\"\n        android:text=\"none\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" /&gt;\n\n    &lt;Button\n        android:id=\"@+id/blinkButton\"\n        android:layout_width=\"329dp\"\n        android:layout_height=\"46dp\"\n        android:layout_marginTop=\"212dp\"\n        android:onClick=\"onClick\"\n        android:text=\"heartbeat\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" /&gt;\n\n&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;\n</code></pre> <p>Por fim, \u00e9 s\u00f3 adicionar o app ao produto:</p> meuproduto.mk<pre><code>PRODUCT_PACKAGES += \\\n  libUserLedJNI \\\n  com.interfaces \\\n  UserLedApp\n</code></pre> <p>A estrutura final ficou assim:</p> <pre><code>device/casa/placamae/app/UserLedApp\n\u251c\u2500\u2500 Android.bp\n\u251c\u2500\u2500 AndroidManifest.xml\n\u251c\u2500\u2500 java\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 com\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 example\n\u2502\u00a0\u00a0         \u2514\u2500\u2500 userledapp\n\u2502\u00a0\u00a0             \u251c\u2500\u2500 MainActivity.java\n\u2502\u00a0\u00a0             \u251c\u2500\u2500 UserLedBroadcastReceiver.java\n\u2502\u00a0\u00a0             \u2514\u2500\u2500 UserLedServiceApp.java\n\u2514\u2500\u2500 res\n    \u2514\u2500\u2500 layout\n        \u2514\u2500\u2500 activity_main.xml\n</code></pre> <p>Agora \u00e9 s\u00f3 rebuildar o AOSP, flashar as imagens e procurar pelo app UserLedApp</p> <p></p>"},{"location":"android/boards/vim3/hal/hidl/#cliente-em-java","title":"Cliente em Java","text":"<p>Existe a possibilidade de n\u00e3o a JNI e usar a HIDL direto com o pr\u00f3prio JAVA. Para isso basta fazer algumas alterac\u00f5es nos arquivos j\u00e1 criados:</p> AndroidManifest.xml<pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n  package=\"com.example.userledapp\"&gt;\n\n  &lt;application \n      android:name=\".UserLedServiceApp\"\n      android:label=\"UserLedApp\"\n\n      android:requiredForAllUsers=\"true\"\n      android:persistent=\"true\"&gt;\n\n      &lt;activity\n            android:name=\".MainActivity\"\n            android:exported=\"true\"&gt;\n            &lt;intent-filter&gt;\n                &lt;action android:name=\"android.intent.action.MAIN\" /&gt;\n                &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;\n            &lt;/intent-filter&gt;\n        &lt;/activity&gt;\n    &lt;/application&gt;\n&lt;/manifest&gt;\n</code></pre> Android.bp<pre><code>android_app {\n    name: \"UserLedApp\",\n    certificate: \"platform\", // to be a persistent app\n    system_ext_specific: true, //https://source.android.com/docs/core/architecture/bootloader/partitions/product-interfaces#java-interfaces\n    platform_apis: true,\n\n    resource_dirs: [\"res\"],\n\n    srcs: [\"java/**/*.java\"],\n\n    static_libs: [\n        \"android.hidl.base-V1.0-java\",\n        \"placamae.hal.userled-V1.0-java\",\n        \"androidx-constraintlayout_constraintlayout\",\n        \"androidx-constraintlayout_constraintlayout-solver\",\n    ],\n }\n</code></pre> MainActivity.java<pre><code>package com.example.userledapp;\n\nimport android.app.Activity;\nimport android.os.Bundle;\nimport android.util.Log;\nimport android.view.View;\nimport android.widget.Button;\nimport android.widget.TextView;\n\npublic class MainActivity extends Activity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n    }\n\n    @Override\n    protected void onResume() {\n        super.onResume();\n    }\n\n    public void onClick(View view) {\n        String setValue = ((Button)view).getText().toString();\n\n        try {\n            UserLedServiceApp.getLed().setMode(setValue);\n        } \n        catch (android.os.RemoteException e) {\n            Log.e(\"MainActiviry\", \"user led HIDL Java proxy returned error\", e);\n        }\n    }\n}\n</code></pre> UserLedBroadcastReceiver.java<pre><code>package com.example.userledapp;\n\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.util.Log;\n\npublic class UserLedBroadcastReceiver extends BroadcastReceiver {\n    private static final String TAG = \"userledAppBroadcast\";\n\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        String mode = intent.getStringExtra(\"setMode\");\n        try {\n            if(mode != null) {\n                if(UserLedServiceApp.getLed().setMode(mode)) {\n                    Log.d(TAG, \"Succesfuly setMode to (\" + mode + \")\");\n                }\n                else {\n                    Log.e(TAG, \"Failed calling setMode to (\" + mode + \")\");\n                }\n            }\n        }\n        catch (android.os.RemoteException e) {\n                Log.e(TAG, \"IUserLed error\", e);\n        }\n    }\n}\n</code></pre> <p>Agora \u00e9 s\u00f3 rebuildar e testar.</p> UserLedServiceApp.java<pre><code>package com.example.userledapp;\n\nimport android.app.Application;\nimport android.content.IntentFilter;\nimport android.util.Log;\nimport placamae.hal.userled.V1_0.IUserLed;\n\n\npublic class UserLedServiceApp extends Application {\n    private static final String TAG = \"userledServiceApp\";\n\n    UserLedBroadcastReceiver broadcast = new UserLedBroadcastReceiver();\n    private static IUserLed userledJava; // HIDL Java Proxy\n\n    public void onCreate() {\n        super.onCreate();\n\n        Log.d(TAG, \"onCreate()\");\n        try {\n            userledJava = IUserLed.getService(true);\n            Log.d(TAG, \"HIDL-Java setMode(default-on) =&gt; \" + userledJava.setMode(\"default-on\"));\n        } \n        catch (android.os.RemoteException e) {\n            Log.e(TAG, \"IUserLed error\", e);\n        }\n\n\n        IntentFilter filter = new IntentFilter(\"com.fooHIDL.fooHIDL\");\n        registerReceiver(broadcast, filter);\n    }\n\n    public void onTerminate() {\n        super.onTerminate();\n        Log.d(TAG, \"Terminated\");\n    }\n\n    // HIDL Java Proxy\n    public static IUserLed getLed() {\n        return userledJava;\n    }\n}\n</code></pre>"},{"location":"android/boards/vim3/kernel/drivers/blueled/","title":"Habilitando o Led Azul","text":"Image by Jacek Abramowicz from Pixabay"},{"location":"android/boards/vim3/kernel/drivers/blueled/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>A Khadas VIM3 possui um conjunto de 3 LEDs soldados na placa, os LEDs Branco, Vermelho, Azul. Na vers\u00e3o do kernel Linux Android amlogic-bmeson-5.4, o LED Azul n\u00e3o vem habilitado por padr\u00e3o. Nesse post vou descrever os passos que utilizei para deixar esse LED acess\u00edvel ao Android.</p>"},{"location":"android/boards/vim3/kernel/drivers/blueled/#informacoes-uteis","title":"Informa\u00e7\u00f5es \u00dateis","text":"<ul> <li>Vers\u00e3o do AOSP: <code>android-12.0.0_r4</code></li> <li>Vers\u00e3o do Kernel Android: <code>android-amlogic-bmeson-5.4</code></li> <li>Distro de Compila\u00e7\u00e3o: <code>Linux Mint 21</code></li> <li>Vers\u00e3o do Kernel da distro: <code>5.15.0-56-generic</code></li> </ul>"},{"location":"android/boards/vim3/kernel/drivers/blueled/#o-gpio-do-led-azul","title":"O GPIO do LED Azul","text":"<p>Os LEDs da placa est\u00e3o na letra <code>I</code> da imagem abaixo (Fonte):</p> <p> </p>    Vista de cima da VIM3     <p>\u00c9 preciso saber qual desses LEDs \u00e9 o azul e a qual GPIO ele est\u00e1 conectado. Para isso, \u00e9 necess\u00e1rio buscar no esquem\u00e1tico da placa, que pode ser encontrado nesse link. Procurando por <code>BLUE</code>, podemos encontrar a porta que ativa o LED.</p> <p> </p>    Esquem\u00e1tico do LED azul    <p>Ele mostra que o sinal que ativa o LED azul \u00e9 o <code>PWR_LED</code>. Buscando no esquem\u00e1tico pelo componente que envia esse sinal, temos:</p> <p> </p>    Fonte do sinal PWR_LED    <p>O STM8S \u00e9 um microcontrolador de 8 bits, ele \u00e9 respons\u00e1vel por fazer o controle de outros componentes da placa. Ele \u00e9 controlado via <code>i2c</code>  pelo endere\u00e7o <code>0x18</code> e possui alguns comando pr\u00e9-determinados para que possamos controlar os componentes que est\u00e3o associados a ele.</p> <p>Para mais detalhes sobre o STM8S veja Habilitando a FAN)</p>"},{"location":"android/boards/vim3/kernel/drivers/blueled/#habilitando-o-led","title":"Habilitando o LED","text":"<p>Para ter acesso ao <code>STM8S</code> eu adicionei o seguinte c\u00f3digo ao kernel Linux Android amlogic-bmeson-5.4:</p> <p>arch/arm64/boot/dts/amlogic/meson-g12b-a311d-khadas-vim3.dts<pre><code>...\n\n&amp;i2c_AO {\n  khadas-mcu {\n    compatible = \"khadas-mcu\";\n    reg = &lt;0x18&gt;;\n    fan,trig_temp_level0 = &lt;50&gt;;\n    fan,trig_temp_level1 = &lt;60&gt;;\n    fan,trig_temp_level2 = &lt;65&gt;;\n    fan,trig_temp_level3 = &lt;70&gt;;\n    hwver = \"VIM3.V11\";\n  };\n};\n</code></pre> Com isso, \u00e9 poss\u00edvel acessar o <code>STM8S</code> via <code>adb shell</code>. Agora resta saber como ativar o LED azul. Para isso, \u00e9 necess\u00e1rio saber qual comando deve ser enviado para o <code>STM8S</code>. Checando a escassa documenta\u00e7\u00e3o da placa, encontrei o seguinte pdf vim3_mcu_reg_en que possui as seguintes linhas:</p> Address Register name Byte R/W Note 0x28 LED_MODE_ON 1 R/W 0:LED Off after Power On1:LED On after Power On2:LED Breath after Power On3:LED Heartbeat after Power On 0x29 LED_MODE_OFF 1 R/W 0:LED Off after Power Off1:LED On after Power Off2:LED Breath after Power Off3:LED Heartbeat after Power Off <p>Com base nessas linhas, o LED azul pode ter um comportamento quando a placa est\u00e1 ligada e outro comportamento quando a placa est\u00e1 desligada.</p>"},{"location":"android/boards/vim3/kernel/drivers/blueled/#testando","title":"Testando","text":"<p>Depois de buildar o Kernel e o AOSP e flashar as imagens, utilizei o <code>adb shell</code> para fazer os testes. </p> <p>Primeiro chequei para ver se o endere\u00e7o <code>0x18</code>estava dispon\u00edvel no barramento <code>0</code> (\u00e9 necess\u00e1rio ter permiss\u00e3o de super usu\u00e1rio):</p> <pre><code>jaoboard:/ # i2cdetect -y 0 # barramento 0 do i2c\n     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f\n00:          -- -- -- -- -- -- -- -- -- -- -- 0e --\n10: -- -- -- -- -- -- -- -- 18 -- -- -- -- -- -- --\n20: UU -- 22 -- -- -- -- -- -- -- -- -- -- -- -- --\n30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\n40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\n50: -- 51 -- -- -- -- -- -- -- -- -- -- -- -- -- --\n60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\n70: -- -- -- -- -- -- -- --   \n</code></pre> <p>com o endere\u00e7o <code>0x18</code> dispon\u00edvel, usei o seguinte comando para deixar o LED azul piscando enquanto a placa estiver ligada:</p> <pre><code>i2cset 0 0x18 0x28 3 w  -y # Heartbeat\n</code></pre> <p> </p>    LED Azul piscando    <p>Para mudar o comportamento do LED azul para a placa desligada, basta mudar o registrador de <code>0x28</code> para <code>0x29</code>. Por exemplo:</p> <pre><code>i2cset 0 0x18 0x29 3 w  -y # Heartbeat\n</code></pre>"},{"location":"android/boards/vim3/kernel/drivers/blueled/#conclusao","title":"Conclus\u00e3o","text":"<p>Agora os 3 LEDs dispon\u00edveis na Khadas VIM3 podem ser utilizados, no futuro a ideia \u00e9 criar um Device Driver para controlar o LED azul. Os outros (Branco e Vermelho) j\u00e1 pertencem a categoria de <code>UserLed</code> e podem ser encontrados em <code>/sys/class/leds/</code> com os nomes <code>vim3:white:sys</code> e  <code>vim3:red</code>. Devido isso, podem ter seu comportamento alterado de acordo com o arquivo <code>trigger</code>, por exemplo:</p> <pre><code>jaoboard:/sys/class/leds/vim3:red $ cat trigger                                \n[none] rc-feedback bluetooth-power rfkill-any rfkill-none mmc0 timer \noneshot disk-activity disk-read disk-write ide-disk heartbeat backlight \ngpio cpu cpu0 cpu1 cpu2 cpu3 cpu4 cpu5 default-on transient panic mmc2 mmc1 \nhci0-power rfkill0 rfkill1 rfkill2 \n</code></pre>"},{"location":"android/boards/vim3/kernel/drivers/fan/","title":"Habilitando a FAN","text":"Image by Clker-Free-Vector-Images from Pixabay"},{"location":"android/boards/vim3/kernel/drivers/fan/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>A Khadas VIM3 possui alguns acess\u00f3rios, dentre eles a ventoinha. N\u00e3o tenho certeza se ela j\u00e1 vem habilitada com o sistema que vem por padr\u00e3o na placa (Android Pie (9)), mas na vers\u00e3o do kernel Linux que eles mant\u00e9m, a ventoinha j\u00e1 est\u00e1 adicionada. </p> <p>Infelizmente na vers\u00e3o do kernel Linux Android que estou utilizando nesse momento, a ventoinha ainda n\u00e3o foi adicionada. Dessa forma, nesse post vou descrever os passos que segui para conseguir utilizar a mesma.</p>"},{"location":"android/boards/vim3/kernel/drivers/fan/#informacoes-uteis","title":"Informa\u00e7\u00f5es \u00dateis","text":"<ul> <li>Vers\u00e3o do AOSP: <code>android-12.0.0_r4</code></li> <li>Vers\u00e3o do Kernel Android: <code>android-amlogic-bmeson-5.4</code></li> <li>Distro de Compila\u00e7\u00e3o: <code>Linux Mint 21</code></li> <li>Vers\u00e3o do Kernel da distro: <code>5.15.0-56-generic</code></li> </ul>"},{"location":"android/boards/vim3/kernel/drivers/fan/#a-porta-da-fan","title":"A porta da FAN","text":"<p>O conector da FAN est\u00e1 no n\u00famero <code>6</code> da imagem abaixo (Fonte):</p> <p> </p>    Vista de cima da VIM3     <p>Agora \u00e9 preciso saber onde estas portas est\u00e3o conectadas internamente. Para isso, \u00e9 necess\u00e1rio buscar no esquem\u00e1tico da placa, que pode ser encontrado nesse link. Procurando por <code>FAN</code>, podemos encontrar a porta mencionada anteriormente no esquem\u00e1tico.</p> <p> </p>    Esquem\u00e1tico do conector da FAN    <p>Com isso, \u00e9 poss\u00edvel observar que existem os seguintes sinais: <code>VCC</code>, <code>GND</code> e <code>FAN_PWM</code>. Dessa forma, o pino de controle da ventoinha \u00e9 o <code>FAN_PWM</code>, \u00e9 preciso saber de onde este sinal est\u00e1 vindo. Para isso, basta buscar no esquem\u00e1tico por <code>FAN_PWM</code> e o componente abaixo ser\u00e1 encontrado.</p> <p> </p>    Fonte do sinal FAN_PWM    <p>O STM8S \u00e9 um microcontrolador de 8 bits, ele \u00e9 respons\u00e1vel por fazer o controle da ventoinha (pino 17). Ainda no esquem\u00e1tico, \u00e9 poss\u00edvel observar que esse microcontrolador \u00e9 controlado por <code>i2c</code> (pinos 8 e 9) sendo estes do pr\u00f3prio <code>SOC</code>. O esquem\u00e1tico n\u00e3o fornece o endere\u00e7o, para controlar esse microcontrolador, ou seja, n\u00e3o temos como ter acesso a esse componente.</p>"},{"location":"android/boards/vim3/kernel/drivers/fan/#o-endereco-do-stm8s","title":"O Endere\u00e7o do STM8S","text":"<p>Como a FAN est\u00e1 adicionado ao Kernel Linux mantido pela Khadas, ent\u00e3o a informa\u00e7\u00e3o do endere\u00e7o do microcontrolador est\u00e1 em algum lugar do c\u00f3digo (mas onde ?). Ainda observando as portas do STM8S no esquem\u00e1tico, \u00e9 poss\u00edvel perceber algumas men\u00e7\u00f5es de <code>MCU</code> (sigla para MicroController Unit). A partir disso, \u00e9 muito prov\u00e1vel que qualquer endere\u00e7o de <code>i2c</code> esteja em algum Device Tree Source (DTS) dentro do Kernel Linux da Khadas. Os DTS da <code>VIM3</code> est\u00e3o em <code>arch/arm64/boot/dts/amlogic/</code> e nesse caminho busquei por <code>MCU</code>  e retornaram os seguintes arquivos: </p> <pre><code>\u256d\u2500 ~/Doc/b/V/2/linux-vim3/a/arm6/b/d/amlogic on khadas-vim3-p-64bit \n\u2570\u2500\u276f grep -r mcu                                                              \u2500\u256f\ntm2_t962x3_t312.dts:            /*mcu irq pin*/\ntm2_t962x3_t312.dts:            mcu_irq_pin = &lt;&amp;gpio GPIOH_9 GPIO_ACTIVE_HIGH&gt;;\nkvim3.dts:       khadas-mcu {\nkvim3.dts:               compatible = \"khadas-mcu\";\naxg_s400_v03sbr.dts:    mcu6350: mcu6350@40 {\naxg_s400_v03gva_sbr.dts:    mcu6350: mcu6350@40 {\nkvim3.dts11:       khadas-mcu {\nkvim3.dts11:               compatible = \"khadas-mcu\";\nkvim3.dtsbak:       khadas-mcu {\nkvim3.dtsbak:               compatible = \"khadas-mcu\";\nkvim3.dtspdm:       khadas-mcu {\nkvim3.dtspdm:               compatible = \"khadas-mcu\";\nkvim3.dts_dai:       khadas-mcu {\nkvim3.dts_dai:               compatible = \"khadas-mcu\";\nkvim3l.dts: khadas-mcu {\nkvim3l.dts:     compatible = \"khadas-mcu\";\n</code></pre> <p>A branch que eu utilizei foi a khadas-vim3-p-64bit</p> <p>O arquivo <code>kvim3.dts</code> pareceu promissor, checando a linha retornada anteriormente:</p> <p>kvim3.dts<pre><code>&amp;i2c_AO {\n  status = \"okay\";\n  pinctrl-names=\"default\";\n  pinctrl-0=&lt;&amp;ao_i2c_master_pins1&gt;;\n  clock-frequency = &lt;100000&gt;; /* default 100k */\n\n  khadas-mcu {\n    compatible = \"khadas-mcu\";\n    reg = &lt;0x18&gt;;\n    fan,trig_temp_level0 = &lt;50&gt;;\n    fan,trig_temp_level1 = &lt;60&gt;;\n    fan,trig_temp_level2 = &lt;65&gt;;\n    fan,trig_temp_level3 = &lt;70&gt;;\n    hwver = \"VIM3.V11\";\n  };\n  ...\n};\n</code></pre> Um node chamado <code>khadas-mcu</code> dentro do node <code>i2c_AO</code> (o mesmo que controla o STM8S). Ainda \u00e9 poss\u00edvel observar que o endere\u00e7o utilizado \u00e9 o 0x18 (<code>reg = &lt;0x18&gt;;</code>). Agora resta testar.</p>"},{"location":"android/boards/vim3/kernel/drivers/fan/#testando-no-kernel-android","title":"Testando no Kernel Android","text":"<p>Para testar, adicionei o seguinte conte\u00fado no final do arquivo:</p> arch/arm64/boot/dts/amlogic/meson-g12b-a311d-khadas-vim3.dts<pre><code>...\n\n&amp;i2c_AO {\n  khadas-mcu {\n    compatible = \"khadas-mcu\";\n    reg = &lt;0x18&gt;;\n    fan,trig_temp_level0 = &lt;50&gt;;\n    fan,trig_temp_level1 = &lt;60&gt;;\n    fan,trig_temp_level2 = &lt;65&gt;;\n    fan,trig_temp_level3 = &lt;70&gt;;\n    hwver = \"VIM3.V11\";\n  };\n};\n</code></pre> <p>Dessa forma, \u00e9 poss\u00edvel ter acesso ao componente que tenha o endere\u00e7o <code>0x18</code> (ainda n\u00e3o \u00e9 certeza que seja o <code>STM8S</code>). Buildando o Kernel com essas altera\u00e7\u00f5es e adicionando ao AOSP, so resta flashar o <code>boot.img</code> e checar se o endere\u00e7o <code>0x18</code> est\u00e1 dispon\u00edvel. Para isso, \u00e9 poss\u00edvel utilizar o comando <code>i2cdetect</code>, por meio do <code>adb shell</code>. O retorno do comando foi o seguinte:</p> <p><pre><code>\u2570\u2500\u276f adb shell\njaoboard:/ # i2cdetect -y 0                                                    \n     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f\n00:          -- -- -- -- -- -- -- -- -- -- -- 0e --\n10: -- -- -- -- -- -- -- -- 18 -- -- -- -- -- -- --\n20: UU -- 22 -- -- -- -- -- -- -- -- -- -- -- -- --\n30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\n40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\n50: -- 51 -- -- -- -- -- -- -- -- -- -- -- -- -- --\n60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\n70: -- -- -- -- -- -- -- --       \n</code></pre> Tudo caminhando bem, endere\u00e7o <code>0x18</code> habilitado. Entretanto, existe um problema, mesmo que o endere\u00e7o seja o do <code>STM8S</code>, ele \u00e9 apenas uma interface para controlar a FAN. Dessa forma, existe um firmware gravado nele (na qual n\u00e3o temos acesso) que dado uma entrada ele executa uma sa\u00edda.</p> <p>Checando a escassa documenta\u00e7\u00e3o da placa, encontrei o seguinte pdf vim3_mcu_reg_en que n\u00e3o faz nenhuma men\u00e7\u00e3o ao <code>STM8S</code>, mas possui a seguinte linha:</p> Address Register Name Byte R/W Note 0x88 CMD_FAN_STATUS_CTRL 0 W 0\uff1aDisable Fan1\uff1aFan Speed Level 12\uff1aFan Speed Level 23\uff1aFan Speed Level 3 <p>Fiz o seguinte teste no shell do Android:</p> <pre><code>jaoboard:/ # i2cset 0 0x18 0x88 1 w                                            \nWrite register 0x88 from chip 0x18 on bus 0? (Y/n):\n</code></pre> <p>e Voil\u00e0 a ventoinha come\u00e7ou a girar.</p> <p> </p>    Ventoinha funcionando"},{"location":"android/boards/vim3/kernel/drivers/fan/#conclusao","title":"Conclus\u00e3o","text":"<p>Sem d\u00favidas, a falta de documenta\u00e7\u00e3o para as placas em geral \u00e9 um grande problema e isso dificulta o Bring up das mesmas. Se n\u00e3o tiver uma equipe interna para fazer as implementa\u00e7\u00f5es, \u00e9 praticamente imposs\u00edvel fazer alguma coisa funcionar. Como foi poss\u00edvel perceber nesse post, se n\u00e3o fosse algu\u00e9m da pr\u00f3pria khadas para gerar o DTS com o endere\u00e7o, a ventoinha seria inacess\u00edvel, uma vez que existe uma interface para controla-la. Mas no fim, deu tudo certo e seguimos na luta para aprender sobre embarcados :).</p>"},{"location":"linguagens/Rust/Cap1/","title":"Introdu\u00e7\u00e3o","text":"<ul> <li> Instalando o Rust no linux</li> <li> Escrevendo o Hello World!</li> <li> Usando <code>cargo</code> (gerenciador de pacotes e sistema de build)</li> </ul>"},{"location":"linguagens/Rust/Cap1/#instalando-o-rust-no-linux","title":"Instalando o Rust no linux","text":"<p>Devemos baixar o <code>rustup</code>, que \u00e9 responsp\u00e1vel por baixar o <code>rust</code> e fazer a instala\u00e7\u00e3o</p> <pre><code>curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh\n</code></pre> <p>Algumas informa\u00e7\u00f5es devem aparecer</p> <p>Welcome to Rust!</p> <p>This will download and install the official compiler for the Rust programming language, and its package manager, Cargo.</p> <p>Rustup metadata and toolchains will be installed into the Rustup home directory, located at:</p> <p>/home/jao/Documents/Programs/rust/rustup/</p> <p>This can be modified with the RUSTUP_HOME environment variable.</p> <p>The Cargo home directory located at:</p> <p>/home/jao/Documents/Programs/rust/cargo/</p> <p>This can be modified with the CARGO_HOME environment variable.</p> <p>The cargo, rustc, rustup and other commands will be added to Cargo's bin directory, located at:</p> <p>/home/jao/.cargo/bin</p> <p>This path will then be added to your PATH environment variable by modifying the profile files located at:</p> <p>/home/jao/.profile   /home/jao/.zshenv</p> <p>You can uninstall at any time with rustup self uninstall and these changes will be reverted.</p> <p>Current installation options:</p> <p>default host triple: x86_64-unknown-linux-gnu      default toolchain: stable (default)                profile: default   modify PATH variable: yes</p> <p>1) Proceed with installation (default)  2) Customize installation 3) Cancel installation</p> <p>Basta digitar 1 e a instala\u00e7\u00e3o ir\u00e1 come\u00e7ar. </p> <p>Se tudo occorrer bem, a seguinte mensagem deve aparecer</p> <p>Rust is installed now. Great!</p> <p>To get started you may need to restart your current shell. This would reload your PATH environment variable to include Cargo's bin directory (/home/jao/Documents/Programs/rust/cargo//bin).</p> <p>To configure your current shell, run: source /home/jao/Documents/Programs/rust/cargo//env</p>"},{"location":"linguagens/Rust/Cap1/#alguns-comandos-uteis","title":"Alguns comandos \u00fateis","text":"<ul> <li>rustup update</li> <li>rustup self uninstall</li> <li>rustc --version</li> <li>rustup doc</li> </ul>"},{"location":"linguagens/Rust/Cap1/#escrevendo-o-hello-world","title":"Escrevendo o Hello World!","text":"<p>Crie um arquivo chamado <code>main.rs</code> e adicione o conte\u00fado</p> main.rs<pre><code>fn main() {\n    println!(\"Hello World!\");\n}\n</code></pre> <p>Para compilar e executar, basta digitar no terminal</p> <pre><code>rustc main.rc\n./main\n</code></pre> <p>O resultado ser\u00e1 o texto Hello World!</p>"},{"location":"linguagens/Rust/Cap1/#alguns-comandos-uteis_1","title":"Alguns comandos \u00fateis","text":"<ul> <li>rustfmt (para formatar o c\u00f3digo)</li> </ul>"},{"location":"linguagens/Rust/Cap1/#usando-cargo-gerenciador-de-pacotes-e-sistema-de-build","title":"Usando cargo (gerenciador de pacotes e sistema de build)","text":"<p>Para criar um projeto utilizando o <code>cargo</code>, basta usar o comando</p> <pre><code>cargo new hello_cargo\n</code></pre> <p>Um arquivo <code>main.rs</code> ser\u00e1 criado dentro da pasta <code>hello_cargo/src/</code>. Para compilar o c\u00f3digo, basta digitar</p> <pre><code>cargo build\n</code></pre> <p>dentro da pasta hello_cargo, a pasta <code>target/</code>ser\u00e1 criada e o execut\u00e1vel est\u00e1 em <code>hello_cargo/target/debug</code>, chamado de hello_cargo</p>"},{"location":"linguagens/Rust/Cap1/#comandos-uteis","title":"Comandos \u00fateis","text":"<ul> <li>cargo run (para executar o programa)</li> <li>cargo check (para fazer as checagens no c\u00f3digo, sem compilar)</li> <li>cargo build --release (para fazer uma build de release, por padr\u00e3o a build \u00e9 de debug).</li> </ul>"},{"location":"linguagens/Rust/Cap2/","title":"Adivinha\u00e7\u00e3o","text":""},{"location":"linguagens/Rust/Cap2/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>Dando continuidade ao conhecimento do <code>Rust</code>, vamos ao cap\u00edtulo 2 do livro:</p> <p>The Rust Programming Language</p> <p>Ele prop\u00f5em introduzir alguns conceitos comuns da linguagem, criando o jogo da adivinha\u00e7\u00e3o</p>"},{"location":"linguagens/Rust/Cap2/#configurando-o-projeto","title":"Configurando o Projeto","text":"<p>Criei um novo projeto utilizando o <code>Cargo</code>:</p> <pre><code>cargo new adivinhacao\n</code></pre>"},{"location":"linguagens/Rust/Cap2/#comecando-o-jogo","title":"Come\u00e7ando o Jogo","text":"<p>Vou dividir em alguns passos para facilitar o passo a passo da cria\u00e7\u00e3o do jogo.</p> <p>Para compilar o programa utilizei o <code>cargo build</code> e para executar <code>cargo run</code>.</p>"},{"location":"linguagens/Rust/Cap2/#input","title":"Input","text":"<p>O primeiro passo \u00e9 saber como fazer um input do usu\u00e1rio. Para isso, segue o c\u00f3digo abaixo:</p> src/main.rs<pre><code>// Baseado no exemplo do pr\u00f3prio livo, com algumas modifica\u00e7\u00f5es\n\nuse std::io; //Lib para tratar de I/O\n\nfn main() {\n\n    // Observe o termo \"mut\", pois essa vari\u00e1vel \n    // ser\u00e1 alterada com a entrada do usu\u00e1rio\n    let mut guess = String::new(); \n\n    io::stdin()\n      .read_line(&amp;mut guess) // L\u00ea a entrada e atribui a vari\u00e1vel \"guess\"\n      .expect(\"Failed to read line\"); // Caso algo saia errado, mostra a mensagem\n\n    println!(\"You guessed: {guess}\"); //Mostra a entrada do usu\u00e1rio\n}\n</code></pre>"},{"location":"linguagens/Rust/Cap2/#numeros-aleatorios","title":"N\u00fameros Aleat\u00f3rios","text":"<p>O <code>Rust</code> n\u00e3o possui a gera\u00e7\u00e3o de n\u00fameros aleat\u00f3rios em sua biblioteca padr\u00e3o. Com isso, usei o rand dispon\u00edvel no crate. Para isso, \u00e9 necess\u00e1rio adicionar a biblioteca no arquivo Cargo.toml:</p> <pre><code>[dependencies]\nrand = \"0.8.3\"\n</code></pre> <p>Agora utilize o comando <code>cargo build</code> para instalar a depend\u00eancia.</p> <p>Voltando ao c\u00f3digo, vamos adicionar biblioteca e a fun\u00e7\u00e3o que gera os n\u00fameros:</p> src/main.rs<pre><code>// Baseado no exemplo do pr\u00f3prio livro, com algumas modifica\u00e7\u00f5es\n\nuse std::io; //Lib para tratar de I/O\nuse rand::Rng; //Lib para gerar n\u00fameros rand\u00f4micos\n\nfn main() {\n\n    // Gera um n\u00famero inteiro de 0 a 100\n    let secret_number = rand::thread_rng().\n                            gen_range(1..=100);\n\n    println!(\"The secret number is: {secret_number}\");\n\n    // Observe o termo \"mut\", pois essa vari\u00e1vel \n    // ser\u00e1 alterada com a entrada do usu\u00e1rio\n    let mut guess = String::new(); \n\n    io::stdin()\n      .read_line(&amp;mut guess) // L\u00ea a entrada e atribui a vari\u00e1vel \"guess\"\n      .expect(\"Failed to read line\"); // Caso algo saia errado, mostra a mensagem\n\n    println!(\"You guessed: {guess}\"); //Mostra a entrada do usu\u00e1rio\n}\n</code></pre>"},{"location":"linguagens/Rust/Cap2/#comparando","title":"Comparando","text":"<p>Uma vez que a entrada do usu\u00e1rio e o n\u00famero rand\u00f4mico est\u00e3o dispon\u00edveis, s\u00f3 resta fazer a compara\u00e7\u00e3o entre os dois e checar se \u00e9 menor, maior ou igual.</p> src/main.rs<pre><code>// Baseado no exemplo do pr\u00f3prio livro, com algumas modifica\u00e7\u00f5es\n\nuse std::io; //Lib para tratar de I/O\nuse rand::Rng; //Lib para gerar n\u00fameros rand\u00f4micos\nuse std::cmp::Ordering; //Lib para fazer compara\u00e7\u00e3o\n\nfn main() {\n\n    // Gera um n\u00famero inteiro de 0 a 100\n    let secret_number = rand::thread_rng().\n                            gen_range(1..=100);\n\n    println!(\"The secret number is: {secret_number}\");\n\n    // Observe o termo \"mut\", pois essa vari\u00e1vel \n    // ser\u00e1 alterada com a entrada do usu\u00e1rio\n    let mut guess = String::new(); \n\n    io::stdin()\n      .read_line(&amp;mut guess) // L\u00ea a entrada e atribui a vari\u00e1vel \"guess\"\n      .expect(\"Failed to read line\"); // Caso algo saia errado, mostra a mensagem\n\n    // Converte a entrada para inteiro\n    let guess: u32 = guess.trim().parse().\n                        expect(\"\\n\\n&gt;&gt;&gt;&gt; Please type a integer number! &lt;&lt;&lt;&lt;\\n\\n\");\n\n    println!(\"You guessed: {guess}\"); //Mostra a entrada do usu\u00e1rio\n\n    // Compara e informa se o n\u00famero \u00e9 menor, maior ou igual\n    match guess.cmp(&amp;secret_number) {\n        Ordering::Less =&gt; println!(\"Too small!\"),\n        Ordering::Greater =&gt; println!(\"Too big!\"),\n        Ordering::Equal =&gt; println!(\"You win!\"),\n    }\n}\n</code></pre>"},{"location":"linguagens/Rust/Cap2/#tentando-novamente","title":"Tentando Novamente","text":"<p>At\u00e9 agora o jogo s\u00f3 permite apenas uma tentativa (try hard ). Agora vou adicionar o loop para fazer v\u00e1rias tentativas.</p> src/main.rs<pre><code>// Baseado no exemplo do pr\u00f3prio livro, com algumas modifica\u00e7\u00f5es\n\nuse std::io; //Lib para tratar de I/O\nuse rand::Rng; //Lib para gerar n\u00fameros rand\u00f4micos\nuse std::cmp::Ordering; //Lib para fazer compara\u00e7\u00e3o\n\nfn main() {\n\n    // Gera um n\u00famero inteiro de 0 a 100\n    let secret_number = rand::thread_rng().\n                            gen_range(1..=100);\n\n    println!(\"The secret number is: {secret_number}\");\n\n    loop {\n\n        // Observe o termo \"mut\", pois essa vari\u00e1vel \n        // ser\u00e1 alterada com a entrada do usu\u00e1rio\n        let mut guess = String::new(); \n\n\n        io::stdin()\n        .read_line(&amp;mut guess) // L\u00ea a entrada e atribui a vari\u00e1vel \"guess\"\n        .expect(\"Failed to read line\"); // Caso algo saia errado, mostra a mensagem\n\n        // Converte a entrada para inteiro\n        let guess: u32 = guess.trim().parse().\n                            expect(\"\\n\\n&gt;&gt;&gt;&gt; Please type a integer number! &lt;&lt;&lt;&lt;\\n\\n\");\n\n        println!(\"You guessed: {guess}\"); //Mostra a entrada do usu\u00e1rio\n\n        // Compara e informa se o n\u00famero \u00e9 menor, maior ou igual\n        match guess.cmp(&amp;secret_number) {\n            Ordering::Less =&gt; println!(\"Too small!\"),\n            Ordering::Greater =&gt; println!(\"Too big!\"),\n            Ordering::Equal =&gt; println!(\"You win!\"),\n        }\n    }\n}\n</code></pre>"},{"location":"linguagens/Rust/Cap2/#ganhando","title":"Ganhando","text":"<p>Mesmo digitando o n\u00famero correto, o jogo ainda permite fazer uma nova tentativa. Vou adicionar um break quando o n\u00famero digitado for o correto.</p> src/main.rs<pre><code>// Baseado no exemplo do pr\u00f3prio livro, com algumas modifica\u00e7\u00f5es\n\nuse std::io; //Lib para tratar de I/O\nuse rand::Rng; //Lib para gerar n\u00fameros rand\u00f4micos\nuse std::cmp::Ordering; //Lib para fazer compara\u00e7\u00e3o\n\nfn main() {\n\n    // Gera um n\u00famero inteiro de 0 a 100\n    let secret_number = rand::thread_rng().\n                            gen_range(1..=100);\n\n    println!(\"The secret number is: {secret_number}\");\n\n    loop {\n\n        // Observe o termo \"mut\", pois essa vari\u00e1vel \n        // ser\u00e1 alterada com a entrada do usu\u00e1rio\n        let mut guess = String::new(); \n\n\n        io::stdin()\n        .read_line(&amp;mut guess) // L\u00ea a entrada e atribui a vari\u00e1vel \"guess\"\n        .expect(\"Failed to read line\"); // Caso algo saia errado, mostra a mensagem\n\n        // Converte a entrada para inteiro\n        let guess: u32 = guess.trim().parse().\n                            expect(\"\\n\\n&gt;&gt;&gt;&gt; Please type a integer number! &lt;&lt;&lt;&lt;\\n\\n\");\n\n        println!(\"You guessed: {guess}\"); //Mostra a entrada do usu\u00e1rio\n\n        // Compara e informa se o n\u00famero \u00e9 menor, maior ou igual\n        match guess.cmp(&amp;secret_number) {\n            Ordering::Less =&gt; println!(\"Too small!\"),\n            Ordering::Greater =&gt; println!(\"Too big!\"),\n            Ordering::Equal =&gt; {\n                println!(\"You win!\");\n                break;\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"linguagens/Rust/Cap2/#tratando-erros","title":"Tratando Erros","text":"<p>Caso a entrada do usu\u00e1rio n\u00e3o seja exatamente um inteiro, ocorre um crash no jogo. Vou adicionar um tratamento para lidar com esse problema.</p> src/main.rs<pre><code>// Baseado no exemplo do pr\u00f3prio livro, com algumas modifica\u00e7\u00f5es\n\nuse std::io; //Lib para tratar de I/O\nuse rand::Rng; //Lib para gerar n\u00fameros rand\u00f4micos\nuse std::cmp::Ordering; //Lib para fazer compara\u00e7\u00e3o\n\nfn main() {\n\n    // Gera um n\u00famero inteiro de 0 a 100\n    let secret_number = rand::thread_rng().\n                            gen_range(1..=100);\n\n    println!(\"The secret number is: {secret_number}\");\n\n    loop {\n\n        // Observe o termo \"mut\", pois essa vari\u00e1vel \n        // ser\u00e1 alterada com a entrada do usu\u00e1rio\n        let mut guess = String::new(); \n\n\n        io::stdin()\n        .read_line(&amp;mut guess) // L\u00ea a entrada e atribui a vari\u00e1vel \"guess\"\n        .expect(\"Failed to read line\"); // Caso algo saia errado, mostra a mensagem\n\n        // Converte a entrada para inteiro\n        let guess: u32 = match guess.trim().parse() {\n            Ok(num) =&gt; num,\n            Err(_) =&gt; {\n                println!(\"Entrada Inv\u00e1lido\");\n                continue;\n            }\n        };\n\n        println!(\"You guessed: {guess}\"); //Mostra a entrada do usu\u00e1rio\n\n        // Compara e informa se o n\u00famero \u00e9 menor, maior ou igual\n        match guess.cmp(&amp;secret_number) {\n            Ordering::Less =&gt; println!(\"Too small!\"),\n            Ordering::Greater =&gt; println!(\"Too big!\"),\n            Ordering::Equal =&gt; {\n                println!(\"You win!\");\n                break;\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"linguagens/Rust/Cap2/#conclusao","title":"Conclus\u00e3o","text":"<p>Criar o jogo introduziu o conceito de <code>match</code>, <code>loop</code>, <code>mut</code> e <code>Crate</code>. Que s\u00e3o b\u00e1sicos na linguagem.</p>"},{"location":"linguagens/Rust/Cap3/","title":"Conceitos","text":"<p>Dando continuidade ao conhecimento do <code>Rust</code>, vamos ao cap\u00edtulo 3 do livro:</p> <p>The Rust Programming Language</p> <p>Neste cap\u00edtulo \u00e9 visto os conceitos comuns de toda as linguagens, como: </p> <ul> <li> Vari\u00e1veis e mutabilidade</li> <li> Tipos de dado</li> <li> Fun\u00e7\u00f5es</li> <li> Coment\u00e1rios</li> <li> Controle de fluxo </li> </ul>"},{"location":"linguagens/Rust/Cap3/#variaveis-e-mutabilidade","title":"Vari\u00e1veis e Mutabilidade","text":""},{"location":"linguagens/Rust/Cap3/#imutabilidade","title":"Imutabilidade","text":"<p>Por padr\u00e3o, as vari\u00e1veis s\u00e3o imut\u00e1veis. Isso acaba gerando mais seguran\u00e7a na hora de escrever o c\u00f3digo, mas ainda existe a op\u00e7\u00e3o de criar vari\u00e1veis m\u00fataveis.</p> <p>Para exemplificar, criei o projeto <code>variables</code>, com o comando:</p> <pre><code>cargo new variables\n</code></pre> <p>e criei o seguinte programa: </p> <pre><code>fn main() {\n    let x = 5;\n    println!(\"The value of x is: {x}\");\n    x = 6;\n    println!(\"The value of x is: {x}\");\n}\n</code></pre> <p>ao tentar compilar o programa, o seguinte erro ir\u00e1 aparecer:</p> <p>error[E0384]: cannot assign twice to immutable variable <code>x</code>   --&gt; src/main.rs:4:5   | 2 |     let x = 5;   |         -   |         |   |         first assignment to <code>x</code>   |         help: consider making this binding mutable: <code>mut x</code> 3 |     println!(\"The value of x is: {x}\"); 4 |     x = 6;   |     ^^^^^ cannot assign twice to immutable variable  For more information about this error, try <code>rustc --explain E0384</code>. error: could not compile <code>variables</code> due to previous error</p> <p>O erro \u00e9 <code>cannot assign twice to immutable variable</code>, isso quer dizer que uma vari\u00e1vel teve seu valor alterado durante a execu\u00e7\u00e3o do programa. Como por padr\u00e3o <code>rust</code> possui vari\u00e1veis imut\u00e1veis, esse erro acabou ocorrendo (linha 6).</p> <p>Apesar de <code>rust</code> encorajar o uso de vari\u00e1veis imut\u00e1veis, \u00e9 poss\u00edvel criar vari\u00e1veis mut\u00e1veis, basta fazer a seguinte altera\u00e7\u00e3o no programa:</p> <pre><code>fn main() {\n    let mut x = 5;\n    println!(\"The value of x is: {x}\");\n    x = 6;\n    println!(\"The value of x is: {x}\");\n}\n</code></pre> <p>Agora, o programa ir\u00e1 compilar e rodar corretamente.</p>"},{"location":"linguagens/Rust/Cap3/#constantes","title":"Constantes","text":"<p>Como vari\u00e1veis imut\u00e1veis, as constantes tamb\u00e9m n\u00e3o podem ser alteradas. Existem algumas diferen\u00e7as entre elas:</p> <ul> <li>N\u00e3o \u00e9 permitido usar <code>mut</code> em constantes</li> <li>Constantes s\u00e3o declaradas com <code>const</code></li> <li>O tipo da constante deve ser declarado.</li> <li>Constantes podem ser declaradas em qualquer escopo</li> </ul> <p>Um exemplo de declara\u00e7\u00e3o de constante:</p> <pre><code>fn main() {\n    const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;\n}\n</code></pre>"},{"location":"linguagens/Rust/Cap3/#shadowing","title":"Shadowing","text":"<p>\u00c9 poss\u00edvel declarar vari\u00e1veis com o mesmo nome, em <code>rust</code> isso quer dizer que A primeira vari\u00e1vel \u00e9 shadowing pela segunda. Segue um exemplo:</p> <pre><code>fn main() {\n\n    let x = 5;\n\n    let x = x + 1;\n\n    {\n        let x = x * 2;\n        println!(\"The value of x in the inner scope is: {x}\");\n    }\n\n    println!(\"The value of x is: {x}\");\n}\n</code></pre> <p>Na linha 5, a vari\u00e1vel <code>x</code> \u00e9 shadowing pelo da linha 6. Dessa forma, o novo valor de <code>x</code> \u00e9 6. Na linha 8, ocorre o mesmo processo, resultando em <code>x</code> com valor 12. A diferen\u00e7a \u00e9 que na linha 8, <code>x</code> est\u00e1 em outro escopo. Por isso, o valor de <code>x</code> na linha 12 n\u00e3o \u00e9 alterado.</p> <p>O resultado da execu\u00e7\u00e3o do programa \u00e9:</p> <p>The value of x in the inner scope is: 12  The value of x is: 6</p> <p>A diferen\u00e7a entre shadowing e vari\u00e1veis com <code>mut</code>, \u00e9 que um erro de compila\u00e7\u00e3o vai surgir se o valor da vari\u00e1vel for modificada. Com shadowing a vari\u00e1vel continua imut\u00e1vel, ou seja, o valor da vari\u00e1vel n\u00e3o \u00e9 simplesmente alterado, ela \u00e9 totalmente recriada (como uma nova vari\u00e1vel) em outra regi\u00e3o de mem\u00f3ria.</p> <p>Esse exemplo ajuda a entender:</p> <pre><code>fn main() {\n    let spaces = \"   \";\n    let spaces = spaces.len();\n    println!(\"Spaces is {spaces}\");\n}\n</code></pre> <p>Inicialmente a vari\u00e1vel <code>spaces</code> \u00e9 uma <code>&amp;str</code>, mas logo em seguida \u00e9 um <code>usize</code>. Essa \u00e9 uma vantagem do shadowing.</p> <p>Utilizando o <code>mut</code>, essa abordagem n\u00e3o \u00e9 poss\u00edvel:</p> <pre><code>fn main() {\n    let mut spaces = \"   \";\n    spaces = spaces.len();\n    println!(\"Spaces is {spaces}\");\n}\n</code></pre> <p>Ao tentar compilar o programa, o seguinte erro aparece:</p> <p>error[E0308]: mismatched types  --&gt; src/main.rs:3:14   | 2 |     let mut spaces = \"   \";   |                      ----- expected due to this value 3 |     spaces = spaces.len();   |              ^^^^^^^^^^^^ expected <code>&amp;str</code>, found <code>usize</code>  For more information about this error, try <code>rustc --explain E0308</code>. error: could not compile <code>variables</code> due to previous error</p>"},{"location":"linguagens/Rust/Cap3/#tipos-de-dado","title":"Tipos de dado","text":"<p><code>Rust</code> \u00e9 uma linguagem estaticamente tipada, isso quer dizer que os tipos de todas as vari\u00e1veis devem ser conhecidas em tempo de compila\u00e7\u00e3o. Neste caso, o compilador ir\u00e1 inferir o tipo do dado. Em casos onde o tipo pode ser ambiguo, \u00e9 nesser\u00e1rio adicionar o tipo manualmente, por exemplo:</p> <pre><code>let guess: u32 = \"42\".parse().expect(\"Not a number!\");\n</code></pre> <p>Se o tipo <code>u32</code> n\u00e3o for declarado, a compila\u00e7\u00e3o retorna um erro.</p>"},{"location":"linguagens/Rust/Cap3/#escalar","title":"Escalar","text":"<p>O escalar representa um \u00fanico valor. <code>Rust</code> possui 4 tipos de principais de escalares:</p> <ol> <li>interger</li> <li>floating-point</li> <li>Booleans</li> <li>Character</li> </ol>"},{"location":"linguagens/Rust/Cap3/#inteiros","title":"Inteiros","text":"<p>Existem tamb\u00e9m alguns inteiros built-in:</p> Tamanho com sinal sem sinal 8-bits i8 u8 16-bits i16 u16 32-bits i32 (padr\u00e3o) u32 64-bits i64 u64 128-bits i128 u128 arch isize usize <p>Al\u00e9m disso, \u00e9 poss\u00edvel escrever inteiros na forma literal de outras formas:</p> Number literals Example Decimal 98_222 Hex 0xFF Octal 0o77 Binary 0b1111_0000 Byte (u8 only) b'A'"},{"location":"linguagens/Rust/Cap3/#ponto-flutuante","title":"Ponto-Flutuante","text":"<p><code>Rust</code> possui 2 tipos primitivos para ponto-flutuante:</p> <ul> <li>f32 - single-precision</li> <li>f64 - double-precision (padr\u00e3o)</li> </ul> <pre><code>fn main() {\n    let x = 2.0; // f64\n\n    let y: f32 = 3.0; // f32\n}\n</code></pre> <p>Pontos flutuantes em rust s\u00e3o representados de acordo com o IEEE-754.</p>"},{"location":"linguagens/Rust/Cap3/#operacao-com-numeros","title":"Opera\u00e7\u00e3o com n\u00fameros","text":"<ul> <li>Adi\u00e7\u00e3o</li> <li>Subtra\u00e7\u00e3o</li> <li>Multiplica\u00e7\u00e3o</li> <li>Divis\u00e3o</li> <li>Resto</li> </ul> <pre><code>fn main() {\n    // Adi\u00e7\u00e3o\n    let sum = 5 + 10;\n\n    // Subtra\u00e7\u00e3o\n    let difference = 95.5 - 4.3;\n\n    // Multiplica\u00e7\u00e3o\n    let product = 4 * 30;\n\n    // Divis\u00e3o\n    let quotient = -1.0 / 2.0;\n    let truncated = -1 / 2; // Results in 0\n\n    // Resto\n    let remainder = 43 % 5;\n}\n</code></pre>"},{"location":"linguagens/Rust/Cap3/#boolean","title":"Boolean","text":"<p><code>Rust</code> possui 2 valores poss\u00edveis:</p> <ul> <li>true</li> <li>false</li> </ul>"},{"location":"linguagens/Rust/Cap3/#caracteres","title":"Caracteres","text":"<p>Este tipo possui 4 bytes e suporta:</p> <ul> <li>ASCII</li> <li>Accented letters</li> <li>Chinese</li> <li>Japanese</li> <li>Korean characters</li> <li>emoji</li> <li>Unicode</li> </ul> <p>Alguns exemplos:</p> <pre><code>fn main() {\n    let c = 'z';\n    let z: char = '\u2124'; // with explicit type annotation\n    let heart_eyed_cat = '\ud83d\ude3b';\n}\n</code></pre> <p>char literais utilizam aspas simples, ao contr\u00e1rio de strings literais que usam aspas duplas. </p> <p>Unicode: </p> <ul> <li><code>U+0000</code> at\u00e9 <code>U+D7FF</code> </li> <li><code>U+E000</code> at\u00e9 <code>U+10FFFF</code></li> </ul>"},{"location":"linguagens/Rust/Cap3/#composto","title":"Composto","text":"<p><code>Rust</code> possui 2 tipos basicos de tipos compostos:</p> <ul> <li>tuples</li> <li>arrays</li> </ul>"},{"location":"linguagens/Rust/Cap3/#tuplas","title":"Tuplas","text":"<p>\u00c9 capaz de juntar diversos tipos em um \u00fanico tipo composto. Tuplas possuem tamanho fixo, ou seja, uma vez declarado, n\u00e3o pode ser alterado.</p> <pre><code>fn main() {\n    let tup: (i32, f64, bool, char) = (500, 6.4, true, '\ud83d\ude3b');\n    let (x, y, z, a) = tup; // destructuring\n\n    let tup_0 = tup.0;\n    let tup_1 = tup.1;\n    let tup_2 = tup.2;\n    let tup_3 = tup.3;\n\n    let unit : ();\n}\n</code></pre> <p>Uma tupla vazia \u00e9 chamada de <code>unit</code>.</p>"},{"location":"linguagens/Rust/Cap3/#arrays","title":"Arrays","text":"<p>Diferente das tuplas, todos os elementos de um <code>arrays</code> s\u00e3o do mesmo tipo. Tamb\u00e9m possuem tamanho fixo.</p> <pre><code>fn main() {\n    let a = [1, 2, 3, 4, 5];\n    let b: [i32; 5] = [1, 2, 3, 4, 5]; // Declaring explicit type in initialization\n    let c = [3; 5]; // Result: [3, 3, 3, 3, 3];\n\n    let first_a = a[0];\n}\n</code></pre> <p>Arrays s\u00e3o uteis quando se quer utilizar a stack ao inv\u00e9s da heap</p>"},{"location":"linguagens/Rust/Cap3/#funcoes","title":"Fun\u00e7\u00f5es","text":"<p><code>Rust</code>, por convens\u00e3o, utiliza snake case como estilo para fun\u00e7\u00f5es e nome de vari\u00e1veis. As fun\u00e7\u00f5es podem ser declaradas antes ou depois da <code>main</code>.</p> <pre><code>fn other_function(value: i32, unit_label: char) {\n    println!(\"The measurement is: {value}{unit_label}\");\n}\n\nfn main() {\n    println!(\"Hello, world!\");\n\n    another_function();\n    other_function(5, 'h');\n}\n\nfn another_function() {\n    println!(\"Another function.\");\n}\n</code></pre> <p>Existe uma distin\u00e7\u00e3o entre: Declara\u00e7\u00f5es e Express\u00f5es:</p> <ul> <li>Statements: N\u00e3o retornam valores ap\u00f3s sua execu\u00e7\u00e3o.</li> </ul> <pre><code>fn main() {\n    statement_function();\n}\n\nfn statement_function() {\n  println!(\"Statement\");\n}\n</code></pre> <ul> <li>Expressions: Retornam algum valor ap\u00f3s sua execu\u00e7\u00e3o.</li> </ul> <pre><code>fn main() {\n    let y = {\n        let x = 3;\n        x + 1\n    };\n\n    println!(\"The value of y is: {y}\");\n}\n</code></pre>"},{"location":"linguagens/Rust/Cap3/#retorno","title":"Retorno","text":"<p>Fun\u00e7\u00f5es que retornam algum valor utilizam a seta (<code>-&gt;</code>) em sua assinatura para determinar o tipo do retorno:</p> <pre><code>fn main() {\n    let x = plus_one(5);\n\n    println!(\"The value of x is: {x}\");\n}\n\nfn plus_one(x: i32) -&gt; i32 {\n    x + 1\n}\n</code></pre> <p>Observe que para retorno, n\u00e3o \u00e9 utilizado o ponto e virgula no final. Caso ele seja colocado o compilador ir\u00e1 retornar um erro.</p>"},{"location":"linguagens/Rust/Cap3/#comentarios","title":"Coment\u00e1rios","text":"<p>Coment\u00e1rios em <code>rust</code> utilizam apenas <code>//</code>.</p> <pre><code>// This is a\n// Multiple Line commnet\n\nfn main() {\n    // Single line comment\n    let lucky_number = 7; // I\u2019m feeling lucky today\n}\n</code></pre>"},{"location":"linguagens/Rust/Cap3/#controle-de-fluxo","title":"Controle de fluxo","text":""},{"location":"linguagens/Rust/Cap3/#if","title":"If","text":"<p>Forma mais comum, utilizadas em outras linguagens:</p> <pre><code>fn main() {\n    let number = 6;\n\n    if number % 4 == 0 {\n        println!(\"number is divisible by 4\");\n    } else if number % 3 == 0 {\n        println!(\"number is divisible by 3\");\n    } else if number % 2 == 0 {\n        println!(\"number is divisible by 2\");\n    } else {\n        println!(\"number is not divisible by 4, 3, or 2\");\n    }\n}\n</code></pre> <p>Uma forma mais enxuta de <code>if</code>, \u00e9 chamada em <code>rust</code>de let statement:</p> <pre><code>fn main() {\n    let condition = true;\n    let number = if condition { 5 } else { 6 };\n\n    println!(\"The value of number is: {number}\");\n}\n</code></pre>"},{"location":"linguagens/Rust/Cap3/#loops-com-repeticao","title":"Loops com Repeti\u00e7\u00e3o","text":""},{"location":"linguagens/Rust/Cap3/#loop","title":"loop","text":"Infite Loop<pre><code>fn main() {\n    loop {\n        println!(\"again!\");\n    }\n}\n</code></pre> Loop with return<pre><code>fn main() {\n    let mut counter = 0;\n\n    let result = loop {\n        counter += 1;\n\n        if counter == 10 {\n            break counter * 2;\n        }\n    };\n\n    println!(\"The result is {result}\");\n}\n</code></pre> <p>Quando possui <code>loop</code>dentro de outro <code>loop</code> e queremos usar o comandos <code>break</code> ou <code>continue</code>, em <code>rust</code> \u00e9 poss\u00edvel criar etiquetas para cada <code>loop</code>:</p> Loop Label<pre><code>fn main() {\n    let mut count = 0;\n    'counting_up: loop {\n        println!(\"count = {count}\");\n        let mut remaining = 10;\n\n        loop {\n            println!(\"remaining = {remaining}\");\n            if remaining == 9 {\n                break;\n            }\n            if count == 2 {\n                break 'counting_up;\n            }\n            remaining -= 1;\n        }\n\n        count += 1;\n    }\n    println!(\"End count = {count}\");\n}\n</code></pre>"},{"location":"linguagens/Rust/Cap3/#while","title":"while","text":"<pre><code>fn main() {\n    let mut number = 3;\n\n    while number != 0 {\n        println!(\"{number}!\");\n\n        number -= 1;\n    }\n\n    println!(\"LIFTOFF!!!\");\n}\n</code></pre>"},{"location":"linguagens/Rust/Cap3/#for","title":"for","text":"<pre><code>fn main() {\n    let a = [10, 20, 30, 40, 50];\n\n    for element in a {\n        println!(\"the value is: {element}\");\n    }\n}\n</code></pre> <pre><code>fn main() {\n    for number in (1..4).rev() {\n        println!(\"{number}!\");\n    }\n    println!(\"LIFTOFF!!!\");\n}\n</code></pre>"},{"location":"linguagens/Rust/Cap4/","title":"Ownership","text":"<p>Dando continuidade ao conhecimento do <code>Rust</code>, vamos ao cap\u00edtulo 4 do livro:</p> <p>The Rust Programming Language</p> <p>Neste cap\u00edtulo \u00e9 visto um dos conceitos que faz o <code>rust</code> ser memory safety.</p>"},{"location":"linguagens/Rust/Cap4/#o-que-e-o-ownership","title":"O que \u00e9 o ownership?","text":"<p>Ownership \u00e9 um conjunto de regras que governam a forma como <code>rust</code> gerencia a mem\u00f3ria. Algumas linguagens possuem garbage collector, que varrem a mem\u00f3ria periodicamente buscando aloca\u00e7\u00f5es que n\u00e3o est\u00e3o sendo mais utilizadas. Outras linguagens, o desenvolvedor deve alocar e desalocar a mem\u00f3ria utilizada explicitamente.</p> <p><code>Rust</code> utiliza outra abordagem, a mem\u00f3ria \u00e9 gerenciada por meio de um conjunto de regras checadas pelo compilador. Se alguma dessas regras \u00e9 violada, o compilador retorna um erro.</p>"},{"location":"linguagens/Rust/Cap4/#a-stack-e-a-heap","title":"A Stack e a Heap","text":"<p>Em linguagens de sistema, como <code>rust</code>, se um valor est\u00e1 na stack ou na heap afeta o comportamento da linguagem. Partes do <code>ownership</code> tem rela\u00e7\u00e3o com a stack e a heap.</p> <p>A stack e a heap fazem parte da mem\u00f3ria dispon\u00edvel no c\u00f3digo em tempo de execu\u00e7\u00e3o, mas elas s\u00e3o estruturadas de formas diferentes. A stack armazena os valores em ordem e remove os valores em ordem reversa (LIFO). Adicionar um valor \u00e9 chamado de pushing onto the stack e remover um valor \u00e9 chamado de popping off the stack. Todos os valores armazenados na stack possuem um valor fixo, conhecido. Valors com tamanho desconhecido em tempo de compila\u00e7\u00e3o ou que mudam de tamanho, devem ser armazenados na heap</p> <p>Quando um certo valor \u00e9 armazenado na heap, \u00e9 requisitado uma certa quantidade de mem\u00f3ria (aloca\u00e7\u00e3o). Esse processo \u00e9 chamado de allocating on the heap. Uma vez que o espa\u00e7o de mem\u00f3ria \u00e9 alocado, ele possui um valor fixo e conhecido. O processo de aloca\u00e7\u00e3o retorna um ponteiro com o endere\u00e7o da regi\u00e3o de mem\u00f3ria alocada. Esse ponteiro pode ser armazenado na stack, se quisermos saber o conte\u00fado desse endere\u00e7o de mem\u00f3ria, basta seguir o ponteiro.</p> <p>Adicionar valors na stack n\u00e3o \u00e9 considerado aloca\u00e7\u00e3o.</p> <p>Adicionar um valor na stack \u00e9 mais r\u00e1pido que alocar um espa\u00e7o na heap, porque n\u00e3o \u00e9 necess\u00e1rio procurar um espa\u00e7o dispon\u00edvel.</p> <p>Procurar um valor na heap \u00e9 mais lento do que acessar um valor na stack, porque n\u00e3o \u00e9 preciso seguir o ponteiro para ter acesso ao valor.</p> <p>\u00c9 necess\u00e1rio ficar atento aos valores alocados na heap para evitar duplica\u00e7\u00f5es e consequentemente o desperd\u00edcio. Al\u00e9m de limpar os espa\u00e7os de mem\u00f3ria que n\u00e3o est\u00e3o sendo mais utilizados. Esses problemas s\u00e3o checados pelo <code>ownership</code>.</p> <p>Esse v\u00eddeo mostra alguns exemplos de uso sobre heap The Origins of Process Memory</p>"},{"location":"linguagens/Rust/Cap4/#regras-do-ownership","title":"Regras do Ownership","text":"<p>S\u00e3o eles:</p> <ul> <li>Cada valor em <code>rust</code> possui um dono (owner)</li> <li>S\u00f3 pode existir um dono (owner) de cada vez.</li> <li>Quando o dono (owner) sai do escopo, o valor \u00e9 descartado.</li> </ul>"},{"location":"linguagens/Rust/Cap4/#escopo-de-variavel","title":"Escopo de vari\u00e1vel","text":"<p>Um escopo \u00e9 um espa\u00e7o dentro de um programa:</p> <pre><code>fn main(){\n\n    // s is not valid here, it\u2019s not yet declared\n    {                      \n        let s = \"hello\";   // s is valid from this point forward\n\n        println!(\"{s}\");\n    }\n    // s is not valid here, it\u2019s out of scope\n}\n</code></pre>"},{"location":"linguagens/Rust/Cap4/#o-tipo-string","title":"O tipo String","text":"<p>O tipo <code>string</code> pode exemplificar melhor o uso do <code>ownership</code>. Segue um exemplo simples de uso do tipo <code>string</code>: </p> <pre><code>fn main(){\n\n    let mut s = String::from(\"hello\");\n\n    s.push_str(\", world!\"); // push_str() appends a literal to a String\n\n    println!(\"{}\", s); // This will print `hello, world!`\n}\n</code></pre>"},{"location":"linguagens/Rust/Cap4/#memoria-e-alocacao","title":"Mem\u00f3ria e aloca\u00e7\u00e3o","text":"<p>No caso de <code>string</code> literal:</p> <pre><code>let s = \"hello\";\n</code></pre> <p>O conte\u00fado \u00e9 conhecido em tempo de compila\u00e7\u00e3o, ent\u00e3o o texto \u00e9 adicionado diretamente ao final do execut\u00e1vel (devido estar na stack). Devido isso, esse tipo de uso de <code>string</code> \u00e9 mais r\u00e1pido e eficiente.</p> <p>Com o tipo <code>string</code>, para suportar uma vari\u00e1vel mut\u00e1vel e de tamanho vari\u00e1vel, \u00e9 necess\u00e1rio alocar uma quantidade de mem\u00f3ria da heap, desconhecida em tempo de compila\u00e7\u00e3o. Isso significa:</p> <ul> <li>A mem\u00f3ria \u00e9 requisitada em tempo de execu\u00e7\u00e3o.</li> <li>\u00c9 necess\u00e1rio devolver a mem\u00f3ria alocada, quando a vari\u00e1vel n\u00e3o for mais necess\u00e1ria. </li> </ul> <p>A requisi\u00e7\u00e3o de mem\u00f3ria \u00e9 feita utilizando <code>String::from</code>.</p> <p>Devolver a mem\u00f3ria que n\u00e3o est\u00e1 mais sendo utilizada, \u00e9 um desafio maior. Linguagens que utilizam os garbage collector, ficam buscando por espa\u00e7os de mem\u00f3ria que n\u00e3o s\u00e3o mais utilizados pelo programa, para desalocar o recurso. Para linguagens que n\u00e3o utilizam o garbage collector, \u00e9 de responsabilidade do desenvolvedor identificar quando um espa\u00e7o alocado n\u00e3o \u00e9 mais necess\u00e1rio. Historicamente, esse \u00e9 um problema em computa\u00e7\u00e3o.</p> <p>Em <code>rust</code> a mem\u00f3ria \u00e9 automaticamente retornada quando ela sai do escopo:</p> <pre><code>fn main(){\n\n    // s is not valid here, it\u2019s not yet declared\n    {                      \n        let s = String::from(\"hello\");   // s is valid from this point forward\n\n        println!(\"{s}\");\n    }\n    // s is not valid here, it\u2019s out of scope\n}\n</code></pre> <p>Quando uma vari\u00e1vel sai do escopo, <code>rust</code> chama uma fun\u00e7\u00e3o especial chamada <code>drop</code>. <code>Rust</code> chama o <code>drop</code> automaticamente ao final das chaves (<code>}</code>) em cada escopo.</p> <p>A fun\u00e7\u00e3o <code>drop</code> \u00e9 similar ao Resource Acquisition Is Initialization (RAII) utilizado  em C++.</p>"},{"location":"linguagens/Rust/Cap4/#reatribuindo-variaveis","title":"Reatribuindo vari\u00e1veis","text":"<p>As vari\u00e1veis armazenadas na stack funcionam da mesma forma que outras linguagens de programa\u00e7\u00e3o. <code>Rust</code> se diferencia nas vari\u00e1veis armazenadas na heap, por exemplo:</p> <pre><code>    let s1 = String::from(\"hello\"); \n    let s2 = s1; // s1 no longer valid, after this.\n\n    println!(\"{}, world!\", s2);\n</code></pre> <p>Quando <code>s2 = s1</code>, automaticamente o <code>rust</code> considera <code>s1</code> n\u00e3o mais v\u00e1lido. Uma vez que <code>s2</code> aponta para a mesma regi\u00e3o de mem\u00f3ria de <code>s1</code>, n\u00e3o faz muito sentido termos duas vari\u00e1veis apontando para o mesmo endere\u00e7o. Dessa forma, <code>rust</code> acaba invalidando o a vari\u00e1vel mais antiga, no caso, <code>s1</code>. Essa abordagem \u00e9 conhecida como move. Ent\u00e3o pode-se dizer que <code>s1</code> foi movido para <code>s2</code>.</p> <p>A vantagem dessa abordagem \u00e9 que ela impede de termos o problema de double free error </p> <p>Caso seja necess\u00e1rio fazer um c\u00f3pia de uma vari\u00e1vel que possui valores na heap, <code>rust</code> oferece o comando <code>clone</code>:</p> <pre><code>    let s1 = String::from(\"hello\");\n    let s2 = s1.clone();\n\n    println!(\"s1 = {}, s2 = {}\", s1, s2);\n</code></pre> <p>Agora, ambas as vari\u00e1veis <code>s1</code>e <code>s2</code> est\u00e3o dispon\u00edveis, mas em regi\u00f5es de mem\u00f3ria distintas.</p>"},{"location":"linguagens/Rust/Cap4/#ownership-e-funcoes","title":"Ownership e Fun\u00e7\u00f5es","text":"<p>Trabalhar com fun\u00e7\u00f5es \u00e9 similar as vari\u00e1veis:</p> <pre><code>fn main() {\n    let s = String::from(\"hello\");  // s comes into scope\n\n    takes_ownership(s);             // s's value moves into the function...\n                                    // ... and so is no longer valid here\n\n    let x = 5;                      // x comes into scope\n\n    makes_copy(x);                  // x would move into the function,\n                                    // but i32 is Copy, so it's okay to still\n                                    // use x afterward\n\n} // Here, x goes out of scope, then s. But because s's value was moved, nothing\n  // special happens.\n\nfn takes_ownership(some_string: String) { // some_string comes into scope\n    println!(\"{}\", some_string);\n} // Here, some_string goes out of scope and `drop` is called. The backing\n  // memory is freed.\n\nfn makes_copy(some_integer: i32) { // some_integer comes into scope\n    println!(\"{}\", some_integer);\n} // Here, some_integer goes out of scope. Nothing special happens.\n</code></pre> <p>Novamente, a grande diferen\u00e7a est\u00e1 na linha 4. Uma vez que a vari\u00e1vel <code>s</code> \u00e9 passada para a fun\u00e7\u00e3o, ela n\u00e3o fica mais dispon\u00edvel.</p>"},{"location":"linguagens/Rust/Cap4/#retornando-valores-em-funcoes","title":"Retornando Valores em Fun\u00e7\u00f5es","text":"<p>Retornar valores em <code>rust</code> \u00e9 chamado transfer ownership</p> <pre><code>fn main() {\n    let s1 = gives_ownership();         // gives_ownership moves its return\n                                        // value into s1\n\n    let s2 = String::from(\"hello\");     // s2 comes into scope\n\n    let s3 = takes_and_gives_back(s2);  // s2 is moved into\n                                        // takes_and_gives_back, which also\n                                        // moves its return value into s3\n} // Here, s3 goes out of scope and is dropped. s2 was moved, so nothing\n  // happens. s1 goes out of scope and is dropped.\n\nfn gives_ownership() -&gt; String {             // gives_ownership will move its\n                                             // return value into the function\n                                             // that calls it\n\n    let some_string = String::from(\"yours\"); // some_string comes into scope\n\n    some_string                              // some_string is returned and\n                                             // moves out to the calling\n                                             // function\n}\n\n// This function takes a String and returns one\nfn takes_and_gives_back(a_string: String) -&gt; String { // a_string comes into\n                                                      // scope\n\n    a_string  // a_string is returned and moves out to the calling function\n}\n</code></pre> <p>Nesse caso, a vari\u00e1vel <code>s2</code> \u00e9 passada para a fun\u00e7\u00e3o. Por sua vez, a fun\u00e7\u00e3o retorna a vari\u00e1vel recebida. </p>"},{"location":"linguagens/Rust/Cap4/#referencias-e-emprestimos","title":"Refer\u00eancias e Empr\u00e9stimos","text":"<p>Uma refer\u00eancia \u00e9 como um ponteiro (de <code>C</code>) em que o valor contido no ponteiro \u00e9 outro dono (owner). Diferente de ponteiros, uma refer\u00eancia sempre aponta para um valor v\u00e1lido.</p> <pre><code>fn main() {\n    let s1 = String::from(\"hello\");\n\n    let len = calculate_length(&amp;s1);\n\n    println!(\"The length of '{}' is {}.\", s1, len);\n}\n\nfn calculate_length(s: &amp;String) -&gt; usize {\n    s.len()\n}\n</code></pre> <p>Essa passagem de refer\u00eancia \u00e9 conhecida como empr\u00e9stimo (<code>borrowing</code>), em <code>rust</code>. Caso alguma coisa seja alterada na vari\u00e1vel emprestada, o compilador ir\u00e1 retornar erro.</p> <p>Podemos referenciar uma vari\u00e1vel com <code>&amp;</code> e desreferenciar com <code>*</code>.</p> <p>Para que seja poss\u00edvel fazer altera\u00e7\u00f5es em refer\u00eancias, \u00e9 necess\u00e1rio declarar a refer\u00eancia com <code>mut</code>:</p> <pre><code>fn main() {\n    let mut s = String::from(\"hello\");\n\n    change(&amp;mut s);\n}\n\nfn change(some_string: &amp;mut String) {\n    some_string.push_str(\", world\");\n}\n</code></pre> <p>Refer\u00eancias mut\u00e1veis possuem um grande restri\u00e7\u00e3o. S\u00f3 podemos ter um refer\u00eancia mut\u00e1vel por vez, de uma mesma vari\u00e1vel:</p> <pre><code>fn main() {\n    let mut s = String::from(\"hello\");\n\n    let r1 = &amp;mut s;\n    let r2 = &amp;mut s;\n\n    println!(\"{}, {}\", r1, r2);\n}\n</code></pre> <p>Neste caso, o compilador ir\u00e1 retornar um erro, devido <code>r1</code> e <code>r2</code> est\u00e3o pegando a refer\u00eancia da mesma vari\u00e1vel <code>s</code>.</p> <p>Essa abordagem previne alguns um problema chamado <code>data race</code>, similar a <code>race condition</code>. Esse problema ocorre quando:</p> <ul> <li>2 ou mais ponteiros acessarem um mesmo dado ao mesmo tempo.</li> <li>Pelo menos um dos ponteiros est\u00e1 sendo usado para gravar nos dados.</li> <li>N\u00e3o h\u00e1 nenhum mecanismo sendo usado para sincronizar o acesso aos dados.</li> </ul> <p>Podemos ter refer\u00eancia mut\u00e1vel de uma mesma vari\u00e1vel em tempos diferentes, ou seja, em escopos diferentes:</p> <pre><code>fn main(){\n    let mut s = String::from(\"hello\");\n\n    {\n        let r1 = &amp;mut s;\n    } // r1 goes out of scope here, so we can make a new reference with no problems.\n\n    let r2 = &amp;mut s;\n}\n</code></pre> <p>Podemos fazer um mix de refer\u00eancias mut\u00e1veis e n\u00e3o mut\u00e1veis, desde que de forma correta:</p> <pre><code>fn main(){\n    let mut s = String::from(\"hello\");\n\n    let r1 = &amp;s; // no problem\n    let r2 = &amp;s; // no problem\n    println!(\"{} and {}\", r1, r2);\n    // variables r1 and r2 will not be used after this point\n\n    let r3 = &amp;mut s; // no problem\n    println!(\"{}\", r3);\n}\n</code></pre>"},{"location":"linguagens/Rust/Cap4/#o-tipo-slice","title":"O tipo Slice","text":"<p><code>Slices</code> passam a refer\u00eancia de uma parte cont\u00ednua de elementos de uma cole\u00e7\u00e3o.</p> <pre><code>fn main(){\n    let s = String::from(\"hello world\");\n\n    let hello = &amp;s[0..5];\n    let world = &amp;s[6..11];\n}\n</code></pre> <pre><code>fn main(){\n    let a = [1, 2, 3, 4, 5];\n\n    let slice = &amp;a[1..3];\n\n    assert_eq!(slice, &amp;[2, 3]);\n}\n</code></pre>"},{"location":"linux/boards/Beaglebone/Buildando/","title":"Buildando o Linux","text":"Image by OpenClipart-Vectors from Pixabay"},{"location":"linux/boards/Beaglebone/Buildando/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>Com o intuito de dar uma sequ\u00eancia ao post Habilitando o env.txt com tfpt, vamos seguindo com a build do kernel Linux para a beaglebone. Atualmente tem suas peculiaridades devido sua arquitetura de 32 bits (64 bits se tornou padr\u00e3o em SBCs). Muitos outros artigos podem ser encontrados sobre isso, mas sua grande maioria s\u00e3o antigos e de l\u00e1 pra c\u00e1 algumas coisas mudaram.</p>"},{"location":"linux/boards/Beaglebone/Buildando/#setup","title":"Setup","text":"<p>Para tentar tornar os passos reproduz\u00edveis, segue o setup que eu utilizei para a build:</p> <ul> <li>Distro: Linux Mint 21.1</li> <li>Kernel (host): Linux 6.3.7-060307-generic </li> <li>Toolchain: gcc-arm-10.3-2021.07-x86_64-arm-none-linux-gnueabihf</li> <li>Kernel (target): Linux-mainline-6.1</li> </ul>"},{"location":"linux/boards/Beaglebone/Buildando/#download","title":"Download","text":"<p>Basta utilizar o comando:</p> <pre><code>git clone https://github.com/torvalds/linux.git -b v6.1\n</code></pre>"},{"location":"linux/boards/Beaglebone/Buildando/#build","title":"Build","text":"<p>Aviso</p> <p>N\u00e3o esque\u00e7a de adicionar o caminho dos bin\u00e1rios da toolchain nas vari\u00e1veis de ambiente. No meu caso:  export PATH=/home/joao/Documents/2.Linux/toolchains/gcc-arm-10.3-2021.07-x86_64-arm-none-linux-gnueabihf/bin:$PATH</p> <p>O processo de build pode consistir em 3 passos b\u00e1sicos.</p> <p>Selecionando o <code>defconfig</code>:</p> <pre><code>make ARCH=arm CROSS_COMPILE=arm-none-linux-gnueabihf- -j16 O=out/ omap2plus_defconfig\n</code></pre> <p>Habilitando drivers com o <code>menuconfig</code>:</p> <pre><code>make ARCH=arm CROSS_COMPILE=arm-none-linux-gnueabihf- -j16 O=out/ menuconfig\n</code></pre> <p>Finalmente a build em si:</p> <pre><code>make ARCH=arm CROSS_COMPILE=arm-none-linux-gnueabihf- -j16 O=out/\n</code></pre>"},{"location":"linux/boards/Beaglebone/Buildando/#os-binarios","title":"Os Bin\u00e1rios","text":"<p>Uma vez que o processo de build finalizar, eles estar\u00e3o dispon\u00edveis dentro dos caminhos:</p> <p><pre><code>out/arch/arm/boot\nout/arch/arm/boot/dts\n</code></pre> Os bin\u00e1rios de interesse s\u00e3o <code>out/arch/arm/boot/zImage</code> e <code>out/arch/arm/boot/dts/am335x-boneblack.dtb</code>. Basta copi\u00e1-los para dentro da pasta onde fica o arquivo <code>env.txt</code> no servidor de tftp ou na parti\u00e7\u00e3o <code>boot</code> do cart\u00e3o SD.</p>"},{"location":"linux/boards/Beaglebone/Buildando/#conclusao","title":"Conclus\u00e3o","text":"<p>Estamos buildando uma das vers\u00e3o mais recentes do Kernel Linux atualmente. Dando uma sobre vida maior a beaglebone, o que torna ela ainda muito \u00fatil para o aprendizado de sistemas embarcados (lembrando que ela \u00e9 open hardware)</p>"},{"location":"linux/boards/Beaglebone/USB%20Serial/","title":"USB Serial na Beaglebone","text":"<p>Para conseguir debuggar poss\u00edveis problemas, \u00e9 importante visualizar os logs da porta UART.</p>"},{"location":"linux/boards/Beaglebone/USB%20Serial/#dispositivo","title":"Dispositivo","text":"<p>Estou usando o m\u00f3dulo USB Serial equipado com um chip CP2102</p> <p> </p>    M\u00f3dulo Conversor USB TTL CP2102 Serial RS232"},{"location":"linux/boards/Beaglebone/USB%20Serial/#conexoes","title":"Conex\u00f5es","text":"<p>A Beaglebone tem seus pinos de UART separados das outras GPIOs, isso facilita na hora de fazer as conex\u00f5es.</p> <p> </p>    Conex\u00e3o entre a beaglebone e o m\u00f3dulo USB Serial"},{"location":"linux/boards/Beaglebone/USB%20Serial/#visualizando-os-logs","title":"Visualizando os logs","text":"<p>Depois de fazer as conex\u00f5es, podemos utilizar alguns programas para visualizar os logs que saem da UART. Dentre eles, exitem:</p> <ul> <li>Minicom</li> <li>Screen</li> <li>Picocom</li> <li>E muitos outros</li> </ul> <p>At\u00e9 o momento estou usando o Minicom, mas j\u00e1 usei bastante o Screen.</p>"},{"location":"linux/boards/Beaglebone/USB%20Serial/#resultado","title":"Resultado","text":"Visualizando os logs da UART       Conex\u00e3o com a Beaglebone"},{"location":"linux/boards/Beaglebone/busybox/","title":"Buildando BusyBox","text":"Image by Busybox from Busybox"},{"location":"linux/boards/Beaglebone/busybox/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>Seguindo com os tutoriais Habilitando o env.txt com tfpt e Buildando o Linux, vamos compilar o busybox para termos um Root File System (RFS) m\u00ednimo. Para entendermos o que realmente \u00e9 necess\u00e1rio para termos um distro Linux.</p>"},{"location":"linux/boards/Beaglebone/busybox/#setup","title":"Setup","text":"<ul> <li>Distro: Linux Mint 21.1</li> <li>Kernel: Linux 6.3.7-060307-generic </li> <li>Toolchain: gcc-arm-10.3-2021.07-x86_64-arm-none-linux-gnueabihf</li> <li>Busybox : busybox-1.33.2</li> </ul>"},{"location":"linux/boards/Beaglebone/busybox/#download","title":"Download","text":"<p>Para baixar o busybox podemos utilizar o comando:</p> <pre><code>wget https://busybox.net/downloads/busybox-1.33.2.tar.bz2\n</code></pre> <p>Para extrair:</p> <pre><code>tar -xvjf busybox-1.33.2.tar.bz2\n</code></pre>"},{"location":"linux/boards/Beaglebone/busybox/#build","title":"Build","text":"<p>Aviso</p> <p>N\u00e3o esque\u00e7a de adicionar o caminho dos bin\u00e1rios da toolchain nas vari\u00e1veis de ambiente. No meu caso:  export PATH=/home/joao/Documents/4.Busybox/toolchains/gcc-arm-10.3-2021.07-x86_64-arm-none-linux-gnueabihf/bin:$PATH</p> <p>O processo de build pode consistir em 3 passos b\u00e1sicos.</p> <p>Selecionando o <code>defconfig</code>:</p> <pre><code>make ARCH=arm CROSS_COMPILE=arm-none-linux-gnueabihf- -j16 O=out/ defconfig\n</code></pre> <p>Habilitando recursos com o menuconfig:</p> <pre><code>make ARCH=arm CROSS_COMPILE=arm-none-linux-gnueabihf- -j16 O=out/ menuconfig\n</code></pre> <p>Dica</p> <p>Ativar a compila\u00e7\u00e3o das bibliotecas de forma est\u00e1tica:  Settings -&gt; Build static binary (no shared libs)</p> <p>Finalmente a build em si:</p> <pre><code>make ARCH=arm CROSS_COMPILE=arm-none-linux-gnueabihf- -j16 O=out/ CONFIG_PREFIX=$PWD/../RFS install\n</code></pre> <p>O comando acima ir\u00e1 compilar o busybox e depois copiar  os bin\u00e1rios e hierarquia de pastas para o diret\u00f3rio passado na vari\u00e1vel <code>CONFIG_PREFIX</code></p>"},{"location":"linux/boards/Beaglebone/busybox/#conclusao","title":"Conclus\u00e3o","text":"<p>O busybox \u00e9 o canivete su\u00ed\u00e7o de sistemas embarcados, ele \u00e9 muito utilizado em roteadores (com as devidas modifica\u00e7\u00f5es). Al\u00e9m disso o grub tamb\u00e9m utiliza o busybox. </p>"},{"location":"linux/boards/Beaglebone/Bootloader/U-boot/","title":"U-Boot na Beaglebone","text":"Image by christoph1703 from Pixabay"},{"location":"linux/boards/Beaglebone/Bootloader/U-boot/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>Dando prosseguimento na minha saga por bootloader para embarcados, vou postar meus passos para usar o U-Boot com SD-Card.</p> <p>Baseado no curso da Udemy -&gt; <code>Embedded Linux Step by Step Using Beaglebone Black</code></p>"},{"location":"linux/boards/Beaglebone/Bootloader/U-boot/#baixando","title":"Baixando","text":"<p>O reposit\u00f3rio oficial do U-Boot \u00e9 o da denx:</p> <pre><code>git clone https://source.denx.de/u-boot/u-boot.git\n</code></pre> <p>eles tamb\u00e9m mant\u00e9m um espelho no github</p> <pre><code>git clone https://github.com/u-boot/u-boot.git\n</code></pre> <p>Como a maioria das placas, os criadores portaram o U-Boot para a Beaglebone <pre><code>git clone https://github.com/beagleboard/u-boot.git\n</code></pre></p>"},{"location":"linux/boards/Beaglebone/Bootloader/U-boot/#buildando","title":"Buildando","text":"<p>Primeiro, foi preciso baixar o toolchain</p> <pre><code>sudo apt install gcc-arm-linux-gnueabihf\n</code></pre> <p>Tanto o U-Boot mainline quanto o U-Boot beaglebone possuem o mesmo nome de arquivo para as configura\u00e7\u00f5es padr\u00f5es:</p> <pre><code>am335x_evm_defconfig\n</code></pre> <p>No meu caso, eu utilizei o U-boot mainline.</p> <p>Dessa forma, para criar o <code>.config</code> usei o comando:</p> <pre><code>make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- am335x_evm_defconfig O=out/\n</code></pre> <p>OBS: para limpar o ambiente compila\u00e7\u00e3o, basta usar o comando <code>make distclean</code></p> <p>Por fim, para gerar as imagens, utilizei o comando:</p> <pre><code>make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j16 O=out/\n</code></pre> <p>OBS: -j \u00e9 o par\u00e2metro que define a quantidade de n\u00facleos de processador utilizado no processo de compila\u00e7\u00e3o.</p> <p>Se tudo ocorrer bem, uma mensagem semelhante a essa deve aparecer: </p> <pre><code>  MKIMAGE MLO\n  MKIMAGE MLO.byteswap\n  DTC     arch/arm/dts/am335x-pdu001.dtb\n  DTC     arch/arm/dts/am335x-chiliboard.dtb\n  DTC     arch/arm/dts/am335x-sl50.dtb\n  DTC     arch/arm/dts/am335x-base0033.dtb\n  DTC     arch/arm/dts/am335x-guardian.dtb\n  DTC     arch/arm/dts/am335x-wega-rdk.dtb\n  DTC     arch/arm/dts/am335x-regor-rdk.dtb\n  SHIPPED dts/dt.dtb\n  MKIMAGE u-boot.img\n  CAT     u-boot-dtb.bin\n  COPY    u-boot.dtb\n  MKIMAGE u-boot-dtb.img\n  COPY    u-boot.bin\n</code></pre> <p>Mostrando que os bin\u00e1rios <code>MLO</code> e <code>u-boot.img</code> foram criados.</p>"},{"location":"linux/boards/Beaglebone/Bootloader/U-boot/#utilizando","title":"Utilizando","text":"<p>Com as imagens geradas, precisamos copi\u00e1-las para o cart\u00e3o SD. Para isso, devemos criar, no cart\u00e3o SD, uma parti\u00e7\u00e3o <code>fat 16</code> que ir\u00e1 abrigar o <code>MLO</code>, <code>u-boot.img</code> e tamb\u00e9m a imagem do kernel (200 MB s\u00e3o suficientes). \u00c9 necess\u00e1rio tamb\u00e9m marcar a flag <code>boot</code> depois da cria\u00e7\u00e3o da parti\u00e7\u00e3o, para que a placa carregue o bootloader.</p> <p>Por fim, \u00e9 s\u00f3 colocar o cart\u00e3o SD na beaglebone, segurar o bot\u00e3o <code>S2</code> e ligar a placa.</p>"},{"location":"linux/boards/Beaglebone/Bootloader/U-boot/#estagios","title":"Est\u00e1gios","text":"<p>A forma como a Texas Instruments desenvolveu o SOC AM335x (mais detalhes), se faz necess\u00e1rio que o processo de boot da placa precise de 3 est\u00e1gios</p> <ol> <li>BROM - que \u00e9 definido pela pr\u00f3pria Texas Instruments (n\u00e3o \u00e9 poss\u00edvel modifica-lo)</li> <li>SPL ou Secondary Program Loader - No U-boot chamado de <code>MLO</code> ou Memory LOader</li> <li>O U-boot em si (<code>u-boot.img</code>)</li> </ol> <p>Para maiores detalhes, checar o Technical Reference manual (TRM).</p> <p>No TRM tamb\u00e9m \u00e9 poss\u00edvel verificar que existe a possibilidade de fazer o boot sem um sistema de arquivos no SD-Card/eMMC, na se\u00e7\u00e3o <code>26.1.8.5.5 MMC/SD Read Sector Procedure in Raw Mode</code></p>"},{"location":"linux/boards/Beaglebone/Bootloader/U-boot/#brom","title":"BROM","text":"<p>O BROM faz v\u00e1rias checagens no hardware, mas o que nos interessa nesse est\u00e1gio \u00e9 o que ele busca ap\u00f3s finalizar sua execu\u00e7\u00e3o. O TRM encontramos a seguinte informa\u00e7\u00e3o</p> <pre><code>The next task for the ROM Code is to find the booting file named \u201cMLO\u201d inside \nthe Root Directory of the FAT12/16/32 file system. The file is not searched \nin any other location.\n</code></pre> <p>Ou seja, no nosso SD-Card/eMMC precisamos de uma parti\u00e7\u00e3o do tipo FAT12, FAT16 ou FAT32. Dentro da parti\u00e7\u00e3o, um arquivo chamado <code>MLO</code>.</p>"},{"location":"linux/boards/Beaglebone/Bootloader/U-boot/#mlo","title":"MLO","text":"<p>Resumidamente, o MLO \u00e9 respons\u00e1vel por \"habilitar\" a mem\u00f3ria ram (DRAM) e carregar a imagem do U-Boot para a mesma.</p> <p>Um primeiro teste foi colocar apenas o <code>MLO</code> no SD-Card (sem o <code>u-boot.img</code>) e ver o que aconteceria. E essa foi a mensagem que retornou:</p> <pre><code>U-Boot SPL 2022.04-rc3-00052-g6d3c46ed0e (Sep 11 2022 - 11:17:49 -0400)         \nTrying to boot from MMC1                                                        \nspl_load_image_fat: error reading image u-boot.img, err - -2                    \nSPL: failed to boot from all boot devices                                       \n### ERROR ### Please RESET the board ### \n</code></pre> <p>OBS: Para visualizar o logs de boot, cheque esse post</p> <p>Uma mensagem dizendo n\u00e3o foi poss\u00edvel carregar o <code>u-boot.img</code>. Vale ressaltar que esses logs s\u00e3o do <code>MLO</code>, podemos observar refer\u00eancias ao SPL nos logs.</p> <p>Isso j\u00e1 mostra os primeiros sinais de vida da Beaglebone, mostrando que o SD-Card foi formatado corretamente e a placa est\u00e1 conseguindo detectar o mesmo. Com essas confirma\u00e7\u00f5es, podemos seguir em frente.</p>"},{"location":"linux/boards/Beaglebone/Bootloader/U-boot/#u-bootimg","title":"U-boot.img","text":"<p>Copiando o bin\u00e1rio <code>u-boot.img</code> para o SD-Card \u00e9 poss\u00edvel ver o u-boot carregado, como podemos ver abaixo: <pre><code>U-Boot SPL 2022.04-rc3-00052-g6d3c46ed0e (Sep 11 2022 - 11:17:49 -0400)\nTrying to boot from MMC1\n\n\nU-Boot 2022.04-rc3-00052-g6d3c46ed0e (Sep 11 2022 - 11:17:49 -0400)\n\nCPU  : AM335X-GP rev 2.1\nModel: TI AM335x BeagleBone Black\nDRAM:  512 MiB\nCore:  150 devices, 14 uclasses, devicetree: separate\nWDT:   Started wdt@44e35000 with servicing (60s timeout)\nNAND:  0 MiB\nMMC:   OMAP SD/MMC: 0, OMAP SD/MMC: 1\nLoading Environment from FAT... Unable to read \"uboot.env\" from mmc0:1... \n&lt;ethaddr&gt; not set. Validating first E-fuse MAC\nNet:   eth2: ethernet@4a100000, eth3: usb_ether\nHit any key to stop autoboot:  0 \n</code></pre></p> <p>Dessa forma, consegui compilar e rodar o U-Boot na minha Beaglebone.</p>"},{"location":"linux/boards/Beaglebone/Bootloader/U-boot/#proximos-passos","title":"Pr\u00f3ximos passos","text":"<p>Para o pr\u00f3ximo desafio, fica carregar o kernel Linux. Procurando rapidamente, percebi o u-boot deixou de dar suporte ao arquivo uEnv.txt, o que vai dificultar as coisas um pouco mais. Algumas fontes:</p> <ul> <li>https://forum.beagleboard.org/t/u-boot-ignores-uenv-txt/30549/3</li> </ul> <p>Possivelmente esse commit desabilitou o uEnv.txt </p> <pre><code>https://github.com/u-boot/u-boot/commit/ff8f277e9121c6636e21bb7d7381c4dcac2a596b\\\n</code></pre> <p>Mas tamb\u00e9m encontrei, que existe uma outra forma de carregar as imagens do <code>Kernel</code> e o <code>DTB</code>. Utilizando o Distro Boot (ref)</p> <p>Al\u00e9m de fazer da forma tradicional, que \u00e9 criando o pr\u00f3prio script de boot (ref)</p> <p><pre><code>cat &lt;&lt;\"EOF\" &gt; boot.cmd\nmmc dev 0\nfatload mmc 0:1 ${kernel_addr_r} zImage\nsetenv bootargs console=tty1 console=ttyAMA0,115200 earlyprintk root=/dev/mmcblk0p2 rootwait\nbootz ${kernel_addr_r} - ${fdt_addr}\nEOF\n</code></pre> <pre><code>tools/mkimage -C none -A arm -T script -d boot.cmd boot.scr\n</code></pre></p>"},{"location":"linux/boards/Beaglebone/Bootloader/env/","title":"Habilitando o env.txt com tfpt","text":"Image by christoph1703 from Pixabay"},{"location":"linux/boards/Beaglebone/Bootloader/env/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>Nas vers\u00f5es mais atuais do u-boot n\u00e3o \u00e9 poss\u00edvel usar nativamente o arquivo <code>env.txt</code>, que facilitava a cria\u00e7\u00e3o do script de inicializa\u00e7\u00e3o do bootloader. Essa abordagem era bem \u00fatil pois n\u00e3o era necess\u00e1rio recompilar o u-boot para mudar o script de execu\u00e7\u00e3o. Com o intuito apenas de facilitar os testes na placa, acabei reabilitando esse arquivo.</p> <p>Cuidado</p> <p>Esse post \u00e9 apenas para fins de teste. Essa abordagem teve motivos para ser descontinuada.  Use por sua conta e risco!</p>"},{"location":"linux/boards/Beaglebone/Bootloader/env/#setup","title":"Setup","text":"<p>Para tentar aumentar as chances de reprodu\u00e7\u00e3o dos passos, segue o setup utilizado:</p> <ul> <li>Distro: Linux Mint 21.1</li> <li>Kernel: Linux 6.3.7-060307-generic</li> <li>Toolchain: gcc-arm-10.3-2021.07-x86_64-arm-none-linux-gnueabihf</li> <li>U-boot: u-boot-mainline-2023.04</li> </ul>"},{"location":"linux/boards/Beaglebone/Bootloader/env/#modificacao","title":"Modifica\u00e7\u00e3o","text":"<p>Existem v\u00e1rias formas de habilitar o <code>env.txt</code>, uma delas \u00e9 alterando a vari\u00e1vel <code>CONFIG_BOOTCOMMAND</code> no defconfig <code>am335x_evm_defconfig</code>. Por padr\u00e3o essa vari\u00e1vel vem com os seguintes comandos:</p> <pre><code>CONFIG_BOOTCOMMAND=\"run findfdt; run init_console; run finduuid; run distro_bootcmd\"\n</code></pre> <p>Ela executa as fun\u00e7\u00f5es <code>findfdt</code>, <code>init_console</code>, <code>finduuid</code> e <code>distro_bootcmd</code> respectivamente.</p> <p>Info</p> <p>Para saber onde essas fun\u00e7\u00f5es foram criadas \u00e9 necess\u00e1rio dar uma olhada mais a fundo no arquivo:  <code>include/configs/am335x_evm.h</code> e seus includes.</p> <p>Para reativar o <code>env.txt</code>, podemos fazer a seguinte altera\u00e7\u00e3o:</p> <pre><code>CONFIG_BOOTCOMMAND=\"setenv serverip 192.168.0.203; setenv ipaddr 192.168.0.104; if tftpboot 0x80000000 env.txt; then env import -t 0x80000000 ${filesize}; run agora_vai; fi;\"\n</code></pre> <p>Para facilitar o entendimento do c\u00f3digo, segue o mesmo indentado:</p> <pre><code>setenv serverip 192.168.0.203; \nsetenv ipaddr 192.168.0.104; \nif tftpboot 0x80000000 env.txt; then \n    env import -t 0x80000000 ${filesize}; \n    run agora_vai; \nfi;\n</code></pre> <ul> <li>Na linha 1: \u00c9 setado a vari\u00e1vel de ambiente <code>serverip</code> que ser\u00e1 o ip do servidor tftp.</li> <li>Na linha 2: \u00c9 setados a vari\u00e1vel de ambiente <code>ipaddr</code> que ser\u00e1 o ip da placa.</li> <li>Na linha 3: O arquivo <code>env.txt</code> \u00e9 buscado no servidor e armazenado na mem\u00f3ria ram da placa no endere\u00e7o 0x80000000.</li> <li>Na linha 4: Se tudo ocorrer corretamente, o u-boot carrega o conte\u00fado do arquivo <code>env.txt</code> nas vari\u00e1veis de ambiente.</li> <li>Na linha 5: Executa a fun\u00e7\u00e3o <code>agora_vai</code> que foi escrita dentro do arquivo <code>env.txt</code>.</li> </ul>"},{"location":"linux/boards/Beaglebone/Bootloader/env/#o-arquivo-envtxt","title":"O arquivo env.txt","text":"<p>At\u00e9 o momento o u-boot est\u00e1 preparado para buscar no servidor tftp um arquivo com o nome <code>env.txt</code>. Agora, vamos checar o conte\u00fado desse arquivo:</p> <pre><code>boot_args=setenv bootargs \"console=ttyO0,115200n8 root=/dev/nfs \\\n          ip=192.168.0.104 \\\n          nfsroot=192.168.0.203:/home/joao/Documents/NFS,nfsvers=4 rw rootwait \\\n          loglevel=8\"\n\nload_kernel=tftpboot 0x82000000 zImage\nload_dtb=tftpboot 0x88000000 am335x-boneblack.dtb\nboot_command=bootz 0x82000000 - 0x88000000\n\nagora_vai=run boot_args load_kernel load_dtb boot_command\n</code></pre> <p>A fun\u00e7\u00e3o <code>boot_args</code> adiciona algumas vari\u00e1veis de ambiente que ser\u00e3o passadas ao kernel, relacionadas a Network File System (NFS). A fun\u00e7\u00e3o <code>load_kernel</code> busca no servidor tftp pelo arquivo zImage= (imagem do kernel) e carrega no endere\u00e7o de mem\u00f3ria 0x82000000. Em seguida a fun\u00e7\u00e3o <code>load_dtb</code> carrega no endere\u00e7o de mem\u00f3ria 0x88000000 o arquivo am335x-boneblack.dtb (device tree blob). Em <code>boot_command</code> o u-boot executa o que est\u00e1 nas regi\u00f5es de mem\u00f3ria 0x82000000 (zImage) e 0x88000000 (dtb). Por fim, a fun\u00e7\u00e3o <code>agora_vai</code> executa as fun\u00e7\u00f5es descritas acima.</p> <p>Perceba que esse arquivo n\u00e3o \u00e9 executado imediatamente, ele apenas \u00e9 carregado em mem\u00f3ria. O script s\u00f3 ser\u00e1 executado de fato, quando a fun\u00e7\u00e3o <code>agora_vai</code> for invocada (descrita na se\u00e7\u00e3o anterior na linha 5).</p>"},{"location":"linux/boards/Beaglebone/Bootloader/env/#conclusao","title":"Conclus\u00e3o","text":"<p>Se tudo ocorrer corretamente o kernel Linux ser\u00e1 carregado e executado, mas se o NFS ainda n\u00e3o estiver configurado ir\u00e1 ocorrer um kernel panic devido n\u00e3o ser poss\u00edvel encontrar o <code>init</code>. </p>"},{"location":"linux/boards/qemu/bootloader/LittleKernel/","title":"LittleKernel","text":"Image by StartupStockPhotos from Pixabay"},{"location":"linux/boards/qemu/bootloader/LittleKernel/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>Recentemente descobri que grandes empresas utilizam uma alternativa ao <code>U-Boot</code> para bootloader. Por isso, resolvi escrever esse post sobre o <code>LittleKernel</code>. Ele n\u00e3o tem a popularidade do <code>U-Boot</code>, mas \u00e9 t\u00e3o antigo quanto.</p> <p>Devido sua impopularidade, vamos primeiro seguir o tutorial que utiliza o QEMU. Para que tenhamos um ambiente minimamente funcional.</p>"},{"location":"linux/boards/qemu/bootloader/LittleKernel/#baixando-o-littlekernel","title":"Baixando o LittleKernel","text":"<p>O <code>LittleKernel</code> est\u00e1 hospedado no github. Para baixa-lo, basta utilizar o comando:</p> <pre><code>git clone https://github.com/littlekernel/lk.git\n</code></pre> <p>Checando o diret\u00f3rios com o comando <code>tree -L 1 .</code>, temos a seguinte configura\u00e7\u00e3o:</p> <pre><code>.\n\u251c\u2500\u2500 app\n\u251c\u2500\u2500 arch\n\u251c\u2500\u2500 build-qemu-virt-arm32-test\n\u251c\u2500\u2500 dev\n\u251c\u2500\u2500 docs\n\u251c\u2500\u2500 engine.mk\n\u251c\u2500\u2500 external\n\u251c\u2500\u2500 kernel\n\u251c\u2500\u2500 lib\n\u251c\u2500\u2500 LICENSE\n\u251c\u2500\u2500 lk_inc.mk.example\n\u251c\u2500\u2500 make\n\u251c\u2500\u2500 makefile\n\u251c\u2500\u2500 platform\n\u251c\u2500\u2500 project\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 scripts\n\u251c\u2500\u2500 target\n\u251c\u2500\u2500 tools\n\u2514\u2500\u2500 top\n</code></pre>"},{"location":"linux/boards/qemu/bootloader/LittleKernel/#instalando-as-dependencias","title":"Instalando as depend\u00eancias","text":"<p>Para esse post, vou utilizar o <code>qemu-system-arm</code>. Para isso, \u00e9 preciso instala-lo:</p> <pre><code>sudo apt-install qemu-system-arm\n</code></pre> <p>Na pr\u00f3pria p\u00e1gina do <code>Littekernel</code> tem uma sugest\u00e3o para toolchain:</p> <pre><code>sudo apt-get install gcc-arm-none-eabi\n</code></pre> <p>E essas s\u00e3o as depend\u00eancias iniciais.</p>"},{"location":"linux/boards/qemu/bootloader/LittleKernel/#buildando","title":"Buildando","text":"<p>Os desenvolvedores do <code>LittleKernel</code> fornecem um script para rodar o bootloader no QEMU. Basta entrar na pasta do reposit\u00f3rio e digitar:</p> <pre><code>scripts/do-qemuarm\n</code></pre> <p>Esse comando ir\u00e1 compilar o <code>LittleKernel</code> e carrega-lo no QEMU. Como resultado o terminal (ou console) do bootloader ser\u00e1 carregado e as seguintes mensagens devem parecer:</p> <pre><code>welcome to lk/MP\n\nboot args 0x0 0x0 0x0 0x0\nINIT: cpu 0, calling hook 0x8011c5ed (version) at level 0x3ffff, flags 0x1\nversion:\n    arch:     arm\n    platform: qemu-virt-arm\n    target:   qemu-virt-arm\n    project:  qemu-virt-arm32-test\n    buildid:  L9PCS_LOCAL\nINIT: cpu 0, calling hook 0x8011e18d (vm_preheap) at level 0x3ffff, flags 0x1\ninitializing heap\ncalling constructors\nINIT: cpu 0, calling hook 0x8011e1d5 (vm) at level 0x4ffff, flags 0x1\ninitializing mp\ninitializing threads\ninitializing timers\ninitializing ports\ncreating bootstrap completion thread\ntop of bootstrap2()\nINIT: cpu 0, calling hook 0x801196e9 (minip) at level 0x70000, flags 0x1\nINIT: cpu 0, calling hook 0x80119eb1 (pktbuf) at level 0x70000, flags 0x1\npktbuf: creating 256 pktbuf entries of size 1536 (total 393216)\nINIT: cpu 0, calling hook 0x8011cf85 (virtio) at level 0x70000, flags 0x1\nreleasing 0 secondary cpus\ninitializing platform\nPCIE: initializing pcie with ecam at 0x3f000000 found in FDT\nPCI: pci ecam functions installed\nPCI: last pci bus is 15\nPCI dump:\n  bus 0\n   dev 0000:00:00.0 vid:pid 1b36:0008 base:sub:intr 6:0:0 \nPCI dump post assign:\n  bus 0\n   dev 0000:00:00.0 vid:pid 1b36:0008 base:sub:intr 6:0:0 \ninitializing target\nINIT: cpu 0, calling hook 0x8011ced5 (e1000) at level 0x90001, flags 0x1\ninitializing apps\nstarting app inetsrv\nstarting internet servers\nstarting app shell\nentering main console loop\n] \n</code></pre> <p>Pode digitar o comando <code>help</code> e come\u00e7ar a desbrav\u00e1-lo.</p> <p>Para sair, \u00e9 preciso usar as seguintes teclas: CTRL + A e depois c. O terminal sair\u00e1 do <code>LittleKernel</code> e entrar\u00e1 no QEMU:</p> <pre><code> QEMU 4.2.1 monitor - type 'help' for more information\n(qemu) \n</code></pre> <p>Por fim, bast digitar quit.</p>"},{"location":"linux/boards/qemu/bootloader/LittleKernel/#decifrando-o-do-qemuarm","title":"Decifrando o do-qemuarm","text":"<p>Esse script possui muitas linhas, mas as 3 \u00faltimas linhas resumem o processo:</p> <pre><code>$DIR/make-parallel $MAKE_VARS $PROJECT &amp;&amp;\necho $SUDO $QEMU $ARGS $@ &amp;&amp;\n$SUDO $QEMU $ARGS $@\n</code></pre> <p>Na linha 132:</p> <ul> <li><code>$MAKE_VARS</code> \u00e9 vazio</li> <li><code>$PROJECT</code> \u00e9 <code>\"qemu-virt-arm32-test\"</code><ul> <li>Esse nome \u00e9 referente a um arquivo dentro do diret\u00f3rio <code>projects/</code> na pasta raiz.</li> </ul> </li> <li>Esses s\u00e3o os par\u00e2metros para compilar o <code>LittleKernel</code>.</li> </ul> <p>Na linha 133:</p> <ul> <li>Mostra o comando completo para emula\u00e7\u00e3o do <code>LittleKernel</code> pelo QEMU:</li> </ul> <pre><code>qemu-system-arm -cpu cortex-a15 -m 512 -smp 1 -machine virt,highmem=off -kernel build-qemu-virt-arm32-test/lk.elf -net none -nographic\n</code></pre> <ul> <li> <p>Baseado no comando gerado, pode-se observar que \u00e9 criado a pasta <code>build-qemu-virt-arm32-test</code> e dentro dela o arquivo <code>lk.elf</code>. Esse arquivo \u00e9 o bin\u00e1rio gerado pela compila\u00e7\u00e3o do <code>LittleKernel</code>. Na linha 134:</p> </li> <li> <p>Executa a emula\u00e7\u00e3o.</p> </li> </ul>"},{"location":"linux/boards/qemu/bootloader/LittleKernel/#conclusao","title":"Conclus\u00e3o","text":"<p>Com esses passos \u00e9 poss\u00edvel come\u00e7ar a explorar o <code>LittleKernel</code> e tirar as primeiras impress\u00f5es. Particularmente, achei a estrutura de pastas mais amig\u00e1vel que o do <code>U-Boot</code>. Isso n\u00e3o quer dizer que seja melhor ou pior, mas parece mais f\u00e1cil de organizar.</p>"},{"location":"linux/boards/qemu/bootloader/U-boot_qemu/","title":"U-boot","text":"Image by PublicDomainPictures from Pixabay"},{"location":"linux/boards/qemu/bootloader/U-boot_qemu/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>A fim de ter um ambiente de testes para aprender sobre o U-Boot, o mais recomendado \u00e9 criar um ambiente virtual. Para isso, eu escolhi o QEMU, que \u00e9 altamente configur\u00e1vel.</p> <p>Essa postagem tem como base a arquitetura <code>aarch64</code>, devido sua larga utiliza\u00e7\u00e3o em sistemas embarcados.</p>"},{"location":"linux/boards/qemu/bootloader/U-boot_qemu/#baixando-o-u-boot-mainline","title":"Baixando o U-Boot mainline","text":"<p>Basta copiar e colar o c\u00f3digo abaixo: </p> <pre><code>git clone https://source.denx.de/u-boot/u-boot.git\n</code></pre>"},{"location":"linux/boards/qemu/bootloader/U-boot_qemu/#buildando-o-u-boot","title":"Buildando o U-boot","text":"<p>A seguir s\u00e3o definidos alguns passos para gerar o bin\u00e1rio do U-boot, que ser\u00e1 utilizado pelo QEMU.</p>"},{"location":"linux/boards/qemu/bootloader/U-boot_qemu/#instalando-dependencias","title":"Instalando Depend\u00eancias","text":"<p>Dependendo do sistema utilizado, alguns pacotes ser\u00e3o necess\u00e1rios para que o processo de build tenha sucesso. No meu ambiente (<code>ubuntu 22.04</code>), foram necess\u00e1rio os seguintes pacotes:</p> <pre><code>sudo apt install \\\n    flex \\\n    bison \\\n    gcc-aarch64-linux-gnu \\\n</code></pre>"},{"location":"linux/boards/qemu/bootloader/U-boot_qemu/#definindo-a-arquitetura","title":"Definindo a Arquitetura","text":"<p>Para criar um sistema de build limpo, o par\u00e2metro <code>O=</code> foi utilizado. Dentro da pasta do U-Boot, cole o c\u00f3digo abaixo:</p> <pre><code>make O=../out qemu_arm64_defconfig -j16\n</code></pre> <p>Se tudo ocorrer bem, a mensagem a seguir deve aparecer:</p> <p></p> <p>Uma pasta <code>out</code> foi criada, adicionando todos os itens necess\u00e1rios para a build.</p> <p></p>"},{"location":"linux/boards/qemu/bootloader/U-boot_qemu/#gerando-o-binario","title":"Gerando o Bin\u00e1rio","text":"<p>Dentro da pasta <code>out</code>, cole o c\u00f3digo abaixo:</p> <pre><code>make CROSS_COMPILE=aarch64-linux-gnu- -j16\n</code></pre> <p>Se tudo ocorrer corretamente o arquivo <code>u-boot.bin</code> ser\u00e1 criado.</p> <p></p>"},{"location":"linux/boards/qemu/bootloader/U-boot_qemu/#carregando-o-u-boot-com-qemu","title":"Carregando o U-boot com QEMU","text":"<p>Para utilizar o QEMU para arquiteturas ARM64 \u00e9 necess\u00e1rio instalar o pacote:</p> <pre><code>sudo apt install qemu-system-arm\n</code></pre> <p>Dentro da pasta <code>out</code>, execute o seguinte comando:</p> <pre><code>qemu-system-aarch64 -M virt -nographic -cpu cortex-a57  -bios u-boot.bin\n</code></pre> <p>onde o par\u00e2metro <code>-bios</code> \u00e9 o binario que acabou de ser criado pela nossa build.</p> <p>Ap\u00f3s executar o comando, o u-boot dever\u00e1 iniciar normalmente:</p> <p></p>"},{"location":"linux/boards/vim3/bootloader/u-boot/","title":"U-boot na VIM3 (SD Card)","text":"U-boot logo <p>baseado no tutorial do pr\u00f3prio u-boot no readthedocs</p>"},{"location":"linux/boards/vim3/bootloader/u-boot/#organizando-a-estrutura-de-pastas","title":"Organizando a estrutura de pastas","text":"<p>Ser\u00e3o necess\u00e1rios v\u00e1rios arquivos e pastas durante esse post. Devido isso, iremos usar a seguinte estrutura de pastas</p> <pre><code>.\n\u251c\u2500\u2500 fip\n\u251c\u2500\u2500 toolchain\n\u251c\u2500\u2500 u-boot-mainline\n\u2514\u2500\u2500 u-boot-vim3\n</code></pre> <p>Elas ser\u00e3o criadas ao longo deste post.</p>"},{"location":"linux/boards/vim3/bootloader/u-boot/#baixando-o-u-boot-mainline","title":"Baixando o u-boot Mainline","text":"<p>O u-boot possui um reposit\u00f3rio no github. Vamos baixa-lo dentro da pasta u-boot-mainline:</p> <pre><code>git clone https://github.com/u-boot/u-boot.git u-boot-mainline\n</code></pre> <p>Para fazer o cross compile \u00e9 necess\u00e1rio baixar as toolchain. As vers\u00f5es novas do u-boot precisam de vers\u00f5es novas de toolchain, que podem ser encontradas no site da ARM. Nesse post estou usando a vers\u00e3o gcc-arm-10.3-2021.07 (meu link de backup).</p>"},{"location":"linux/boards/vim3/bootloader/u-boot/#compilando-o-u-boot-mainline","title":"Compilando o u-boot mainline","text":"<p>Uma vez baixado a toolchain (gcc-arm-10.3-2021.07), vamos criar a pasta toolchain e mover a toolchain baixada para dentro dela.</p> <p>Agora, precisamos descompactar a toochain e adicionar os bin\u00e1rios ao path do sistema. Para isso</p> <pre><code>export PATH=CAMINHO_ABSOLUTO/toolchain/gcc-arm-10.3-2021.07-x86_64-aarch64-none-elf/bin:$PATH\n</code></pre> <p>Observe que a pasta <code>/bin</code> est\u00e1 sendo adicionada ao path. Nela est\u00e3o os execut\u00e1veis que ser\u00e3o utilizados durante o processo de build.</p> <p>Volte para a pasta do u-boot-mainline e execute os seguintes comandos:</p> <pre><code>make khadas-vim3_defconfig O=out/\nmake CROSS_COMPILE=aarch64-none-elf- O=out/\n</code></pre> <p>O par\u00e2metro <code>O</code> define a pasta onde os arquivos compilados ser\u00e3o salvos.</p> <p>O argumento <code>CROSS_COMPILE=aarch64-none-elf-</code> informa qual toolchain ser\u00e1 utilizada no momento da compila\u00e7\u00e3o, essa toolchain precisa estar no path do sistema (como fizemos anteriormente). Dentro os v\u00e1rios compiladores dispon\u00edveis, podemos ver que existem alguns bem conhecidos: <code>c++</code>, <code>cpp</code>, <code>g++</code> e muitos outros.</p> <pre><code>toolchain/gcc-arm-10.3-2021.07-x86_64-aarch64-none-elf/bin\n\u251c\u2500\u2500 aarch64-none-elf-addr2line\n\u251c\u2500\u2500 aarch64-none-elf-ar\n\u251c\u2500\u2500 aarch64-none-elf-as\n\u251c\u2500\u2500 aarch64-none-elf-c++\n\u251c\u2500\u2500 aarch64-none-elf-c++filt\n\u251c\u2500\u2500 aarch64-none-elf-cpp\n\u251c\u2500\u2500 aarch64-none-elf-elfedit\n\u251c\u2500\u2500 aarch64-none-elf-g++\n...\n</code></pre> <p>Se tudo ocorrer como o esperado, uma mensagem similar a essa:</p> <pre><code>aarch64-none-elf-ld.bfd: warning: -z norelro ignored\nOBJCOPY lib/efi_loader/initrddump.efi\nLD      u-boot\nOBJCOPY u-boot.srec\nOBJCOPY u-boot-nodtb.bin\nRELOC   u-boot-nodtb.bin\nCAT     u-boot-dtb.bin\nCOPY    u-boot.bin\nSYM     u-boot.sym\nLD      u-boot.elf\nmake[1]: Leaving directory 'CAMINHO_ABSOLUTO/u-boot-mainline/out'\n</code></pre> <p>O arquivo <code>u-boot.bin</code> deve ter sido gerado dentro da pasta <code>out</code>.</p>"},{"location":"linux/boards/vim3/bootloader/u-boot/#baixando-u-boot-vim3","title":"Baixando u-boot VIM3","text":"<p>A Khadas tamb\u00e9m possui um reposit\u00f3rio com as vers\u00f5es do u-boot para as diversas placas que eles produzem. Vamos baixar o brach <code>khadas-vims-v2015.01</code> dentro da pasta u-boot-vim3</p> <p><pre><code>git clone https://github.com/khadas/u-boot.git -b khadas-vims-v2015.01 u-boot-vim3\n</code></pre> Para fazer o cross compile \u00e9 necess\u00e1rio baixar as toolchain.  Seguindo o tutorial base, precisaremos de 2 toolchain (<code>none-elf</code> e <code>none-eabi</code>):</p> <ul> <li>gcc-linaro-aarch64-none-elf-4.8-2013.11 - Linaro<ul> <li>gcc-linaro-aarch64-none-elf-4.8-2013.11 (backup).</li> </ul> </li> <li>gcc-linaro-arm-none-eabi-4.8-2013.11 - Linaro<ul> <li>gcc-linaro-arm-none-eabi-4.8-2013.11 (backup).</li> </ul> </li> </ul>"},{"location":"linux/boards/vim3/bootloader/u-boot/#compilando-o-u-boot-vim3","title":"Compilando o u-boot VIM3","text":"<p>Antes de adicionar as novas toolchain ao path, limpe o terminal (abra um novo terminal). A vers\u00e3o utilizada no u-boot-mainline n\u00e3o \u00e9 compat\u00edvel com a vers\u00e3o da VIM3</p> <p>Com as 2 toolchain baixadas, mova-as para a pastas toolchain e descompacte cada uma em sua respectiva pasta. Por fim, adicionar os bin\u00e1rios dos 2 toolchain ao path do sistema</p> <pre><code>export PATH=CAMINHO_ABSOLUTO/toolchain/gcc-linaro-aarch64-none-elf-4.8-2013.11_linux/bin:$PATH\nexport PATH=CAMINHO_ABSOLUTO/toolchain/gcc-linaro-arm-none-eabi-4.8-2013.11_linux/bin:$PATH \n</code></pre> <p>Com os caminhos adicionados, podemos compilar o u-boot-vim3:</p> <pre><code>make kvim3_defconfig O=out/\nmake CROSS_COMPILE=aarch64-none-elf- O=out/\n</code></pre> <p>O par\u00e2metro <code>O</code> define a pasta onde os arquivos compilados ser\u00e3o salvos.</p> <p>Se tudo ocorrer bem, uma mensagem similar deve aparecer:</p> <pre><code>  LD      CAMINHO_ABSOLUTO/u-boot-vim3/out/board/khadas/kvim3/firmware/acs.elf\n  OD      CAMINHO_ABSOLUTO/u-boot-vim3/out/board/khadas/kvim3/firmware/acs.dump\n  BIN     CAMINHO_ABSOLUTO/u-boot-vim3/out/board/khadas/kvim3/firmware/acs.bin\n\nBuilt CAMINHO_ABSOLUTO/u-boot-vim3/out/board/khadas/kvim3/firmware/acs.bin successfully\n\n\n    CPP task_entry.s\n    CPP user_task.lds\n    CC task_entry.o\n    CC user_task.o\n    CPP misc.s\n    CC misc.o\n    CC uart.o\n    CC suspend.o\n    CC lib/string.o\n    CC lib/delay.o\n    LD CAMINHO_ABSOLUTO/u-boot-vim3/out/scp_task/bl301.out\n    OBJDUMP CAMINHO_ABSOLUTO/u-boot-vim3/out/scp_task/bl301.dis\n    OBJCOPY CAMINHO_ABSOLUTO/u-boot-vim3/out/scp_task/bl301.bin\n</code></pre>"},{"location":"linux/boards/vim3/bootloader/u-boot/#juntando-tudo","title":"Juntando tudo","text":"<p>O primeiro passo \u00e9 criar a pasta fip.</p> <p>Segundo, \u00e9 preciso baixar esse script da BayLibre ou no meu backup e mover para dentro da pasta fip</p> <p>Para mais informa\u00e7\u00f5es sobre o que \u00e9, acesse:  FIP + compilados</p> <p>Terceiro, \u00e9 preciso copiar v\u00e1rios arquivos para dentro da pasta fip:</p> <pre><code># Arquivos compilados no u-boot-VIM3\ncp u-boot-vim3/out/scp_task/bl301.bin fip \ncp u-boot-vim3/out/board/khadas/kvim3/firmware/acs.bin fip\n\n# Copia o u-boot.bin (mainline) e renomeia para bl33.bin\ncp u-boot-mainline/out/u-boot.bin fip/bl33.bin\n\n# Arquivos pr\u00e9-compilados (s\u00e3o fornecidos pela khadas)\ncp u-boot-vim3/fip/g12b/bl2.bin fip\ncp u-boot-vim3/fip/g12b/bl30.bin fip\ncp u-boot-vim3/fip/g12b/bl31.bin fip\ncp u-boot-vim3/fip/g12b/ddr3_1d.fw fip\ncp u-boot-vim3/fip/g12b/ddr4_1d.fw fip\ncp u-boot-vim3/fip/g12b/ddr4_2d.fw fip\ncp u-boot-vim3/fip/g12b/diag_lpddr4.fw fip\ncp u-boot-vim3/fip/g12b/lpddr3_1d.fw fip\ncp u-boot-vim3/fip/g12b/lpddr4_1d.fw fip\ncp u-boot-vim3/fip/g12b/lpddr4_2d.fw fip\ncp u-boot-vim3/fip/g12b/piei.fw fip\ncp u-boot-vim3/fip/g12b/aml_ddr.fw fip\ncp u-boot-vim3/fip/g12b/aml_encrypt_g12b fip \n</code></pre>"},{"location":"linux/boards/vim3/bootloader/u-boot/#concatenando-os-arquivos","title":"Concatenando os arquivos","text":"<p>Pra concatenar as informa\u00e7\u00f5es, vamos utilizar o script da baylibre (dentro da pasta fip)</p> <pre><code># Adiciona um padding no bl30.bin e bl301.bin \n# depois concatena os dois, gerando bl30_new.bin\nbash blx_fix_g12a.sh bl30.bin zero_tmp bl30_zero.bin bl301.bin bl301_zero.bin bl30_new.bin bl30\n\n# Adiciona um padding no bl2.bin e acs.bin \n# depois concatena os dois, gerando bl2_new.bin\nbash blx_fix_g12a.sh bl2.bin  zero_tmp bl2_zero.bin  acs.bin   bl21_zero.bin  bl2_new.bin  bl2\n</code></pre>"},{"location":"linux/boards/vim3/bootloader/u-boot/#encriptando-os-arquivos","title":"Encriptando os arquivos","text":"<p>Para mais informa\u00e7\u00f5es, acesse: link</p> <pre><code># Adiciona assinatura no cabe\u00e7alho do bin\u00e1rio\n./aml_encrypt_g12b --bl2sig  --input bl2_new.bin             --output bl2.n.bin.sig\n\n# Adiciona assinatura no cabe\u00e7alho do bin\u00e1rio\n./aml_encrypt_g12b --bl3sig  --input bl31.bin                --output bl31.img.enc          --level v3 --type bl3\n\n# Adiciona e encripta a assinatura no cabe\u00e7alho do bin\u00e1rio\n./aml_encrypt_g12b --bl30sig --input bl30_new.bin            --output bl30_new.bin.g12a.enc --level v3\n./aml_encrypt_g12b --bl3sig  --input bl30_new.bin.g12a.enc   --output bl30_new.bin.enc      --level v3 --type bl301\n\n# Adiciona a assinatura no cabe\u00e7alho, um padding no final do bin\u00e1rio e comprime o bin\u00e1rio\n./aml_encrypt_g12b --bl3sig  --input bl33.bin --compress lz4 --output bl33.bin.enc          --level v3 --type bl33 --compress lz4\n\n# Gera o bin\u00e1rio do u-boot com as assinaturas concatenadas\n./aml_encrypt_g12b --bootmk --output u-boot-bin --bl2 bl2.n.bin.sig --bl30 bl30_new.bin.enc --bl31 bl31.img.enc \\\n                                                --bl33 bl33.bin.enc --ddrfw1 ddr4_1d.fw --ddrfw2 ddr4_2d.fw \\\n                                                --ddrfw3 ddr3_1d.fw --ddrfw4 piei.fw --ddrfw5 lpddr4_1d.fw \\\n                                                --ddrfw6 lpddr4_2d.fw --ddrfw7 diag_lpddr4.fw --ddrfw8 aml_ddr.fw \\\n                                                --ddrfw9 lpddr3_1d.fw --level v3\n</code></pre>"},{"location":"linux/boards/vim3/bootloader/u-boot/#passando-o-u-boot-para-o-sd-card","title":"Passando o u-boot para o SD Card","text":"<pre><code>$ DEV=/dev/your_sd_device\n$ dd if=fip/u-boot.bin.sd.bin of=$DEV conv=fsync,notrunc bs=512 skip=1 seek=1\n$ dd if=fip/u-boot.bin.sd.bin of=$DEV conv=fsync,notrunc bs=1 count=444\n</code></pre>"},{"location":"linux/outros/nfs_server/","title":"Criando um Servidor NFS","text":"Image by Michael Schwarzenberger from Pixabay"},{"location":"linux/outros/nfs_server/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>Uma vez que o Kernel Linux \u00e9 carregado, ele busca pelo Root Filesystem (RFS). Ele geralmente \u00e9 flashado no mmc ou cart\u00e3o SD, mas existem outras formas de disponibiliza-lo. Uma delas \u00e9 por meio do Network Filesytem (NFS). Dessa forma, o RFS fica dispon\u00edvel via rede. Com isso, n\u00e3o \u00e9 necess\u00e1rio re-flashar toda vez que alguma altera\u00e7\u00e3o for feita no RFS.</p>"},{"location":"linux/outros/nfs_server/#configurando-o-servidor","title":"Configurando o Servidor","text":"<p>S\u00e3o necess\u00e1rios os seguintes passos.</p>"},{"location":"linux/outros/nfs_server/#dependencias","title":"Depend\u00eancias","text":"<p>\u00c9 preciso instalar o pacote <code>nfs-kernel-server</code>, ele \u00e9 respons\u00e1vel por levantar no servidor NFS:</p> <pre><code>sudo apt install nfs-kernel-server\n</code></pre>"},{"location":"linux/outros/nfs_server/#arquivos-de-configuracao","title":"Arquivos de Configura\u00e7\u00e3o","text":"<p>Devemos informar qual o caminho em que os arquivos ser\u00e3o compartilhados. Para isso, devemos informar no arquivo:</p> <pre><code>/etc/exports\n</code></pre> <p>E na \u00faltima linha, devemos adicionar:</p> <pre><code>/home/joao/Documents/NFS 192.168.0.104(rw,sync,no_subtree_check)\n</code></pre> <p>Perceba que \u00e9 passado o caminho que ser\u00e1 compartilhado, o IP que poder\u00e1 acessar esse caminho e algumas outras op\u00e7\u00f5es.</p>"},{"location":"linux/outros/nfs_server/#permissoes","title":"Permiss\u00f5es","text":"<p>Se for a caso, crie o caminho que ser\u00e1 compartilhado, por exemplo:</p> <pre><code>mkdir -p /home/joao/Documents/NFS\n</code></pre> <p>Como um outro dispositivo ir\u00e1 acessar essa pasta (no nosso exemplo, a beaglebone), a pasta criada precisa ter permiss\u00f5es para isso. Primeiro, vamos configurar os usu\u00e1rios:</p> <pre><code>sudo chown nobody:nogroup /home/joao/Documents/NFS\n</code></pre> <p>Por fim, dando acesso total a pasta:</p> <pre><code>sudo chmod 777 /home/joao/Documents/NFS\n</code></pre> <p>Cuidado</p> <p>Cuidado ao utilizar o comando acima. Usar o <code>777</code> \u00e9 altamente desencorajado. Lembre-se que esse \u00e9 um setup de testes.</p>"},{"location":"linux/outros/nfs_server/#reiniciando-o-servico","title":"Reiniciando o Servi\u00e7o","text":"<p>Por fim, basta reiniciar o servi\u00e7o para que ele carregue as novas configura\u00e7\u00f5es:</p> <pre><code>sudo exportfs -a\nsudo systemctl restart nfs-kernel-server\n</code></pre>"},{"location":"linux/outros/nfs_server/#conclusao","title":"Conclus\u00e3o","text":"<p>Seguindo esses passos \u00e9 poss\u00edvel deixar um RFS acess\u00edvel via rede, o que facilita os testes que v\u00e3o ocorrendo. Um ponto importante \u00e9 configurar os argumentos do Kernel Linux, nesse caso:</p> <pre><code>boot_args=root=/dev/nfs \\\n          ip=192.168.0.104 \\\n          nfsroot=192.168.0.203:/home/joao/Documents/NFS,nfsvers=4 rw rootwait\n</code></pre> <p>Dessa forma, o kernel saber\u00e1 qual IP utilizar e em qual IP buscar o RFS.</p>"},{"location":"linux/outros/tftp_server/","title":"Criando um Servidor TFTP","text":"Image by OpenClipart-Vectors from Pixabay"},{"location":"linux/outros/tftp_server/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>Com a ideia de facilitar o processo de testes do bootloader, Kernel Linux e do Root FS \u00e9 poss\u00edvel uma rede de computadores para carregar o Kernel e o Root FS, ao inv\u00e9s de flashar no cart\u00e3o SD. O primeiro passo \u00e9 saber como configurar o servidor. Para isso, foi utilizado o protocolo TFTP. Por fim, configurar o bootloader para buscar a imagem do Kernel Linux e o DTB no servidor, que foi mostrado no post Habilitando o env.txt com tfpt</p>"},{"location":"linux/outros/tftp_server/#configurando-o-servidor","title":"Configurando o Servidor","text":"<p>\u00c9 necess\u00e1rio instalar algumas depend\u00eancias e configurar alguns arquivos.</p>"},{"location":"linux/outros/tftp_server/#dependencias","title":"Depend\u00eancias","text":"<p>Podemos instalar os pacotes <code>xinetd</code>, <code>tftp</code> e <code>tftpd</code> com o comando:</p> <pre><code>sudo apt-get install xinetd tftp tftpd\n</code></pre>"},{"location":"linux/outros/tftp_server/#arquivo-de-configuracao","title":"Arquivo de Configura\u00e7\u00e3o","text":"<p>O servi\u00e7o do TFTP busca o arquivo <code>tftp</code>, para isso devemos cria-lo:</p> <pre><code>sudo touch /etc/xinetd.d/tftp \n</code></pre> <p>Dentro do arquivo precisamos adicionar algumas informa\u00e7\u00f5es:</p> <pre><code>service tftp\n{\nprotocol = udp\nport = 69\nsocket_type = dgram\nwait = yes\nuser = nobody\nserver = /usr/sbin/in.tftpd\nserver_args = /home/joao/Documents/TFTP -s\ndisable = no\n}\n</code></pre> <p>O par\u00e2metro <code>server_args</code> \u00e9 o local onde ficar\u00e1 os arquivos que ser\u00e3o compartilhados.</p> <p>Se for o caso, agora crie a pasta configurada no par\u00e2metro <code>server_args</code>:</p> <pre><code>mkdir -p /home/joao/Documents/TFTP\n</code></pre>"},{"location":"linux/outros/tftp_server/#permissoes","title":"Permiss\u00f5es","text":"<p>Como um outro dispositivo ir\u00e1 acessar essa pasta (no nosso exemplo, a beaglebone), a pasta criada precisa ter permiss\u00f5es para isso. Primeiro, vamos configurar os usu\u00e1rios:</p> <pre><code>sudo chown nobody:nogroup /home/joao/Documents/TFTP\n</code></pre> <p>Por fim, dando acesso total a pasta:</p> <pre><code>sudo chmod 777 /home/joao/Documents/TFTP\n</code></pre> <p>Cuidado</p> <p>Cuidado ao utilizar o comando acima. Usar o <code>777</code> \u00e9 altamente desencorajado. Lembre-se que esse \u00e9 um setup de testes.</p>"},{"location":"linux/outros/tftp_server/#reiniciando-o-servico","title":"Reiniciando o Servi\u00e7o","text":"<p>Por fim, basta reiniciar o servi\u00e7o para que ele carregue as novas configura\u00e7\u00f5es:</p> <pre><code>sudo /etc/init.d/xinetd restart\n</code></pre>"},{"location":"linux/outros/tftp_server/#conclusao","title":"Conclus\u00e3o","text":"<p>O TFTP pode ser utilizado para compartilhar arquivos de forma geral, mas o prop\u00f3sito desse post \u00e9 fazer com que o u-boot acesse o servidor criado e possa baixar a imagem do Kernel Linux.</p>"},{"location":"outros/Parti%C3%A7%C3%B5es/GPT/","title":"Tabela de Parti\u00e7\u00e3o GUID","text":"<p>baseado nos link1, link2 e link3</p>"},{"location":"outros/Parti%C3%A7%C3%B5es/GPT/#consideracoes-iniciais","title":"Considera\u00e7\u00f5es iniciais","text":"<p>Vamos utilizar um cart\u00e3o micro SD de 32GB. Para identificarmos o cart\u00e3o no sistema, utilizamos o comando <code>lsblk</code>, o resultado ser\u00e1 similar a essa</p> <pre><code>\u2570\u2500 lsblk  \nNAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT\nsda           8:0    0 894,3G  0 disk \n\u2514\u2500sda1        8:1    0 894,3G  0 part /run/timeshift/backup\nsdc           8:32   1  29,1G  0 disk \n\u2514\u2500sdc1        8:33   1  29,1G  0 part \nnvme0n1     259:0    0 465,8G  0 disk \n\u251c\u2500nvme0n1p1 259:1    0   476M  0 part /boot/efi\n\u251c\u2500nvme0n1p2 259:2    0  30,5G  0 part [SWAP]\n\u2514\u2500nvme0n1p3 259:3    0 434,8G  0 part /\n</code></pre> <p>Para ter certeza qual \u00e9 o cart\u00e3o SD, execute o <code>lsblk</code> com o cart\u00e3o n\u00e3o conectado e depois conecte o cart\u00e3o e execute o comando novamente (simples ). No caso acima, o cart\u00e3o SD \u00e9 o <code>/dev/sdc</code>.</p> <p>Para facilitar a visualiza\u00e7\u00e3o das altera\u00e7\u00f5es que iremos fazer, vamos zerar os primeiros 10240 bytes do cart\u00e3o. Para isso, utilizaremos o comando <code>dd</code></p> <pre><code>sudo dd if=/dev/zero of=/dev/sdc bs=1024 count=10\n</code></pre> <p>Podemos visualizar conte\u00fado do cart\u00e3o, com o comando <code>hexdump</code></p> <pre><code>sudo hexdump -C /dev/sdc -n 10240\n</code></pre> <p>O resultado deve ser similar a esse</p> <pre><code>00000000  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n*\n00002800\n</code></pre> <p>o n\u00famero 00002800 \u00e9 em hexadecimal e seu equivalente em decimal \u00e9 10240 (ou 10 kB).</p>"},{"location":"outros/Parti%C3%A7%C3%B5es/GPT/#formatando-o-cartao-com-gpt","title":"Formatando o cart\u00e3o com GPT","text":"<p>Com os primeiros bytes do cart\u00e3o SD zerados, vamos adicionar a parti\u00e7\u00e3o GPT ao cart\u00e3o com o comando <code>fdisk</code></p> <pre><code>sudo fdisk /dev/sdc\n</code></pre> <p>Um menu ir\u00e1 aparecer:</p> <ul> <li>Digite <code>g</code></li> <li>Depois digite <code>n</code><ul> <li>Partition number (1-128, default 1): <code>Enter</code></li> <li>First sector (2048-61067230, default 2048): <code>Enter</code></li> <li>Last sector, +/-sectors or +/-size{K,M,G,T,P} (2048-61067230, default 61067230): <code>Enter</code></li> </ul> </li> <li>Por fim, digite <code>w</code></li> </ul> <p>Agora o cart\u00e3o est\u00e1 com o particionamento GPT. Para checar, vamos visualizar novamente o conte\u00fado do cart\u00e3o SD</p> <pre><code>00000000  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n*\n000001c0  02 00 ee ff ff ff 01 00  00 00 ff cf a3 03 00 00  |................|\n000001d0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n*\n000001f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 55 aa  |..............U.|\n00000200  45 46 49 20 50 41 52 54  00 00 01 00 5c 00 00 00  |EFI PART....\\...|\n00000210  fc d8 3a 53 00 00 00 00  01 00 00 00 00 00 00 00  |..:S............|\n00000220  ff cf a3 03 00 00 00 00  00 08 00 00 00 00 00 00  |................|\n00000230  de cf a3 03 00 00 00 00  90 30 7b d4 f3 72 46 59  |.........0{..rFY|\n00000240  89 2c 7f 77 9e b0 00 e6  02 00 00 00 00 00 00 00  |.,.w............|\n00000250  80 00 00 00 80 00 00 00  f1 ae 2f f5 00 00 00 00  |........../.....|\n00000260  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n*\n00000400  af 3d c6 0f 83 84 72 47  8e 79 3d 69 d8 47 7d e4  |.=....rG.y=i.G}.|\n00000410  9c 58 84 76 3e 65 45 92  a4 ec 96 ed 84 df 22 99  |.X.v&gt;eE.......\".|\n00000420  00 08 00 00 00 00 00 00  de cf a3 03 00 00 00 00  |................|\n00000430  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n*\n00002800\n</code></pre> <p>Esses dados mostram que o GPT est\u00e1 sendo usando no cart\u00e3o SD.</p>"},{"location":"outros/Parti%C3%A7%C3%B5es/GPT/#o-backup-de-seguranca","title":"O Backup de seguran\u00e7a","text":"<p>Como uma forma de seguran\u00e7a contra perda de dados, o GPT faz um backup da parti\u00e7\u00e3o no final disco. Para checar basta utilizar o comando:</p> <pre><code>sudo tail -c 10M /dev/sdc | hexdump -C\n</code></pre> <p>Visualizando os \u00faltimos 10 MB do cart\u00e3o SD, encontramos o seguinte conte\u00fado</p> <p><pre><code>747900000  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n*\n7479fbe00  af 3d c6 0f 83 84 72 47  8e 79 3d 69 d8 47 7d e4  |.=....rG.y=i.G}.|\n7479fbe10  9c 58 84 76 3e 65 45 92  a4 ec 96 ed 84 df 22 99  |.X.v&gt;eE.......\".|\n7479fbe20  00 08 00 00 00 00 00 00  de cf a3 03 00 00 00 00  |................|\n7479fbe30  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n*\n7479ffe00  45 46 49 20 50 41 52 54  00 00 01 00 5c 00 00 00  |EFI PART....\\...|\n7479ffe10  66 9b 01 67 00 00 00 00  ff cf a3 03 00 00 00 00  |f..g............|\n7479ffe20  01 00 00 00 00 00 00 00  00 08 00 00 00 00 00 00  |................|\n7479ffe30  de cf a3 03 00 00 00 00  90 30 7b d4 f3 72 46 59  |.........0{..rFY|\n7479ffe40  89 2c 7f 77 9e b0 00 e6  df cf a3 03 00 00 00 00  |.,.w............|\n7479ffe50  80 00 00 00 80 00 00 00  f1 ae 2f f5 00 00 00 00  |........../.....|\n7479ffe60  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n*\n747a00000\n</code></pre> Podemos perceber um espelho dos dados do inicio do disco.</p>"},{"location":"outros/Parti%C3%A7%C3%B5es/GPT/#o-logical-block-addressing","title":"O Logical Block Addressing","text":"<p>O Logical Block Addressing ou LBA, s\u00e3o blocos de informa\u00e7\u00e3o utilizado pelo GPT. Esses blocos possuem 512 bytes.</p>"},{"location":"outros/Parti%C3%A7%C3%B5es/GPT/#lba0","title":"LBA0","text":"<p>O <code>LBA0</code> existe para compatibilidade com o Master Boot Record (MBR), checando os primeiros 512 bytes do cart\u00e3o SD</p> <pre><code>sudo hexdump -C /dev/sdc -s 0 -n 512\n</code></pre> <p>Temos esse resultado:</p> <pre><code>00000000  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n*\n000001c0  02 00 ee ff ff ff 01 00  00 00 ff cf a3 03 00 00  |................|\n000001d0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n*\n000001f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 55 aa  |..............U.|\n00000200\n</code></pre> <p>Nada relevante pode ser visto aqui (a n\u00e3o ser que voc\u00ea esteja usando MBR )</p>"},{"location":"outros/Parti%C3%A7%C3%B5es/GPT/#lba1","title":"LBA1","text":"<p>Esse LBA possui o cabe\u00e7alho da tabela de parti\u00e7\u00e3o. Visualizando os pr\u00f3ximos 512 bytes do cart\u00e3o SD</p> <pre><code>sudo hexdump -C /dev/sdc -s 512 -n 512\n</code></pre> <p>Temos os seguintes dados:</p> <pre><code>00000200  45 46 49 20 50 41 52 54  00 00 01 00 5c 00 00 00  |EFI PART....\\...|\n00000210  d2 61 e7 36 00 00 00 00  01 00 00 00 00 00 00 00  |.a.6............|\n00000220  ff cf a3 03 00 00 00 00  00 08 00 00 00 00 00 00  |................|\n00000230  de cf a3 03 00 00 00 00  46 8a 0b 22 c3 8c 45 75  |........F..\"..Eu|\n00000240  8c ef f5 bd 9e 32 4c 5b  02 00 00 00 00 00 00 00  |.....2L[........|\n00000250  80 00 00 00 80 00 00 00  af 06 c5 b4 00 00 00 00  |................|\n00000260  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n*\n00000400\n</code></pre> <p>Agora vamos entender esse vetor de bytes:</p> <p>Esses dados s\u00e3o Little Endian. Para interpretarmos o valor em decimal, devemos converter para Big Endian</p> <ul> <li>A assinatura s\u00e3o os primeiros 8 bytes</li> </ul> <pre><code>00000200  45 46 49 20 50 41 52 54                           |EFI PART|\n00000208\n</code></pre> <ul> <li>A revis\u00e3o s\u00e3o os 4 pr\u00f3ximos bytes</li> </ul> <pre><code>00000208  00 00 01 00                                       |....|\n0000020c\n</code></pre> <ul> <li>O tamanho do cabe\u00e7alho s\u00e3o os 4 pr\u00f3ximos bytes</li> </ul> <pre><code>0000020c  5c 00 00 00                                       |\\...|\n00000210\n</code></pre> <ul> <li>O CRC32 da parti\u00e7\u00e3o s\u00e3o os 4 pr\u00f3ximos bytes</li> </ul> <pre><code>00000210  d2 61 e7 36                                       |.a.6|\n00000214\n</code></pre> <ul> <li>Os pr\u00f3ximos 4 bytes s\u00e3o reservados e devem ser 0's</li> </ul> <pre><code>00000214  00 00 00 00                                       |....|\n00000218\n</code></pre> <ul> <li>Endere\u00e7o do LBA atual s\u00e3o os 8 pr\u00f3ximos bytes</li> </ul> <pre><code>00000218  01 00 00 00 00 00 00 00                           |........|\n00000220\n</code></pre> <ul> <li>Localiza\u00e7\u00e3o do LBA espelho (backup) s\u00e3o os 8 pr\u00f3ximos bytes</li> </ul> <pre><code>00000220  ff cf a3 03 00 00 00 00                           |........|\n00000228\n</code></pre> <p>Big Endian: 00 00 00 00 03 A3 CF FF | Decimal 61067263. Isso indica que o LBA espelho est\u00e1 no setor 61067263. Para acessa-lo podemos utilizar o comando: sudo dd if=/dev/sdc bs=512 count=1 skip=61067263</p> <ul> <li>Primeiro setor dispon\u00edvel para parti\u00e7\u00e3o s\u00e3o os pr\u00f3ximos 8 bytes</li> </ul> <pre><code>00000228  00 08 00 00 00 00 00 00                           |........|\n00000230\n</code></pre> <p>00 00 08 00 00 00 00 00 -&gt; 2048</p> <ul> <li>\u00daltimo setor dispon\u00edvel para parti\u00e7\u00e3o s\u00e3o os pr\u00f3ximos 8 bytes</li> </ul> <pre><code>00000230  de cf a3 03 00 00 00 00                           |........|\n00000238\n</code></pre> <p>Big endian: 0000000003A3CFDE | Decimal: 61067230. O \u00faltimo setor dispon\u00edvel \u00e9 o 61067230.</p> <ul> <li>O GUID s\u00e3o os pr\u00f3ximos 16 bytes</li> </ul> <pre><code>00000238  46 8a 0b 22 c3 8c 45 75  8c ef f5 bd 9e 32 4c 5b  |F..\"..Eu.....2L[|\n00000248\n</code></pre> <p>O GUID possui segmenta\u00e7\u00f5es: 468a0b22-c38c-4575-8cef-f5bd9e324c5b. Os primeiros 8 bytes s\u00e3o convertidos para big endian e o restante n\u00e3o \u00e9 convertido, resultando em: 220B8A46-8CC3-7545-8CEF-F5BD9E324C5B</p> <ul> <li>O setor que inicia as tabelas de parti\u00e7\u00e3o s\u00e3o os pr\u00f3ximos 8 bytes</li> </ul> <pre><code>00000248  02 00 00 00 00 00 00 00                           |........|\n00000250\n</code></pre> <ul> <li>Quantidades poss\u00edveis de parti\u00e7\u00f5es s\u00e3o os pr\u00f3ximos 4 bytes</li> </ul> <pre><code>00000250  80 00 00 00                                       |....|\n00000254\n</code></pre> <ul> <li>Tamanho de um entrada da tabela de parti\u00e7\u00e3o s\u00e3o os pr\u00f3ximos 4 bytes</li> </ul> <pre><code>00000254  80 00 00 00                                       |....|\n00000258\n</code></pre> <ul> <li>CRC32 de todas as entradas de parti\u00e7\u00e3o do disco s\u00e3o os pr\u00f3ximos 4 bytes</li> </ul> <pre><code>00000258  af 06 c5 b4                                       |....|\n0000025c\n</code></pre> <ul> <li>Restante do espa\u00e7o s\u00e3o 420 bytes</li> </ul> <pre><code>0000025c  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n*\n00000400\n</code></pre>"},{"location":"outros/Parti%C3%A7%C3%B5es/GPT/#lb2-lbn","title":"LB2 - LBN","text":"<pre><code>00000400  af 3d c6 0f 83 84 72 47  8e 79 3d 69 d8 47 7d e4  |.=....rG.y=i.G}.|\n00000410  a0 d5 b4 b0 cf d0 4d fe  b7 09 a8 3f 44 67 bd b7  |......M....?Dg..|\n00000420  00 08 00 00 00 00 00 00  de cf a3 03 00 00 00 00  |................|\n00000430  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n*\n00000480\n</code></pre> <ul> <li>Tipo de parti\u00e7\u00e3o GUID s\u00e3o os primeiros 16 bytes</li> </ul> <pre><code>00000400  af 3d c6 0f 83 84 72 47  8e 79 3d 69 d8 47 7d e4  |.=....rG.y=i.G}.|\n00000410\n</code></pre> <ul> <li>GUID \u00fanico s\u00e3o os pr\u00f3ximos 16 bytes</li> </ul> <pre><code>00000410  a0 d5 b4 b0 cf d0 4d fe  b7 09 a8 3f 44 67 bd b7  |......M....?Dg..|\n00000420\n</code></pre> <ul> <li>Primeiro setor dispon\u00edvel para parti\u00e7\u00e3o s\u00e3o os pr\u00f3ximos 8 bytes</li> </ul> <pre><code>00000420  00 08 00 00 00 00 00 00                           |........|\n00000428\n</code></pre> <ul> <li>\u00daltimo setor dispon\u00edvel para parti\u00e7\u00e3o s\u00e3o os pr\u00f3ximos 8 bytes</li> </ul> <pre><code>00000428  de cf a3 03 00 00 00 00                           |........|\n00000430\n</code></pre> <ul> <li>Os atributos s\u00e3o os pr\u00f3ximos 8 bytes</li> </ul> <pre><code>00000430  00 00 00 00 00 00 00 00                           |........|\n00000438\n</code></pre> <ul> <li>O nome da parti\u00e7\u00e3o s\u00e3o os pr\u00f3ximos 72 bytes</li> </ul> <pre><code>00000438  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n*\n00000480\n</code></pre>"},{"location":"outros/mkdocs/mkdocs/","title":"Documenta\u00e7\u00e3o com MKDOCS","text":"Image by WikiImages from Pixabay"},{"location":"outros/mkdocs/mkdocs/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>Essa postagem foi inspirado na live de python #189. Se quiser mais informa\u00e7\u00f5es sobre MKDocs da uma olhada no v\u00eddeo e deixa o like. </p> <p>O MKDocs \u00e9 uma biblioteca focada em documenta\u00e7\u00e3o, desenvolvida em python. Ela possui v\u00e1rias funcionalidades e algumas delas ser\u00e3o mostradas abaixo.</p> <p>Para instalar:</p> <pre><code>pip install mkdocs\n</code></pre> <p>Ap\u00f3s a instala\u00e7\u00e3o basta digitar:</p> <pre><code>mkdocs new TESTE\n</code></pre> <p>Os arquivos necess\u00e1rios para iniciar a documenta\u00e7\u00e3o ser\u00e3o criados.</p>"},{"location":"outros/mkdocs/mkdocs/#markdown-basico","title":"Markdown B\u00e1sico","text":"<p>Comandos dispon\u00edveis por padr\u00e3o na biblioteca.</p>"},{"location":"outros/mkdocs/mkdocs/#titulo-h1","title":"T\u00edtulo (H1)","text":"<pre><code># Exemplo\n</code></pre>"},{"location":"outros/mkdocs/mkdocs/#subtitulo-h2","title":"Subtitulo (H2)","text":"<pre><code>## Exemplo\n</code></pre>"},{"location":"outros/mkdocs/mkdocs/#subsubtitulo-h3","title":"Subsubtitulo (H3)","text":"<pre><code>### Exemplo\n</code></pre>"},{"location":"outros/mkdocs/mkdocs/#negrito","title":"Negrito","text":"<pre><code>**Exemplo**\n</code></pre> <p>Exemplo</p>"},{"location":"outros/mkdocs/mkdocs/#italico","title":"It\u00e1lico","text":"<pre><code>*Exemplo*\n</code></pre> <p>Exemplo</p>"},{"location":"outros/mkdocs/mkdocs/#citacao","title":"Cita\u00e7\u00e3o","text":"<pre><code>&gt; Exemplo\n</code></pre> <p>Exemplo</p>"},{"location":"outros/mkdocs/mkdocs/#lista-ordenada","title":"Lista Ordenada","text":"<pre><code>1. Exemplo\n2. Exemplo\n3. Exemplo\n</code></pre> <ol> <li>Exemplo</li> <li>Exemplo</li> <li>Exemplo</li> </ol>"},{"location":"outros/mkdocs/mkdocs/#lista-nao-ordenada","title":"Lista N\u00e3o Ordenada","text":"<pre><code>- Exemplo\n- Exemplo\n- Exemplo\n</code></pre> <ul> <li>Exemplo</li> <li>Exemplo</li> <li>Exemplo</li> </ul>"},{"location":"outros/mkdocs/mkdocs/#linha-de-codigo","title":"Linha de C\u00f3digo","text":"<pre><code>`C\u00f3digo`\n</code></pre> <p><code>C\u00f3digo</code></p>"},{"location":"outros/mkdocs/mkdocs/#link","title":"Link","text":"<pre><code>[Site do google](https://www.google.com.br)\n</code></pre> <p>Site do google</p>"},{"location":"outros/mkdocs/mkdocs/#tabela","title":"Tabela","text":"<pre><code>| Nome | Idade |\n| ---- | ----- |\n| Jo\u00e3o | 28    |\n| Pedro | 34   |\n</code></pre> Nome Idade Jo\u00e3o 28 Pedro 34"},{"location":"outros/mkdocs/mkdocs/#markdown-estendido","title":"Markdown Estendido","text":"<p>Para ter ainda mais funcionalidades, \u00e9 necess\u00e1rio instalar a biblioteca PyMdown Extensions:</p> <pre><code>pip install pymdown-extensions\n</code></pre> <p>Al\u00e9m disso, \u00e9 necess\u00e1rio adicionar quais extens\u00f5es ser\u00e3o usadas dentro do arquivo <code>mkdocs.yml</code>, por exemplo:</p> <pre><code>markdown_extensions:\n  - pymdownx.tasklist\n  - pymdownx.emoji\n  - pymdownx.mark\n  - pymdownx.tilde\n</code></pre> <p>Cada uma dessas extens\u00f5es ser\u00e3o mostradas a seguir.</p>"},{"location":"outros/mkdocs/mkdocs/#lista-de-tarefas","title":"Lista de Tarefas","text":"<p><code>pymdownx.tasklist</code></p> <pre><code>- [ ] Checar.\n- [ ] checar.\n- [X] checado.\n</code></pre> <ul> <li> Checar.</li> <li> checar.</li> <li> checado.</li> </ul>"},{"location":"outros/mkdocs/mkdocs/#emoji","title":"Emoji","text":"<p>Para mais emojis: emojipedia. Escolha um emoji e procure por <code>Shortcodes</code>.</p> <p><code>pymdownx.emoji</code></p> <pre><code>:snake: :heart: :rocket:\n</code></pre> <p> </p>"},{"location":"outros/mkdocs/mkdocs/#tachado","title":"Tachado","text":"<p><code>pymdownx.tilde</code> <pre><code>~~Exemplo~~\n</code></pre></p> <p>Exemplo</p>"},{"location":"outros/mkdocs/mkdocs/#realcado","title":"Real\u00e7ado","text":"<p><code>pymdownx.mark</code></p> <pre><code>==Exemplo==\n</code></pre> <p>Exemplo</p>"},{"location":"outros/mkdocs/mkdocs/#super-fences","title":"Super Fences","text":"<p>Dentro do <code>pymdown-extensions</code> existe uma funcionalidade que merece um t\u00f3pico a parte, chamado de  <code>superfences</code>. Com ele, o MKDocs fica ainda mais poderoso.</p> <p>\u00c9 necess\u00e1rio informar para o MKDocs que o super fences ser\u00e1 utilizado, adicionando as linhas dentro do <code>mkdocs.yml</code>:</p> <pre><code>markdown_extensions:\n  # ...\n  - pymdownx.superfences:\n      custom_fences:\n        - name: mermaid\n          class: mermaid\n          format: !!python/name:pymdownx.superfences.fence_div_format\n\nextra_javascript:\n  - https://unpkg.com/mermaid@8.5.1/dist/mermaid.min.js\n</code></pre>"},{"location":"outros/mkdocs/mkdocs/#bloco-de-codigo","title":"Bloco de c\u00f3digo","text":"<p><code>pymdownx.superfences</code></p> <pre><code>    ```{.py3 linenums=\"44\" title=\"teste.py\" hl_lines=\"1 3\"}\n    def xpto():\n        \"\"\"Docstring\"\"\"\n        return True\n    ```\n</code></pre> teste.py<pre><code>def xpto():\n    \"\"\"Docstring\"\"\"\n    return True\n</code></pre>"},{"location":"outros/mkdocs/mkdocs/#formulas","title":"F\u00f3rmulas","text":"<p><code>pymdownx.arithmatex</code></p> <pre><code>$$ \\operatorname{ker} f=\\{g\\in G:f(g)=e_{H}\\}{\\mbox{.}} $$\n</code></pre> <p>$$ \\operatorname{ker} f={g\\in G:f(g)=e_{H}}{\\mbox{.}} $$</p> <pre><code>The homomorphism $f$ is injective if and only if its kernel is only the \nsingleton set $e_G$, because otherwise $\\exists a,b\\in G$ with $a\\neq b$ such \nthat $f(a)=f(b)$.\n</code></pre> <p>The homomorphism $f$ is injective if and only if its kernel is only the  singleton set $e_G$, because otherwise $\\exists a,b\\in G$ with $a\\neq b$ such  that $f(a)=f(b)$.</p>"},{"location":"outros/mkdocs/mkdocs/#custom-fences","title":"Custom Fences","text":"<p>\u00c9 poss\u00edvel incorporar outras bibliotecas dentro do MKDocs, por exemplo a Mermaid que \u00e9 uma biblioteca para gerar diagramas e gr\u00e1ficos. Para isso, \u00e9 necess\u00e1rio adicionar no <code>mkdocs.yml</code></p> <pre><code>  - pymdownx.superfences:\n      custom_fences:\n        - name: mermaid\n          class: mermaid\n          format: !!python/name:pymdownx.superfences.fence_div_format\n\nextra_javascript:\n  - https://unpkg.com/mermaid@8.5.1/dist/mermaid.min.js\n</code></pre> <pre><code>    ```mermaid\n    classDiagram\n        Pessoa &lt;|-- Eduardo\n        class Pessoa{\n            +String nome\n            +metodo(self):bool\n        }\n    ```\n</code></pre> <pre><code>classDiagram\n    Pessoa &lt;|-- Jao\n    class Pessoa{\n        +String nome\n        +metodo(self):bool\n    }\n</code></pre>"},{"location":"rtos/zephyr/zephyr/","title":"Zephyr + Esp32 + Blinky = \u2764\ufe0f","text":"Image by methodshop from Pixabay"},{"location":"rtos/zephyr/zephyr/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>Recentemente voltei a pesquisar sobre Internet of Things (IoT) e durante uma conversas no trabalho fiquei sabendo do Zephyr. Por sorte, um Webnar da Embarcados aconteceu e pude me interar mais sobre essa plataforma. S\u00f3 tenho uma palavra para definir: Sensacional \ud83e\udd2f</p>"},{"location":"rtos/zephyr/zephyr/#instalando-dependencias","title":"Instalando depend\u00eancias","text":"<p>Estou usando <code>Ubuntu 22.04</code>.</p> <pre><code>sudo apt install --no-install-recommends git cmake ninja-build gperf \\\n  ccache dfu-util device-tree-compiler wget \\\n  python3-dev python3-pip python3-setuptools python3-tk python3-wheel xz-utils file \\\n  make gcc gcc-multilib g++-multilib libsdl2-dev\n</code></pre> <p>O Zephyr usa o python para gerenciar os pacotes, algumas depend\u00eancias tamb\u00e9m s\u00e3o necess\u00e1rias</p> <p><pre><code>pip3 install west\n</code></pre> Ap\u00f3s isso, \u00e9 necess\u00e1rio definir o local onde os arquivos ser\u00e3o salvos. No exemplo vou usar o caminho <code>/home/jao/Documents/Workspace/IoT</code></p> <pre><code>west init /home/jao/Documents/Workspace/IoT/PASTA_DO_ZEPHYR\n</code></pre> <p>Alguns arquivos ser\u00e3o baixados do reposit\u00f3rio.</p> <p>Em seguida:</p> <p>PS: Demora...</p> <pre><code>cd /home/jao/Documents/Workspace/IoT/PASTA_DO_ZEPHYR\nwest update\n</code></pre> <p>Depois de terminar a atualiza\u00e7\u00e3o, \u00e9 necess\u00e1rio exportar algumas vari\u00e1veis de ambiente:</p> <pre><code>west zephyr-export\n</code></pre> <p>e ent\u00e3o instalar as dep\u00eancencias restantes do python:</p> <pre><code>pip3 install -r /home/jao/Documents/Workspace/IoT/PASTA_DO_ZEPHYR/zephyr/scripts/requirements.txt\n</code></pre>"},{"location":"rtos/zephyr/zephyr/#baixando-a-toolchain","title":"Baixando a toolchain","text":"<p>Como vamos utilizar o Esp32, a toolchain pode ser baixada aqui. No meu caso estou usando a plataforma <code>linux-amd64</code></p> <p>Ap\u00f3s baixar a toolchain correto, extraia e adicione o caminho da pasta a vari\u00e1vel de ambiente <code>ESPRESSIF_TOOLCHAIN_PATH</code></p> <pre><code>export ESPRESSIF_TOOLCHAIN_PATH=/home/jao/Documents/Workspace/IoT/xtensa-esp32-elf/xtensa-esp32-elf/\n</code></pre> <p>\u00c9 necess\u00e1rio adicionar outra vari\u00e1vel:</p> <pre><code>export ZEPHYR_TOOLCHAIN_VARIANT=\"espressif\"\n</code></pre> <p>Finalmente, podemos baixar os pacotes referentes ao Esp32 do Zephyr:</p> <p>PS: O camando deve ser dado dentro da pasta do Zephyr, no caso: /home/jao/Documents/Workspace/IoT/PASTA_DO_ZEPHYR</p> <pre><code>west espressif update\n</code></pre> <p>Ap\u00f3s esse passo, o ambiente de configura\u00e7\u00e3o para o Esp32 estar\u00e1 finalizado.</p>"},{"location":"rtos/zephyr/zephyr/#exemplo-blinky","title":"Exemplo Blinky","text":"<p>Na vers\u00e3o atual do Zephyr <code>3.0.0</code>, \u00e9 necess\u00e1rio adicionar um m\u00f3dulo no device driver para que o led built-in sej\u00e1 reconhecido. Para isso, \u00e9 necess\u00e1rio criar um arquivo dentro do exemplo do Blincky do pr\u00f3prio Zephyr</p> <pre><code>touch /home/jao/Documents/Workspace/IoT/PASTA_DO_ZEPHYR/zephyr/samples/basic/blinky/esp32.overlay\n</code></pre> <p>o arquivo deve conter o seguinte conte\u00fado:</p> <pre><code>/ {\n    aliases {\n        led0 = &amp;led0;\n    };\n\n    leds {\n        compatible = \"gpio-leds\";\n        led0: led_0 {\n            gpios = &lt;&amp;gpio0 2 GPIO_ACTIVE_HIGH&gt;;\n            label = \"LED 0\";\n        };\n    };\n};\n</code></pre> <p>Na linha <code>gpios = &lt;&amp;gpio0 2 GPIO_ACTIVE_HIGH&gt;;</code>, o n\u00famero 2 \u00e9 referente ao gpio associado ao led built-in.</p> <p>Agora \u00e9 s\u00f3 compilar:</p> <p>PS: dentro da pasta: /home/jao/Documents/Workspace/IoT/PASTA_DO_ZEPHYR/</p> <pre><code>west build -p auto -b esp32  zephyr/samples/basic/blinky\n</code></pre> <p>Muitas vezes o arquivo CMakeCache.txt, precisa ser deletado. Ele fica localizado em : /home/jao/Documents/Workspace/IoT/PASTA_DO_ZEPHYR/build/</p> <p>Se tudo ocorrer bem, a seguinte mensagem deve aparecer:</p> <pre><code>[103/103] Linking C executable zephyr/zephyr.elf\nMemory region         Used Size  Region Size  %age Used\n     mcuboot_hdr:          32 B         32 B    100.00%\n        metadata:          28 B         32 B     87.50%\n             ROM:       31172 B    4194240 B      0.74%\n     iram0_0_seg:       13004 B       128 KB      9.92%\n     irom0_0_seg:       13692 B    3342304 B      0.41%\n     dram0_0_seg:        1240 B     180736 B      0.69%\n     dram0_1_seg:         53 KB     110032 B     49.32%\n     drom0_0_seg:        3826 B    4194240 B      0.09%\n    rtc_iram_seg:          0 GB         8 KB      0.00%\n    rtc_slow_seg:          0 GB         4 KB      0.00%\n        IDT_LIST:          0 GB         8 KB      0.00%\nesptool.py v3.3-dev\nCreating esp32 image...\nMerged 6 ELF sections\nSuccessfully created esp32 image.\n</code></pre> <p>Para flashar no esp32, pasta digitar o seguinte comando:</p> <pre><code>west flash\n</code></pre> <p>O resultado deve ser algo semelhante:</p> <pre><code>Flash will be erased from 0x00010000 to 0x00033fff...\nFlash params set to 0x0220\nWrote 32768 bytes at 0x00001000 in 0.7 seconds (390.4 kbit/s)...\nHash of data verified.\nWrote 16384 bytes at 0x00008000 in 0.3 seconds (515.8 kbit/s)...\nHash of data verified.\nWrote 147456 bytes at 0x00010000 in 2.0 seconds (594.7 kbit/s)...\nHash of data verified.\n\nLeaving...\nHard resetting via RTS pin...\n</code></pre> <p>Se o seguinte erro acontecer:</p> <p>/dev/ttyS0 failed to connect: Failed to connect to Espressif device: No serial data received. For troubleshooting steps visit: https://docs.espressif.com/projects/esptool/en/latest/troubleshooting.html</p> <p>A fatal error occurred: Could not connect to an Espressif device on any of the 2 available serial ports.</p> <p>Talvez seja necess\u00e1rio ficar segurando o bot\u00e3o <code>boot</code> do Esp32.</p> <p>\u00c9 isso, at\u00e9 a pr\u00f3xima.</p>"}]}